"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/../node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var SyncLane = /*                        */ 1;\n        var InputContinuousLane = /*            */ 4;\n        var DefaultLane = /*                    */ 16;\n        var IdleLane = /*                       */ 536870912;\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        exports.ConcurrentRoot = ConcurrentRoot;\n        exports.ContinuousEventPriority = ContinuousEventPriority;\n        exports.DefaultEventPriority = DefaultEventPriority;\n        exports.DiscreteEventPriority = DiscreteEventPriority;\n        exports.IdleEventPriority = IdleEventPriority;\n        exports.LegacyRoot = LegacyRoot;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3hDO1FBQ0g7UUFFQSxJQUFJQyxXQUNKLDBCQUEwQixHQUMxQjtRQUNBLElBQUlDLHNCQUNKLGNBQWMsR0FDZDtRQUNBLElBQUlDLGNBQ0osc0JBQXNCLEdBQ3RCO1FBQ0EsSUFBSUMsV0FDSix5QkFBeUIsR0FDekI7UUFFQSxJQUFJQyx3QkFBd0JKO1FBQzVCLElBQUlLLDBCQUEwQko7UUFDOUIsSUFBSUssdUJBQXVCSjtRQUMzQixJQUFJSyxvQkFBb0JKO1FBRXhCLElBQUlLLGFBQWE7UUFDakIsSUFBSUMsaUJBQWlCO1FBRXJCQyxzQkFBc0IsR0FBR0Q7UUFDekJDLCtCQUErQixHQUFHTDtRQUNsQ0ssNEJBQTRCLEdBQUdKO1FBQy9CSSw2QkFBNkIsR0FBR047UUFDaENNLHlCQUF5QixHQUFHSDtRQUM1Qkcsa0JBQWtCLEdBQUdGO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0aWZvbGlvMjAyNC8uLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanM/N2VkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIElucHV0Q29udGludW91c0xhbmUgPVxuLyogICAgICAgICAgICAqL1xuNDtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIElkbGVMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xuXG52YXIgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gU3luY0xhbmU7XG52YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lO1xudmFyIERlZmF1bHRFdmVudFByaW9yaXR5ID0gRGVmYXVsdExhbmU7XG52YXIgSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlTGFuZTtcblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIENvbmN1cnJlbnRSb290ID0gMTtcblxuZXhwb3J0cy5Db25jdXJyZW50Um9vdCA9IENvbmN1cnJlbnRSb290O1xuZXhwb3J0cy5Db250aW51b3VzRXZlbnRQcmlvcml0eSA9IENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EZWZhdWx0RXZlbnRQcmlvcml0eSA9IERlZmF1bHRFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLklkbGVFdmVudFByaW9yaXR5ID0gSWRsZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLkxlZ2FjeVJvb3QgPSBMZWdhY3lSb290O1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJTeW5jTGFuZSIsIklucHV0Q29udGludW91c0xhbmUiLCJEZWZhdWx0TGFuZSIsIklkbGVMYW5lIiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29udGludW91c0V2ZW50UHJpb3JpdHkiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIklkbGVFdmVudFByaW9yaXR5IiwiTGVnYWN5Um9vdCIsIkNvbmN1cnJlbnRSb290IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!****************************************************************************!*\
  !*** ../node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    module.exports = function $$$reconciler($$$hostConfig) {\n        var exports = {};\n        \"use strict\";\n        var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n        var Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/../node_modules/scheduler/index.js\");\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n            {\n                suppressWarning = newSuppressWarning;\n            }\n        } // In DEV, calls to console.warn and console.error get replaced\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        var assign = Object.assign;\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        // -----------------------------------------------------------------------------\n        var enablePersistentOffscreenHostContainer = false; // -----------------------------------------------------------------------------\n        // the react-reconciler package.\n        var enableNewReconciler = false; // Support legacy Primer support on internal FB www\n        var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        var enableSuspenseAvoidThisFallback = false; // Enables unstable_avoidThisFallback feature in Fizz\n        var warnAboutStringRefs = false; // -----------------------------------------------------------------------------\n        // Debugging and DevTools\n        // -----------------------------------------------------------------------------\n        // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n        // for an experimental timeline tool.\n        var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n        var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var IndeterminateComponent = 2; // Before we know whether it is function or class\n        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_TRACING_MARKER_TYPE = Symbol.for(\"react.tracing_marker\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return outerType.displayName || (functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        } // Keep in sync with shared/getComponentNameFromType\n        function getContextName$1(type) {\n            return type.displayName || \"Context\";\n        }\n        function getComponentNameFromFiber(fiber) {\n            var tag = fiber.tag, type = fiber.type;\n            switch(tag){\n                case CacheComponent:\n                    return \"Cache\";\n                case ContextConsumer:\n                    var context = type;\n                    return getContextName$1(context) + \".Consumer\";\n                case ContextProvider:\n                    var provider = type;\n                    return getContextName$1(provider._context) + \".Provider\";\n                case DehydratedFragment:\n                    return \"DehydratedFragment\";\n                case ForwardRef:\n                    return getWrappedName$1(type, type.render, \"ForwardRef\");\n                case Fragment:\n                    return \"Fragment\";\n                case HostComponent:\n                    // Host component type is the display name (e.g. \"div\", \"View\")\n                    return type;\n                case HostPortal:\n                    return \"Portal\";\n                case HostRoot:\n                    return \"Root\";\n                case HostText:\n                    return \"Text\";\n                case LazyComponent:\n                    // Name comes from the type in this case; we don't have a tag.\n                    return getComponentNameFromType(type);\n                case Mode:\n                    if (type === REACT_STRICT_MODE_TYPE) {\n                        // Don't be less specific than shared/getComponentNameFromType\n                        return \"StrictMode\";\n                    }\n                    return \"Mode\";\n                case OffscreenComponent:\n                    return \"Offscreen\";\n                case Profiler:\n                    return \"Profiler\";\n                case ScopeComponent:\n                    return \"Scope\";\n                case SuspenseComponent:\n                    return \"Suspense\";\n                case SuspenseListComponent:\n                    return \"SuspenseList\";\n                case TracingMarkerComponent:\n                    return \"TracingMarker\";\n                // The display name for this tags come from the user-provided type:\n                case ClassComponent:\n                case FunctionComponent:\n                case IncompleteClassComponent:\n                case IndeterminateComponent:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    if (typeof type === \"function\") {\n                        return type.displayName || type.name || null;\n                    }\n                    if (typeof type === \"string\") {\n                        return type;\n                    }\n                    break;\n            }\n            return null;\n        }\n        // Don't change these two values. They're used by React Dev Tools.\n        var NoFlags = /*                      */ 0;\n        var PerformedWork = /*                */ 1; // You can change the rest (and add more).\n        var Placement = /*                    */ 2;\n        var Update = /*                       */ 4;\n        var PlacementAndUpdate = /*           */ Placement | Update;\n        var ChildDeletion = /*                */ 16;\n        var ContentReset = /*                 */ 32;\n        var Callback = /*                     */ 64;\n        var DidCapture = /*                   */ 128;\n        var ForceClientRender = /*            */ 256;\n        var Ref = /*                          */ 512;\n        var Snapshot = /*                     */ 1024;\n        var Passive = /*                      */ 2048;\n        var Hydrating = /*                    */ 4096;\n        var HydratingAndUpdate = /*           */ Hydrating | Update;\n        var Visibility = /*                   */ 8192;\n        var StoreConsistency = /*             */ 16384;\n        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency; // Union of all commit flags (flags with the lifetime of a particular commit)\n        var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.\n        var Incomplete = /*                   */ 32768;\n        var ShouldCapture = /*                */ 65536;\n        var ForceUpdateForLegacySuspense = /* */ 131072;\n        var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n        // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n        // This enables us to defer more work in the unmount case,\n        // since we can defer traversing the tree during layout to look for Passive effects,\n        // and instead rely on the static flag as a signal that there may be cleanup work.\n        var RefStatic = /*                    */ 2097152;\n        var LayoutStatic = /*                 */ 4194304;\n        var PassiveStatic = /*                */ 8388608; // These flags allow us to traverse to fibers that have effects on mount\n        // without traversing the entire tree after every commit for\n        // double invoking\n        var MountLayoutDev = /*               */ 16777216;\n        var MountPassiveDev = /*              */ 33554432; // Groups of flags that are used in the commit phase to skip over trees that\n        // don't contain effects, by checking subtreeFlags.\n        var BeforeMutationMask = // flag logic (see #20043)\n        Update | Snapshot | 0;\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\n        var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n        var PassiveMask = Passive | ChildDeletion; // Union of tags that don't get reset on clones.\n        // This allows certain concepts to persist without recalculating them,\n        // e.g. whether a subtree contains passive effects or portals.\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        function getNearestMountedFiber(fiber) {\n            var node = fiber;\n            var nearestMounted = fiber;\n            if (!fiber.alternate) {\n                // If there is no alternate, this might be a new tree that isn't inserted\n                // yet. If it is, then it will have a pending insertion effect on it.\n                var nextNode = node;\n                do {\n                    node = nextNode;\n                    if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n                        // This is an insertion or in-progress hydration. The nearest possible\n                        // mounted fiber is the parent but we need to continue to figure out\n                        // if that one is still mounted.\n                        nearestMounted = node.return;\n                    }\n                    nextNode = node.return;\n                }while (nextNode);\n            } else {\n                while(node.return){\n                    node = node.return;\n                }\n            }\n            if (node.tag === HostRoot) {\n                // TODO: Check if this was a nested HostRoot when used with\n                // renderContainerIntoSubtree.\n                return nearestMounted;\n            } // If we didn't hit the root, that means that we're in an disconnected tree\n            // that has been unmounted.\n            return null;\n        }\n        function isFiberMounted(fiber) {\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function isMounted(component) {\n            {\n                var owner = ReactCurrentOwner.current;\n                if (owner !== null && owner.tag === ClassComponent) {\n                    var ownerFiber = owner;\n                    var instance = ownerFiber.stateNode;\n                    if (!instance._warnedAboutRefsInRender) {\n                        error(\"%s is accessing isMounted inside its render() function. \" + \"render() should be a pure function of props and state. It should \" + \"never access something that requires stale data from the previous \" + \"render, such as refs. Move this logic to componentDidMount and \" + \"componentDidUpdate instead.\", getComponentNameFromFiber(ownerFiber) || \"A component\");\n                    }\n                    instance._warnedAboutRefsInRender = true;\n                }\n            }\n            var fiber = get(component);\n            if (!fiber) {\n                return false;\n            }\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n            if (getNearestMountedFiber(fiber) !== fiber) {\n                throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n            var alternate = fiber.alternate;\n            if (!alternate) {\n                // If there is no alternate, then we only need to check if it is mounted.\n                var nearestMounted = getNearestMountedFiber(fiber);\n                if (nearestMounted === null) {\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                }\n                if (nearestMounted !== fiber) {\n                    return null;\n                }\n                return fiber;\n            } // If we have two possible branches, we'll walk backwards up to the root\n            // to see what path the root points to. On the way we may hit one of the\n            // special cases and we'll deal with them.\n            var a = fiber;\n            var b = alternate;\n            while(true){\n                var parentA = a.return;\n                if (parentA === null) {\n                    break;\n                }\n                var parentB = parentA.alternate;\n                if (parentB === null) {\n                    // There is no alternate. This is an unusual case. Currently, it only\n                    // happens when a Suspense component is hidden. An extra fragment fiber\n                    // is inserted in between the Suspense fiber and its children. Skip\n                    // over this extra fragment fiber and proceed to the next parent.\n                    var nextParent = parentA.return;\n                    if (nextParent !== null) {\n                        a = b = nextParent;\n                        continue;\n                    } // If there's no parent, we're at the root.\n                    break;\n                } // If both copies of the parent fiber point to the same child, we can\n                // assume that the child is current. This happens when we bailout on low\n                // priority: the bailed out fiber's child reuses the current child.\n                if (parentA.child === parentB.child) {\n                    var child = parentA.child;\n                    while(child){\n                        if (child === a) {\n                            // We've determined that A is the current branch.\n                            assertIsMounted(parentA);\n                            return fiber;\n                        }\n                        if (child === b) {\n                            // We've determined that B is the current branch.\n                            assertIsMounted(parentA);\n                            return alternate;\n                        }\n                        child = child.sibling;\n                    } // We should never have an alternate for any mounting node. So the only\n                    // way this could possibly happen is if this was unmounted, if at all.\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                }\n                if (a.return !== b.return) {\n                    // The return pointer of A and the return pointer of B point to different\n                    // fibers. We assume that return pointers never criss-cross, so A must\n                    // belong to the child set of A.return, and B must belong to the child\n                    // set of B.return.\n                    a = parentA;\n                    b = parentB;\n                } else {\n                    // The return pointers point to the same fiber. We'll have to use the\n                    // default, slow path: scan the child sets of each parent alternate to see\n                    // which child belongs to which set.\n                    //\n                    // Search parent A's child set\n                    var didFindChild = false;\n                    var _child = parentA.child;\n                    while(_child){\n                        if (_child === a) {\n                            didFindChild = true;\n                            a = parentA;\n                            b = parentB;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = true;\n                            b = parentA;\n                            a = parentB;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) {\n                        // Search parent B's child set\n                        _child = parentB.child;\n                        while(_child){\n                            if (_child === a) {\n                                didFindChild = true;\n                                a = parentB;\n                                b = parentA;\n                                break;\n                            }\n                            if (_child === b) {\n                                didFindChild = true;\n                                b = parentB;\n                                a = parentA;\n                                break;\n                            }\n                            _child = _child.sibling;\n                        }\n                        if (!didFindChild) {\n                            throw new Error(\"Child was not found in either parent set. This indicates a bug \" + \"in React related to the return pointer. Please file an issue.\");\n                        }\n                    }\n                }\n                if (a.alternate !== b) {\n                    throw new Error(\"Return fibers should always be each others' alternates. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n            } // If the root is not a host container, we're in a disconnected tree. I.e.\n            // unmounted.\n            if (a.tag !== HostRoot) {\n                throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.stateNode.current === a) {\n                // We've determined that A is the current branch.\n                return fiber;\n            } // Otherwise B has to be current branch.\n            return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            if (node.tag === HostComponent || node.tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                var match = findCurrentHostFiberImpl(child);\n                if (match !== null) {\n                    return match;\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            if (node.tag === HostComponent || node.tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                if (child.tag !== HostPortal) {\n                    var match = findCurrentHostFiberWithNoPortalsImpl(child);\n                    if (match !== null) {\n                        return match;\n                    }\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // This is a host config that's used for the `react-reconciler` package on npm.\n        // It is only used by third-party renderers.\n        //\n        // Its API lets you pass the host config as an argument.\n        // However, inside the `react-reconciler` we treat host config as a module.\n        // This file is a shim between two worlds.\n        //\n        // It works because the `react-reconciler` bundle is wrapped in something like:\n        //\n        // module.exports = function ($$$config) {\n        //   /* reconciler code */\n        // }\n        //\n        // So `$$$config` looks like a global variable, but it's\n        // really an argument to a top-level wrapping function.\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        var getPublicInstance = $$$hostConfig.getPublicInstance;\n        var getRootHostContext = $$$hostConfig.getRootHostContext;\n        var getChildHostContext = $$$hostConfig.getChildHostContext;\n        var prepareForCommit = $$$hostConfig.prepareForCommit;\n        var resetAfterCommit = $$$hostConfig.resetAfterCommit;\n        var createInstance = $$$hostConfig.createInstance;\n        var appendInitialChild = $$$hostConfig.appendInitialChild;\n        var finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;\n        var prepareUpdate = $$$hostConfig.prepareUpdate;\n        var shouldSetTextContent = $$$hostConfig.shouldSetTextContent;\n        var createTextInstance = $$$hostConfig.createTextInstance;\n        var scheduleTimeout = $$$hostConfig.scheduleTimeout;\n        var cancelTimeout = $$$hostConfig.cancelTimeout;\n        var noTimeout = $$$hostConfig.noTimeout;\n        var now = $$$hostConfig.now;\n        var isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;\n        var warnsIfNotActing = $$$hostConfig.warnsIfNotActing;\n        var supportsMutation = $$$hostConfig.supportsMutation;\n        var supportsPersistence = $$$hostConfig.supportsPersistence;\n        var supportsHydration = $$$hostConfig.supportsHydration;\n        var getInstanceFromNode = $$$hostConfig.getInstanceFromNode;\n        var beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur;\n        var afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur;\n        var preparePortalMount = $$$hostConfig.preparePortalMount;\n        var prepareScopeUpdate = $$$hostConfig.preparePortalMount;\n        var getInstanceFromScope = $$$hostConfig.getInstanceFromScope;\n        var getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;\n        var detachDeletedInstance = $$$hostConfig.detachDeletedInstance; // -------------------\n        //      Microtasks\n        //     (optional)\n        // -------------------\n        var supportsMicrotasks = $$$hostConfig.supportsMicrotasks;\n        var scheduleMicrotask = $$$hostConfig.scheduleMicrotask; // -------------------\n        //      Test selectors\n        //     (optional)\n        // -------------------\n        var supportsTestSelectors = $$$hostConfig.supportsTestSelectors;\n        var findFiberRoot = $$$hostConfig.findFiberRoot;\n        var getBoundingRect = $$$hostConfig.getBoundingRect;\n        var getTextContent = $$$hostConfig.getTextContent;\n        var isHiddenSubtree = $$$hostConfig.isHiddenSubtree;\n        var matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;\n        var setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;\n        var setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver; // -------------------\n        //      Mutation\n        //     (optional)\n        // -------------------\n        var appendChild = $$$hostConfig.appendChild;\n        var appendChildToContainer = $$$hostConfig.appendChildToContainer;\n        var commitTextUpdate = $$$hostConfig.commitTextUpdate;\n        var commitMount = $$$hostConfig.commitMount;\n        var commitUpdate = $$$hostConfig.commitUpdate;\n        var insertBefore = $$$hostConfig.insertBefore;\n        var insertInContainerBefore = $$$hostConfig.insertInContainerBefore;\n        var removeChild = $$$hostConfig.removeChild;\n        var removeChildFromContainer = $$$hostConfig.removeChildFromContainer;\n        var resetTextContent = $$$hostConfig.resetTextContent;\n        var hideInstance = $$$hostConfig.hideInstance;\n        var hideTextInstance = $$$hostConfig.hideTextInstance;\n        var unhideInstance = $$$hostConfig.unhideInstance;\n        var unhideTextInstance = $$$hostConfig.unhideTextInstance;\n        var clearContainer = $$$hostConfig.clearContainer; // -------------------\n        //     Persistence\n        //     (optional)\n        // -------------------\n        var cloneInstance = $$$hostConfig.cloneInstance;\n        var createContainerChildSet = $$$hostConfig.createContainerChildSet;\n        var appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;\n        var finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;\n        var replaceContainerChildren = $$$hostConfig.replaceContainerChildren;\n        var getOffscreenContainerType = $$$hostConfig.getOffscreenContainerType;\n        var getOffscreenContainerProps = $$$hostConfig.getOffscreenContainerProps;\n        var cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;\n        var cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance; // -------------------\n        //     Hydration\n        //     (optional)\n        // -------------------\n        var canHydrateInstance = $$$hostConfig.canHydrateInstance;\n        var canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;\n        var canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;\n        var isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;\n        var isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;\n        var registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;\n        var getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;\n        var getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;\n        var getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;\n        var getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;\n        var hydrateInstance = $$$hostConfig.hydrateInstance;\n        var hydrateTextInstance = $$$hostConfig.hydrateTextInstance;\n        var hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;\n        var getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;\n        var commitHydratedContainer = $$$hostConfig.commitHydratedContainer;\n        var commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;\n        var clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;\n        var clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;\n        var shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;\n        var didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;\n        var didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;\n        var didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;\n        var didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;\n        var didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;\n        var didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;\n        var didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;\n        var didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;\n        var didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;\n        var didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;\n        var didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;\n        var didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;\n        var didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;\n        var didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;\n        var errorHydratingContainer = $$$hostConfig.errorHydratingContainer;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        }\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    }\n                    fn();\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var valueStack = [];\n        var fiberStack;\n        {\n            fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n            return {\n                current: defaultValue\n            };\n        }\n        function pop(cursor, fiber) {\n            if (index < 0) {\n                {\n                    error(\"Unexpected pop.\");\n                }\n                return;\n            }\n            {\n                if (fiber !== fiberStack[index]) {\n                    error(\"Unexpected Fiber popped.\");\n                }\n            }\n            cursor.current = valueStack[index];\n            valueStack[index] = null;\n            {\n                fiberStack[index] = null;\n            }\n            index--;\n        }\n        function push(cursor, value, fiber) {\n            index++;\n            valueStack[index] = cursor.current;\n            {\n                fiberStack[index] = fiber;\n            }\n            cursor.current = value;\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n        var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n        // We use this to get access to the parent context after we have already\n        // pushed the next context provider, and now need to merge their contexts.\n        var previousContext = emptyContextObject;\n        function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n            {\n                if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n                    // If the fiber is a context provider itself, when we read its context\n                    // we may have already pushed its own child context on the stack. A context\n                    // provider should not \"see\" its own child context. Therefore we read the\n                    // previous (parent) context instead for a context provider.\n                    return previousContext;\n                }\n                return contextStackCursor.current;\n            }\n        }\n        function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n            {\n                var instance = workInProgress.stateNode;\n                instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n                instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n            }\n        }\n        function getMaskedContext(workInProgress, unmaskedContext) {\n            {\n                var type = workInProgress.type;\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                } // Avoid recreating masked context unless unmasked context has changed.\n                // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n                // This may trigger infinite loops if componentWillReceiveProps calls setState.\n                var instance = workInProgress.stateNode;\n                if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n                    return instance.__reactInternalMemoizedMaskedChildContext;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                // Context is created before the class component is instantiated so check for instance.\n                if (instance) {\n                    cacheContext(workInProgress, unmaskedContext, context);\n                }\n                return context;\n            }\n        }\n        function hasContextChanged() {\n            {\n                return didPerformWorkStackCursor.current;\n            }\n        }\n        function isContextProvider(type) {\n            {\n                var childContextTypes = type.childContextTypes;\n                return childContextTypes !== null && childContextTypes !== undefined;\n            }\n        }\n        function popContext(fiber) {\n            {\n                pop(didPerformWorkStackCursor, fiber);\n                pop(contextStackCursor, fiber);\n            }\n        }\n        function popTopLevelContextObject(fiber) {\n            {\n                pop(didPerformWorkStackCursor, fiber);\n                pop(contextStackCursor, fiber);\n            }\n        }\n        function pushTopLevelContextObject(fiber, context, didChange) {\n            {\n                if (contextStackCursor.current !== emptyContextObject) {\n                    throw new Error(\"Unexpected context found on stack. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                push(contextStackCursor, context, fiber);\n                push(didPerformWorkStackCursor, didChange, fiber);\n            }\n        }\n        function processChildContext(fiber, type, parentContext) {\n            {\n                var instance = fiber.stateNode;\n                var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromFiber(fiber) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromFiber(fiber) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        function pushContextProvider(workInProgress) {\n            {\n                var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n                // If the instance does not exist yet, we will push null at first,\n                // and replace it on the stack later when invalidating the context.\n                var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n                // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n                previousContext = contextStackCursor.current;\n                push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n                push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n                return true;\n            }\n        }\n        function invalidateContextProvider(workInProgress, type, didChange) {\n            {\n                var instance = workInProgress.stateNode;\n                if (!instance) {\n                    throw new Error(\"Expected to have an instance by this point. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                if (didChange) {\n                    // Merge parent and own context.\n                    // Skip this if we're not updating due to sCU.\n                    // This avoids unnecessarily recomputing memoized values.\n                    var mergedContext = processChildContext(workInProgress, type, previousContext);\n                    instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n                    // It is important to unwind the context in the reverse order.\n                    pop(didPerformWorkStackCursor, workInProgress);\n                    pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n                    push(contextStackCursor, mergedContext, workInProgress);\n                    push(didPerformWorkStackCursor, didChange, workInProgress);\n                } else {\n                    pop(didPerformWorkStackCursor, workInProgress);\n                    push(didPerformWorkStackCursor, didChange, workInProgress);\n                }\n            }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n            {\n                // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n                // makes sense elsewhere\n                if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n                    throw new Error(\"Expected subtree parent to be a mounted class component. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                var node = fiber;\n                do {\n                    switch(node.tag){\n                        case HostRoot:\n                            return node.stateNode.context;\n                        case ClassComponent:\n                            {\n                                var Component = node.type;\n                                if (isContextProvider(Component)) {\n                                    return node.stateNode.__reactInternalMemoizedMergedChildContext;\n                                }\n                                break;\n                            }\n                    }\n                    node = node.return;\n                }while (node !== null);\n                throw new Error(\"Found unexpected detached subtree parent. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n        var ConcurrentMode = /*                 */ 1;\n        var ProfileMode = /*                    */ 2;\n        var StrictLegacyMode = /*               */ 8;\n        var StrictEffectsMode = /*              */ 16;\n        // TODO: This is pretty well supported by browsers. Maybe we can drop it.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // If those values are changed that package should be rebuilt and redeployed.\n        var TotalLanes = 31;\n        var NoLanes = /*                        */ 0;\n        var NoLane = /*                          */ 0;\n        var SyncLane = /*                        */ 1;\n        var InputContinuousHydrationLane = /*    */ 2;\n        var InputContinuousLane = /*            */ 4;\n        var DefaultHydrationLane = /*            */ 8;\n        var DefaultLane = /*                    */ 16;\n        var TransitionHydrationLane = /*                */ 32;\n        var TransitionLanes = /*                       */ 4194240;\n        var TransitionLane1 = /*                        */ 64;\n        var TransitionLane2 = /*                        */ 128;\n        var TransitionLane3 = /*                        */ 256;\n        var TransitionLane4 = /*                        */ 512;\n        var TransitionLane5 = /*                        */ 1024;\n        var TransitionLane6 = /*                        */ 2048;\n        var TransitionLane7 = /*                        */ 4096;\n        var TransitionLane8 = /*                        */ 8192;\n        var TransitionLane9 = /*                        */ 16384;\n        var TransitionLane10 = /*                       */ 32768;\n        var TransitionLane11 = /*                       */ 65536;\n        var TransitionLane12 = /*                       */ 131072;\n        var TransitionLane13 = /*                       */ 262144;\n        var TransitionLane14 = /*                       */ 524288;\n        var TransitionLane15 = /*                       */ 1048576;\n        var TransitionLane16 = /*                       */ 2097152;\n        var RetryLanes = /*                            */ 130023424;\n        var RetryLane1 = /*                             */ 4194304;\n        var RetryLane2 = /*                             */ 8388608;\n        var RetryLane3 = /*                             */ 16777216;\n        var RetryLane4 = /*                             */ 33554432;\n        var RetryLane5 = /*                             */ 67108864;\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = /*          */ 134217728;\n        var NonIdleLanes = /*                                 */ 268435455;\n        var IdleHydrationLane = /*               */ 268435456;\n        var IdleLane = /*                       */ 536870912;\n        var OffscreenLane = /*                   */ 1073741824; // This function is used for the experimental timeline (react-devtools-timeline)\n        // It should be kept in sync with the Lanes values above.\n        function getLabelForLane(lane) {\n            {\n                if (lane & SyncLane) {\n                    return \"Sync\";\n                }\n                if (lane & InputContinuousHydrationLane) {\n                    return \"InputContinuousHydration\";\n                }\n                if (lane & InputContinuousLane) {\n                    return \"InputContinuous\";\n                }\n                if (lane & DefaultHydrationLane) {\n                    return \"DefaultHydration\";\n                }\n                if (lane & DefaultLane) {\n                    return \"Default\";\n                }\n                if (lane & TransitionHydrationLane) {\n                    return \"TransitionHydration\";\n                }\n                if (lane & TransitionLanes) {\n                    return \"Transition\";\n                }\n                if (lane & RetryLanes) {\n                    return \"Retry\";\n                }\n                if (lane & SelectiveHydrationLane) {\n                    return \"SelectiveHydration\";\n                }\n                if (lane & IdleHydrationLane) {\n                    return \"IdleHydration\";\n                }\n                if (lane & IdleLane) {\n                    return \"Idle\";\n                }\n                if (lane & OffscreenLane) {\n                    return \"Offscreen\";\n                }\n            }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n            switch(getHighestPriorityLane(lanes)){\n                case SyncLane:\n                    return SyncLane;\n                case InputContinuousHydrationLane:\n                    return InputContinuousHydrationLane;\n                case InputContinuousLane:\n                    return InputContinuousLane;\n                case DefaultHydrationLane:\n                    return DefaultHydrationLane;\n                case DefaultLane:\n                    return DefaultLane;\n                case TransitionHydrationLane:\n                    return TransitionHydrationLane;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                    return lanes & TransitionLanes;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    return lanes & RetryLanes;\n                case SelectiveHydrationLane:\n                    return SelectiveHydrationLane;\n                case IdleHydrationLane:\n                    return IdleHydrationLane;\n                case IdleLane:\n                    return IdleLane;\n                case OffscreenLane:\n                    return OffscreenLane;\n                default:\n                    {\n                        error(\"Should have found matching lanes. This is a bug in React.\");\n                    }\n                    return lanes;\n            }\n        }\n        function getNextLanes(root, wipLanes) {\n            // Early bailout if there's no pending work left.\n            var pendingLanes = root.pendingLanes;\n            if (pendingLanes === NoLanes) {\n                return NoLanes;\n            }\n            var nextLanes = NoLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n            // even if the work is suspended.\n            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n            if (nonIdlePendingLanes !== NoLanes) {\n                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n                if (nonIdleUnblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n                } else {\n                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n                    if (nonIdlePingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n                    }\n                }\n            } else {\n                // The only remaining work is Idle.\n                var unblockedLanes = pendingLanes & ~suspendedLanes;\n                if (unblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(unblockedLanes);\n                } else {\n                    if (pingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(pingedLanes);\n                    }\n                }\n            }\n            if (nextLanes === NoLanes) {\n                // This should only be reachable if we're suspended\n                // TODO: Consider warning in this path if a fallback timer is not scheduled.\n                return NoLanes;\n            } // If we're already in the middle of a render, switching lanes will interrupt\n            // it and we'll lose our progress. We should only do this if the new lanes are\n            // higher priority.\n            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n            // bother waiting until the root is complete.\n            (wipLanes & suspendedLanes) === NoLanes) {\n                var nextLane = getHighestPriorityLane(nextLanes);\n                var wipLane = getHighestPriorityLane(wipLanes);\n                if (// one. This works because the bits decrease in priority as you go left.\n                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n                // only difference between default updates and transition updates is that\n                // default updates do not support refresh transitions.\n                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n                    // Keep working on the existing in-progress tree. Do not interrupt.\n                    return wipLanes;\n                }\n            }\n            if ((nextLanes & InputContinuousLane) !== NoLanes) {\n                // When updates are sync by default, we entangle continuous priority updates\n                // and default updates, so they render in the same batch. The only reason\n                // they use separate lanes is because continuous updates should interrupt\n                // transitions, but default updates should not.\n                nextLanes |= pendingLanes & DefaultLane;\n            } // Check for entangled lanes and add them to the batch.\n            //\n            // A lane is said to be entangled with another when it's not allowed to render\n            // in a batch that does not also include the other lane. Typically we do this\n            // when multiple updates have the same source, and we only want to respond to\n            // the most recent event from that source.\n            //\n            // Note that we apply entanglements *after* checking for partial work above.\n            // This means that if a lane is entangled during an interleaved event while\n            // it's already rendering, we won't interrupt it. This is intentional, since\n            // entanglement is usually \"best effort\": we'll try our best to render the\n            // lanes in the same batch, but it's not worth throwing out partially\n            // completed work in order to do it.\n            // TODO: Reconsider this. The counter-argument is that the partial work\n            // represents an intermediate state, which we don't want to show to the user.\n            // And by spending extra time finishing it, we're increasing the amount of\n            // time it takes to show the final state, which is what they are actually\n            // waiting for.\n            //\n            // For those exceptions where entanglement is semantically important, like\n            // useMutableSource, we should ensure that there is no partial work at the\n            // time we apply the entanglement.\n            var entangledLanes = root.entangledLanes;\n            if (entangledLanes !== NoLanes) {\n                var entanglements = root.entanglements;\n                var lanes = nextLanes & entangledLanes;\n                while(lanes > 0){\n                    var index = pickArbitraryLaneIndex(lanes);\n                    var lane = 1 << index;\n                    nextLanes |= entanglements[index];\n                    lanes &= ~lane;\n                }\n            }\n            return nextLanes;\n        }\n        function getMostRecentEventTime(root, lanes) {\n            var eventTimes = root.eventTimes;\n            var mostRecentEventTime = NoTimestamp;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var eventTime = eventTimes[index];\n                if (eventTime > mostRecentEventTime) {\n                    mostRecentEventTime = eventTime;\n                }\n                lanes &= ~lane;\n            }\n            return mostRecentEventTime;\n        }\n        function computeExpirationTime(lane, currentTime) {\n            switch(lane){\n                case SyncLane:\n                case InputContinuousHydrationLane:\n                case InputContinuousLane:\n                    // User interactions should expire slightly more quickly.\n                    //\n                    // NOTE: This is set to the corresponding constant as in Scheduler.js.\n                    // When we made it larger, a product metric in www regressed, suggesting\n                    // there's a user interaction that's being starved by a series of\n                    // synchronous updates. If that theory is correct, the proper solution is\n                    // to fix the starvation. However, this scenario supports the idea that\n                    // expiration times are an important safeguard when starvation\n                    // does happen.\n                    return currentTime + 250;\n                case DefaultHydrationLane:\n                case DefaultLane:\n                case TransitionHydrationLane:\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                    return currentTime + 5000;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    // TODO: Retries should be allowed to expire if they are CPU bound for\n                    // too long, but when I made this change it caused a spike in browser\n                    // crashes. There must be some other underlying bug; not super urgent but\n                    // ideally should figure out why and fix it. Unfortunately we don't have\n                    // a repro for the crashes, only detected via production metrics.\n                    return NoTimestamp;\n                case SelectiveHydrationLane:\n                case IdleHydrationLane:\n                case IdleLane:\n                case OffscreenLane:\n                    // Anything idle priority or lower should never expire.\n                    return NoTimestamp;\n                default:\n                    {\n                        error(\"Should have found matching lanes. This is a bug in React.\");\n                    }\n                    return NoTimestamp;\n            }\n        }\n        function markStarvedLanesAsExpired(root, currentTime) {\n            // TODO: This gets called every time we yield. We can optimize by storing\n            // the earliest expiration time on the root. Then use that to quickly bail out\n            // of this function.\n            var pendingLanes = root.pendingLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes;\n            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n            // expiration time. If so, we'll assume the update is being starved and mark\n            // it as expired to force it to finish.\n            var lanes = pendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var expirationTime = expirationTimes[index];\n                if (expirationTime === NoTimestamp) {\n                    // Found a pending lane with no expiration time. If it's not suspended, or\n                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n                    // using the current time.\n                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                        // Assumes timestamps are monotonically increasing.\n                        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n                    }\n                } else if (expirationTime <= currentTime) {\n                    // This lane expired\n                    root.expiredLanes |= lane;\n                }\n                lanes &= ~lane;\n            }\n        } // This returns the highest priority pending lanes regardless of whether they\n        // are suspended.\n        function getHighestPriorityPendingLanes(root) {\n            return getHighestPriorityLanes(root.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root) {\n            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n            if (everythingButOffscreen !== NoLanes) {\n                return everythingButOffscreen;\n            }\n            if (everythingButOffscreen & OffscreenLane) {\n                return OffscreenLane;\n            }\n            return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n            return (lanes & SyncLane) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n            return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n            return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyTransitions(lanes) {\n            return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root, lanes) {\n            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n            return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root, lanes) {\n            // This is a separate check from includesBlockingLane because a lane can\n            // expire after a render has already started.\n            return (lanes & root.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n            return (lane & TransitionLanes) !== 0;\n        }\n        function claimNextTransitionLane() {\n            // Cycle through the lanes, assigning each new transition to the next lane.\n            // In most cases, this means every transition gets its own lane, until we\n            // run out of lanes and cycle back to the beginning.\n            var lane = nextTransitionLane;\n            nextTransitionLane <<= 1;\n            if ((nextTransitionLane & TransitionLanes) === 0) {\n                nextTransitionLane = TransitionLane1;\n            }\n            return lane;\n        }\n        function claimNextRetryLane() {\n            var lane = nextRetryLane;\n            nextRetryLane <<= 1;\n            if ((nextRetryLane & RetryLanes) === 0) {\n                nextRetryLane = RetryLane1;\n            }\n            return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n            return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n            // This wrapper function gets inlined. Only exists so to communicate that it\n            // doesn't matter which bit is selected; you can pick any bit without\n            // affecting the algorithms where its used. Here I'm using\n            // getHighestPriorityLane because it requires the fewest operations.\n            return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n            return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n            return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n            return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set, subset) {\n            return (set & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n            return a | b;\n        }\n        function removeLanes(set, subset) {\n            return set & ~subset;\n        }\n        function intersectLanes(a, b) {\n            return a & b;\n        } // Seems redundant, but it changes the type from a single lane (used for\n        // updates) to a group of lanes (used for flushing work).\n        function laneToLanes(lane) {\n            return lane;\n        }\n        function higherPriorityLane(a, b) {\n            // This works because the bit ranges decrease in priority as you go left.\n            return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n            // Intentionally pushing one by one.\n            // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n            var laneMap = [];\n            for(var i = 0; i < TotalLanes; i++){\n                laneMap.push(initial);\n            }\n            return laneMap;\n        }\n        function markRootUpdated(root, updateLane, eventTime) {\n            root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n            // could unblock them. Clear the suspended lanes so that we can try rendering\n            // them again.\n            //\n            // TODO: We really only need to unsuspend only lanes that are in the\n            // `subtreeLanes` of the updated fiber, or the update lanes of the return\n            // path. This would exclude suspended updates in an unrelated sibling tree,\n            // since there's no way for this update to unblock it.\n            //\n            // We don't do this if the incoming update is idle, because we never process\n            // idle updates until after all the regular updates have finished; there's no\n            // way it could unblock a transition.\n            if (updateLane !== IdleLane) {\n                root.suspendedLanes = NoLanes;\n                root.pingedLanes = NoLanes;\n            }\n            var eventTimes = root.eventTimes;\n            var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n            // recent event, and we assume time is monotonically increasing.\n            eventTimes[index] = eventTime;\n        }\n        function markRootSuspended(root, suspendedLanes) {\n            root.suspendedLanes |= suspendedLanes;\n            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n            var expirationTimes = root.expirationTimes;\n            var lanes = suspendedLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n        }\n        function markRootPinged(root, pingedLanes, eventTime) {\n            root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root, remainingLanes) {\n            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n            root.pendingLanes = remainingLanes; // Let's try everything again\n            root.suspendedLanes = 0;\n            root.pingedLanes = 0;\n            root.expiredLanes &= remainingLanes;\n            root.mutableReadLanes &= remainingLanes;\n            root.entangledLanes &= remainingLanes;\n            var entanglements = root.entanglements;\n            var eventTimes = root.eventTimes;\n            var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n            var lanes = noLongerPendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                entanglements[index] = NoLanes;\n                eventTimes[index] = NoTimestamp;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n        }\n        function markRootEntangled(root, entangledLanes) {\n            // In addition to entangling each of the given lanes with each other, we also\n            // have to consider _transitive_ entanglements. For each lane that is already\n            // entangled with *any* of the given lanes, that lane is now transitively\n            // entangled with *all* the given lanes.\n            //\n            // Translated: If C is entangled with A, then entangling A with B also\n            // entangles C with B.\n            //\n            // If this is hard to grasp, it might help to intentionally break this\n            // function and look at the tests that fail in ReactTransition-test.js. Try\n            // commenting out one of the conditions below.\n            var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n            var entanglements = root.entanglements;\n            var lanes = rootEntangledLanes;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n                entanglements[index] & entangledLanes) {\n                    entanglements[index] |= entangledLanes;\n                }\n                lanes &= ~lane;\n            }\n        }\n        function getBumpedLaneForHydration(root, renderLanes) {\n            var renderLane = getHighestPriorityLane(renderLanes);\n            var lane;\n            switch(renderLane){\n                case InputContinuousLane:\n                    lane = InputContinuousHydrationLane;\n                    break;\n                case DefaultLane:\n                    lane = DefaultHydrationLane;\n                    break;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    lane = TransitionHydrationLane;\n                    break;\n                case IdleLane:\n                    lane = IdleHydrationLane;\n                    break;\n                default:\n                    // Everything else is already either a hydration lane, or shouldn't\n                    // be retried at a hydration lane.\n                    lane = NoLane;\n                    break;\n            } // Check if the lane we chose is suspended. If so, that indicates that we\n            // already attempted and failed to hydrate at that level. Also check if we're\n            // already rendering that lane, which is rare but could happen.\n            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n                // Give up trying to hydrate and fall back to client render.\n                return NoLane;\n            }\n            return lane;\n        }\n        function addFiberToLanesMap(root, fiber, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                updaters.add(fiber);\n                lanes &= ~lane;\n            }\n        }\n        function movePendingFibersToMemoized(root, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            var memoizedUpdaters = root.memoizedUpdaters;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                if (updaters.size > 0) {\n                    updaters.forEach(function(fiber) {\n                        var alternate = fiber.alternate;\n                        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                            memoizedUpdaters.add(fiber);\n                        }\n                    });\n                    updaters.clear();\n                }\n                lanes &= ~lane;\n            }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        var currentUpdatePriority = NoLane;\n        function getCurrentUpdatePriority() {\n            return currentUpdatePriority;\n        }\n        function setCurrentUpdatePriority(newPriority) {\n            currentUpdatePriority = newPriority;\n        }\n        function runWithPriority(priority, fn) {\n            var previousPriority = currentUpdatePriority;\n            try {\n                currentUpdatePriority = priority;\n                return fn();\n            } finally{\n                currentUpdatePriority = previousPriority;\n            }\n        }\n        function higherEventPriority(a, b) {\n            return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n            return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n            return a !== 0 && a < b;\n        }\n        function lanesToEventPriority(lanes) {\n            var lane = getHighestPriorityLane(lanes);\n            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n                return DiscreteEventPriority;\n            }\n            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n                return ContinuousEventPriority;\n            }\n            if (includesNonIdleWork(lane)) {\n                return DefaultEventPriority;\n            }\n            return IdleEventPriority;\n        }\n        // This module only exists as an ESM wrapper around the external CommonJS\n        var scheduleCallback = Scheduler.unstable_scheduleCallback;\n        var cancelCallback = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now$1 = Scheduler.unstable_now;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority = Scheduler.unstable_NormalPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority;\n        // this doesn't actually exist on the scheduler, but it *does*\n        // on scheduler/unstable_mock, which we'll need for internal testing\n        var unstable_yieldValue = Scheduler.unstable_yieldValue;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n        function injectInternals(internals) {\n            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n                // No DevTools\n                return false;\n            }\n            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n            if (hook.isDisabled) {\n                // This isn't a real property on the hook, but it can be set to opt out\n                // of DevTools integration and associated warnings and logs.\n                // https://github.com/facebook/react/issues/3877\n                return true;\n            }\n            if (!hook.supportsFiber) {\n                {\n                    error(\"The installed version of React DevTools is too old and will not work \" + \"with the current version of React. Please update React DevTools. \" + \"https://reactjs.org/link/react-devtools\");\n                }\n                return true;\n            }\n            try {\n                if (enableSchedulingProfiler) {\n                    // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n                    // This gives DevTools a way to feature detect that isn't tied to version number\n                    // (since profiling and timeline are controlled by different feature flags).\n                    internals = assign({}, internals, {\n                        getLaneLabelMap: getLaneLabelMap,\n                        injectProfilingHooks: injectProfilingHooks\n                    });\n                }\n                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n                injectedHook = hook;\n            } catch (err) {\n                // Catch all errors because it is unsafe to throw during initialization.\n                {\n                    error(\"React instrumentation encountered an error: %s.\", err);\n                }\n            }\n            if (hook.checkDCE) {\n                // This is the real DevTools.\n                return true;\n            } else {\n                // This is likely a hook installed by Fast Refresh runtime.\n                return false;\n            }\n        }\n        function onScheduleRoot(root, children) {\n            {\n                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === \"function\") {\n                    try {\n                        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n                    } catch (err) {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitRoot(root, eventPriority) {\n            if (injectedHook && typeof injectedHook.onCommitFiberRoot === \"function\") {\n                try {\n                    var didError = (root.current.flags & DidCapture) === DidCapture;\n                    if (enableProfilerTimer) {\n                        var schedulerPriority;\n                        switch(eventPriority){\n                            case DiscreteEventPriority:\n                                schedulerPriority = ImmediatePriority;\n                                break;\n                            case ContinuousEventPriority:\n                                schedulerPriority = UserBlockingPriority;\n                                break;\n                            case DefaultEventPriority:\n                                schedulerPriority = NormalPriority;\n                                break;\n                            case IdleEventPriority:\n                                schedulerPriority = IdlePriority;\n                                break;\n                            default:\n                                schedulerPriority = NormalPriority;\n                                break;\n                        }\n                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n                    } else {\n                        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);\n                    }\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onPostCommitRoot(root) {\n            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === \"function\") {\n                try {\n                    injectedHook.onPostCommitFiberRoot(rendererID, root);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitUnmount(fiber) {\n            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === \"function\") {\n                try {\n                    injectedHook.onCommitFiberUnmount(rendererID, fiber);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n            {\n                if (typeof unstable_yieldValue === \"function\") {\n                    // We're in a test because Scheduler.unstable_yieldValue only exists\n                    // in SchedulerMock. To reduce the noise in strict mode tests,\n                    // suppress warnings and disable scheduler yielding during the double render\n                    unstable_setDisableYieldValue(newIsStrictMode);\n                    setSuppressWarning(newIsStrictMode);\n                }\n                if (injectedHook && typeof injectedHook.setStrictMode === \"function\") {\n                    try {\n                        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n                    } catch (err) {\n                        {\n                            if (!hasLoggedError) {\n                                hasLoggedError = true;\n                                error(\"React instrumentation encountered an error: %s\", err);\n                            }\n                        }\n                    }\n                }\n            }\n        } // Profiler API hooks\n        function injectProfilingHooks(profilingHooks) {\n            injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n            {\n                var map = new Map();\n                var lane = 1;\n                for(var index = 0; index < TotalLanes; index++){\n                    var label = getLabelForLane(lane);\n                    map.set(lane, label);\n                    lane *= 2;\n                }\n                return map;\n            }\n        }\n        function markCommitStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === \"function\") {\n                    injectedProfilingHooks.markCommitStarted(lanes);\n                }\n            }\n        }\n        function markCommitStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === \"function\") {\n                    injectedProfilingHooks.markCommitStopped();\n                }\n            }\n        }\n        function markComponentRenderStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === \"function\") {\n                    injectedProfilingHooks.markComponentRenderStarted(fiber);\n                }\n            }\n        }\n        function markComponentRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === \"function\") {\n                    injectedProfilingHooks.markComponentRenderStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === \"function\") {\n                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n                }\n            }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === \"function\") {\n                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === \"function\") {\n                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === \"function\") {\n                    injectedProfilingHooks.markLayoutEffectsStopped();\n                }\n            }\n        }\n        function markPassiveEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === \"function\") {\n                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                }\n            }\n        }\n        function markPassiveEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === \"function\") {\n                    injectedProfilingHooks.markPassiveEffectsStopped();\n                }\n            }\n        }\n        function markRenderStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === \"function\") {\n                    injectedProfilingHooks.markRenderStarted(lanes);\n                }\n            }\n        }\n        function markRenderYielded() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === \"function\") {\n                    injectedProfilingHooks.markRenderYielded();\n                }\n            }\n        }\n        function markRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === \"function\") {\n                    injectedProfilingHooks.markRenderStopped();\n                }\n            }\n        }\n        function markRenderScheduled(lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === \"function\") {\n                    injectedProfilingHooks.markRenderScheduled(lane);\n                }\n            }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === \"function\") {\n                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === \"function\") {\n                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var syncQueue = null;\n        var includesLegacySyncCallbacks = false;\n        var isFlushingSyncQueue = false;\n        function scheduleSyncCallback(callback) {\n            // Push this callback into an internal queue. We'll flush these either in\n            // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n            if (syncQueue === null) {\n                syncQueue = [\n                    callback\n                ];\n            } else {\n                // Push onto existing queue. Don't need to schedule a callback because\n                // we already scheduled one when we created the queue.\n                syncQueue.push(callback);\n            }\n        }\n        function scheduleLegacySyncCallback(callback) {\n            includesLegacySyncCallbacks = true;\n            scheduleSyncCallback(callback);\n        }\n        function flushSyncCallbacksOnlyInLegacyMode() {\n            // Only flushes the queue if there's a legacy sync callback scheduled.\n            // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n            // it might make more sense for the queue to be a list of roots instead of a\n            // list of generic callbacks. Then we can have two: one for legacy roots, one\n            // for concurrent roots. And this method would only flush the legacy ones.\n            if (includesLegacySyncCallbacks) {\n                flushSyncCallbacks();\n            }\n        }\n        function flushSyncCallbacks() {\n            if (!isFlushingSyncQueue && syncQueue !== null) {\n                // Prevent re-entrance.\n                isFlushingSyncQueue = true;\n                var i = 0;\n                var previousUpdatePriority = getCurrentUpdatePriority();\n                try {\n                    var isSync = true;\n                    var queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n                    // queue is in the render or commit phases.\n                    setCurrentUpdatePriority(DiscreteEventPriority);\n                    for(; i < queue.length; i++){\n                        var callback = queue[i];\n                        do {\n                            callback = callback(isSync);\n                        }while (callback !== null);\n                    }\n                    syncQueue = null;\n                    includesLegacySyncCallbacks = false;\n                } catch (error) {\n                    // If something throws, leave the remaining callbacks on the queue.\n                    if (syncQueue !== null) {\n                        syncQueue = syncQueue.slice(i + 1);\n                    } // Resume flushing in the next tick\n                    scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n                    throw error;\n                } finally{\n                    setCurrentUpdatePriority(previousUpdatePriority);\n                    isFlushingSyncQueue = false;\n                }\n            }\n            return null;\n        }\n        // This is imported by the event replaying implementation in React DOM. It's\n        // in a separate file to break a circular dependency between the renderer and\n        // the reconciler.\n        function isRootDehydrated(root) {\n            var currentState = root.current.memoizedState;\n            return currentState.isDehydrated;\n        }\n        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\n        var NoTransition = null;\n        function requestCurrentTransition() {\n            return ReactCurrentBatchConfig.transition;\n        }\n        /**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */ function shallowEqual(objA, objB) {\n            if (objectIs(objA, objB)) {\n                return true;\n            }\n            if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n                return false;\n            }\n            var keysA = Object.keys(objA);\n            var keysB = Object.keys(objB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            } // Test for A's keys different from B.\n            for(var i = 0; i < keysA.length; i++){\n                var currentKey = keysA[i];\n                if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function describeFiber(fiber) {\n            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;\n            var source = fiber._debugSource;\n            switch(fiber.tag){\n                case HostComponent:\n                    return describeBuiltInComponentFrame(fiber.type);\n                case LazyComponent:\n                    return describeBuiltInComponentFrame(\"Lazy\");\n                case SuspenseComponent:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case SuspenseListComponent:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n                case FunctionComponent:\n                case IndeterminateComponent:\n                case SimpleMemoComponent:\n                    return describeFunctionComponentFrame(fiber.type);\n                case ForwardRef:\n                    return describeFunctionComponentFrame(fiber.type.render);\n                case ClassComponent:\n                    return describeClassComponentFrame(fiber.type);\n                default:\n                    return \"\";\n            }\n        }\n        function getStackByFiberInDevAndProd(workInProgress) {\n            try {\n                var info = \"\";\n                var node = workInProgress;\n                do {\n                    info += describeFiber(node);\n                    node = node.return;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberOwnerNameInDevOrNull() {\n            {\n                if (current === null) {\n                    return null;\n                }\n                var owner = current._debugOwner;\n                if (owner !== null && typeof owner !== \"undefined\") {\n                    return getComponentNameFromFiber(owner);\n                }\n            }\n            return null;\n        }\n        function getCurrentFiberStackInDev() {\n            {\n                if (current === null) {\n                    return \"\";\n                } // Safe because if current fiber exists, we are reconciling,\n                // and it is guaranteed to be the work-in-progress version.\n                return getStackByFiberInDevAndProd(current);\n            }\n        }\n        function resetCurrentFiber() {\n            {\n                ReactDebugCurrentFrame$1.getCurrentStack = null;\n                current = null;\n                isRendering = false;\n            }\n        }\n        function setCurrentFiber(fiber) {\n            {\n                ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;\n                current = fiber;\n                isRendering = false;\n            }\n        }\n        function setIsRendering(rendering) {\n            {\n                isRendering = rendering;\n            }\n        }\n        var ReactStrictModeWarnings = {\n            recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n            flushPendingUnsafeLifecycleWarnings: function() {},\n            recordLegacyContextWarning: function(fiber, instance) {},\n            flushLegacyContextWarning: function() {},\n            discardPendingWarnings: function() {}\n        };\n        {\n            var findStrictRoot = function(fiber) {\n                var maybeStrictRoot = null;\n                var node = fiber;\n                while(node !== null){\n                    if (node.mode & StrictLegacyMode) {\n                        maybeStrictRoot = node;\n                    }\n                    node = node.return;\n                }\n                return maybeStrictRoot;\n            };\n            var setToSortedString = function(set) {\n                var array = [];\n                set.forEach(function(value) {\n                    array.push(value);\n                });\n                return array.sort().join(\", \");\n            };\n            var pendingComponentWillMountWarnings = [];\n            var pendingUNSAFE_ComponentWillMountWarnings = [];\n            var pendingComponentWillReceivePropsWarnings = [];\n            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            var pendingComponentWillUpdateWarnings = [];\n            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n            var didWarnAboutUnsafeLifecycles = new Set();\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n                // Dedupe strategy: Warn once per component.\n                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n                    return;\n                }\n                if (typeof instance.componentWillMount === \"function\" && // Don't warn about react-lifecycles-compat polyfilled components.\n                instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillMountWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === \"function\") {\n                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillUpdateWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n                // We do an initial pass to gather component names\n                var componentWillMountUniqueNames = new Set();\n                if (pendingComponentWillMountWarnings.length > 0) {\n                    pendingComponentWillMountWarnings.forEach(function(fiber) {\n                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillMountWarnings = [];\n                }\n                var UNSAFE_componentWillMountUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillMountWarnings = [];\n                }\n                var componentWillReceivePropsUniqueNames = new Set();\n                if (pendingComponentWillReceivePropsWarnings.length > 0) {\n                    pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillReceivePropsWarnings = [];\n                }\n                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                }\n                var componentWillUpdateUniqueNames = new Set();\n                if (pendingComponentWillUpdateWarnings.length > 0) {\n                    pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillUpdateWarnings = [];\n                }\n                var UNSAFE_componentWillUpdateUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                } // Finally, we flush all the warnings\n                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n                if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n                    error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\" + \"\\nPlease update the following components: %s\", sortedNames);\n                }\n                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n                    error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended \" + \"and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* If you're updating state whenever props change, \" + \"refactor your code to use memoization techniques or move it to \" + \"static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n\" + \"\\nPlease update the following components: %s\", _sortedNames);\n                }\n                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n                    error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended \" + \"and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames2);\n                }\n                if (componentWillMountUniqueNames.size > 0) {\n                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n                    warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\" + \"* Rename componentWillMount to UNSAFE_componentWillMount to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames3);\n                }\n                if (componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n                    warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* If you're updating state whenever props change, refactor your \" + \"code to use memoization techniques or move it to \" + \"static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n\" + \"* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames4);\n                }\n                if (componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n                    warn(\"componentWillUpdate has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames5);\n                }\n            };\n            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n            var didWarnAboutLegacyContext = new Set();\n            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n                var strictRoot = findStrictRoot(fiber);\n                if (strictRoot === null) {\n                    error(\"Expected to find a StrictMode component in a strict mode tree. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                    return;\n                } // Dedup strategy: Warn once per component.\n                if (didWarnAboutLegacyContext.has(fiber.type)) {\n                    return;\n                }\n                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === \"function\") {\n                    if (warningsForRoot === undefined) {\n                        warningsForRoot = [];\n                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n                    }\n                    warningsForRoot.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n                pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n                    if (fiberArray.length === 0) {\n                        return;\n                    }\n                    var firstFiber = fiberArray[0];\n                    var uniqueNames = new Set();\n                    fiberArray.forEach(function(fiber) {\n                        uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutLegacyContext.add(fiber.type);\n                    });\n                    var sortedNames = setToSortedString(uniqueNames);\n                    try {\n                        setCurrentFiber(firstFiber);\n                        error(\"Legacy context API has been detected within a strict-mode tree.\" + \"\\n\\nThe old API will be supported in all 16.x releases, but applications \" + \"using it should migrate to the new version.\" + \"\\n\\nPlease update the following components: %s\" + \"\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context\", sortedNames);\n                    } finally{\n                        resetCurrentFiber();\n                    }\n                });\n            };\n            ReactStrictModeWarnings.discardPendingWarnings = function() {\n                pendingComponentWillMountWarnings = [];\n                pendingUNSAFE_ComponentWillMountWarnings = [];\n                pendingComponentWillReceivePropsWarnings = [];\n                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                pendingComponentWillUpdateWarnings = [];\n                pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                pendingLegacyContextWarning = new Map();\n            };\n        }\n        /*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                return type;\n            }\n        } // $FlowFixMe only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkPropStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` prop is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        var valueCursor = createCursor(null);\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n            // This is called right before React yields execution, to ensure `readContext`\n            // cannot be called outside the render phase.\n            currentlyRenderingFiber = null;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function enterDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = true;\n            }\n        }\n        function exitDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n            if (isPrimaryRenderer) {\n                push(valueCursor, context._currentValue, providerFiber);\n                context._currentValue = nextValue;\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            } else {\n                push(valueCursor, context._currentValue2, providerFiber);\n                context._currentValue2 = nextValue;\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n        }\n        function popProvider(context, providerFiber) {\n            var currentValue = valueCursor.current;\n            pop(valueCursor, providerFiber);\n            if (isPrimaryRenderer) {\n                {\n                    context._currentValue = currentValue;\n                }\n            } else {\n                {\n                    context._currentValue2 = currentValue;\n                }\n            }\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n            // Update the child lanes of all the ancestors, including the alternates.\n            var node = parent;\n            while(node !== null){\n                var alternate = node.alternate;\n                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n                    node.childLanes = mergeLanes(node.childLanes, renderLanes);\n                    if (alternate !== null) {\n                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                    }\n                } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                }\n                if (node === propagationRoot) {\n                    break;\n                }\n                node = node.return;\n            }\n            {\n                if (node !== propagationRoot) {\n                    error(\"Expected to find the propagation root when scheduling context work. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        function propagateContextChange(workInProgress, context, renderLanes) {\n            {\n                propagateContextChange_eager(workInProgress, context, renderLanes);\n            }\n        }\n        function propagateContextChange_eager(workInProgress, context, renderLanes) {\n            var fiber = workInProgress.child;\n            if (fiber !== null) {\n                // Set the return pointer of the child to the work-in-progress fiber.\n                fiber.return = workInProgress;\n            }\n            while(fiber !== null){\n                var nextFiber = void 0; // Visit this fiber.\n                var list = fiber.dependencies;\n                if (list !== null) {\n                    nextFiber = fiber.child;\n                    var dependency = list.firstContext;\n                    while(dependency !== null){\n                        // Check if the context matches.\n                        if (dependency.context === context) {\n                            // Match! Schedule an update on this fiber.\n                            if (fiber.tag === ClassComponent) {\n                                // Schedule a force update on the work-in-progress.\n                                var lane = pickArbitraryLane(renderLanes);\n                                var update = createUpdate(NoTimestamp, lane);\n                                update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n                                // update to the current fiber, too, which means it will persist even if\n                                // this render is thrown away. Since it's a race condition, not sure it's\n                                // worth fixing.\n                                // Inlined `enqueueUpdate` to remove interleaved update check\n                                var updateQueue = fiber.updateQueue;\n                                if (updateQueue === null) ;\n                                else {\n                                    var sharedQueue = updateQueue.shared;\n                                    var pending = sharedQueue.pending;\n                                    if (pending === null) {\n                                        // This is the first update. Create a circular list.\n                                        update.next = update;\n                                    } else {\n                                        update.next = pending.next;\n                                        pending.next = update;\n                                    }\n                                    sharedQueue.pending = update;\n                                }\n                            }\n                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n                            var alternate = fiber.alternate;\n                            if (alternate !== null) {\n                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n                            }\n                            scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n                            list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n                            break;\n                        }\n                        dependency = dependency.next;\n                    }\n                } else if (fiber.tag === ContextProvider) {\n                    // Don't scan deeper if this is a matching provider\n                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n                } else if (fiber.tag === DehydratedFragment) {\n                    // If a dehydrated suspense boundary is in this subtree, we don't know\n                    // if it will have any context consumers in it. The best we can do is\n                    // mark it as having updates.\n                    var parentSuspense = fiber.return;\n                    if (parentSuspense === null) {\n                        throw new Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                    }\n                    parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n                    var _alternate = parentSuspense.alternate;\n                    if (_alternate !== null) {\n                        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n                    } // This is intentionally passing this fiber as the parent\n                    // because we want to schedule this fiber as having work\n                    // on its children. We'll use the childLanes on\n                    // this fiber to indicate that a context has changed.\n                    scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n                    nextFiber = fiber.sibling;\n                } else {\n                    // Traverse down.\n                    nextFiber = fiber.child;\n                }\n                if (nextFiber !== null) {\n                    // Set the return pointer of the child to the work-in-progress fiber.\n                    nextFiber.return = fiber;\n                } else {\n                    // No child. Traverse to next sibling.\n                    nextFiber = fiber;\n                    while(nextFiber !== null){\n                        if (nextFiber === workInProgress) {\n                            // We're back to the root of this subtree. Exit.\n                            nextFiber = null;\n                            break;\n                        }\n                        var sibling = nextFiber.sibling;\n                        if (sibling !== null) {\n                            // Set the return pointer of the sibling to the work-in-progress fiber.\n                            sibling.return = nextFiber.return;\n                            nextFiber = sibling;\n                            break;\n                        } // No more siblings. Traverse up.\n                        nextFiber = nextFiber.return;\n                    }\n                }\n                fiber = nextFiber;\n            }\n        }\n        function prepareToReadContext(workInProgress, renderLanes) {\n            currentlyRenderingFiber = workInProgress;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            var dependencies = workInProgress.dependencies;\n            if (dependencies !== null) {\n                {\n                    var firstContext = dependencies.firstContext;\n                    if (firstContext !== null) {\n                        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n                            // Context list has a pending update. Mark that this fiber performed work.\n                            markWorkInProgressReceivedUpdate();\n                        } // Reset the work-in-progress list\n                        dependencies.firstContext = null;\n                    }\n                }\n            }\n        }\n        function readContext(context) {\n            {\n                // This warning would fire if you read context inside a Hook like useMemo.\n                // Unlike the class check below, it's not enforced in production for perf.\n                if (isDisallowedContextReadInDEV) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n            if (lastFullyObservedContext === context) ;\n            else {\n                var contextItem = {\n                    context: context,\n                    memoizedValue: value,\n                    next: null\n                };\n                if (lastContextDependency === null) {\n                    if (currentlyRenderingFiber === null) {\n                        throw new Error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                    } // This is the first dependency for this component. Create a new list.\n                    lastContextDependency = contextItem;\n                    currentlyRenderingFiber.dependencies = {\n                        lanes: NoLanes,\n                        firstContext: contextItem\n                    };\n                } else {\n                    // Append a new context item.\n                    lastContextDependency = lastContextDependency.next = contextItem;\n                }\n            }\n            return value;\n        }\n        // An array of all update queues that received updates during the current\n        // render. When this render exits, either because it finishes or because it is\n        // interrupted, the interleaved updates will be transferred onto the main part\n        // of the queue.\n        var interleavedQueues = null;\n        function pushInterleavedQueue(queue) {\n            if (interleavedQueues === null) {\n                interleavedQueues = [\n                    queue\n                ];\n            } else {\n                interleavedQueues.push(queue);\n            }\n        }\n        function enqueueInterleavedUpdates() {\n            // Transfer the interleaved updates onto the main queue. Each queue has a\n            // `pending` field and an `interleaved` field. When they are not null, they\n            // point to the last node in a circular linked list. We need to append the\n            // interleaved list to the end of the pending list by joining them into a\n            // single, circular list.\n            if (interleavedQueues !== null) {\n                for(var i = 0; i < interleavedQueues.length; i++){\n                    var queue = interleavedQueues[i];\n                    var lastInterleavedUpdate = queue.interleaved;\n                    if (lastInterleavedUpdate !== null) {\n                        queue.interleaved = null;\n                        var firstInterleavedUpdate = lastInterleavedUpdate.next;\n                        var lastPendingUpdate = queue.pending;\n                        if (lastPendingUpdate !== null) {\n                            var firstPendingUpdate = lastPendingUpdate.next;\n                            lastPendingUpdate.next = firstInterleavedUpdate;\n                            lastInterleavedUpdate.next = firstPendingUpdate;\n                        }\n                        queue.pending = lastInterleavedUpdate;\n                    }\n                }\n                interleavedQueues = null;\n            }\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n        // It should only be read right after calling `processUpdateQueue`, via\n        // `checkHasForceUpdateAfterProcessing`.\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n            didWarnUpdateInsideUpdate = false;\n            currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n            var queue = {\n                baseState: fiber.memoizedState,\n                firstBaseUpdate: null,\n                lastBaseUpdate: null,\n                shared: {\n                    pending: null,\n                    interleaved: null,\n                    lanes: NoLanes\n                },\n                effects: null\n            };\n            fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current, workInProgress) {\n            // Clone the update queue from current. Unless it's already a clone.\n            var queue = workInProgress.updateQueue;\n            var currentQueue = current.updateQueue;\n            if (queue === currentQueue) {\n                var clone = {\n                    baseState: currentQueue.baseState,\n                    firstBaseUpdate: currentQueue.firstBaseUpdate,\n                    lastBaseUpdate: currentQueue.lastBaseUpdate,\n                    shared: currentQueue.shared,\n                    effects: currentQueue.effects\n                };\n                workInProgress.updateQueue = clone;\n            }\n        }\n        function createUpdate(eventTime, lane) {\n            var update = {\n                eventTime: eventTime,\n                lane: lane,\n                tag: UpdateState,\n                payload: null,\n                callback: null,\n                next: null\n            };\n            return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isInterleavedUpdate(fiber)) {\n                var interleaved = sharedQueue.interleaved;\n                if (interleaved === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update; // At the end of the current render, this queue's interleaved updates will\n                    // be transferred to the pending queue.\n                    pushInterleavedQueue(sharedQueue);\n                } else {\n                    update.next = interleaved.next;\n                    interleaved.next = update;\n                }\n                sharedQueue.interleaved = update;\n            } else {\n                var pending = sharedQueue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                sharedQueue.pending = update;\n            }\n            {\n                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n                    error(\"An update (setState, replaceState, or forceUpdate) was scheduled \" + \"from inside an update function. Update functions should be pure, \" + \"with zero side-effects. Consider using componentDidUpdate or a \" + \"callback.\");\n                    didWarnUpdateInsideUpdate = true;\n                }\n            }\n        }\n        function entangleTransitions(root, fiber, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isTransitionLane(lane)) {\n                var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n                // have finished. We can remove them from the shared queue, which represents\n                // a superset of the actually pending lanes. In some cases we may entangle\n                // more than we need to, but that's OK. In fact it's worse if we *don't*\n                // entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n            // Captured updates are updates that are thrown by a child during the render\n            // phase. They should be discarded if the render is aborted. Therefore,\n            // we should only put them on the work-in-progress queue, not the current one.\n            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n            var current = workInProgress.alternate;\n            if (current !== null) {\n                var currentQueue = current.updateQueue;\n                if (queue === currentQueue) {\n                    // The work-in-progress queue is the same as current. This happens when\n                    // we bail out on a parent fiber that then captures an error thrown by\n                    // a child. Since we want to append the update only to the work-in\n                    // -progress queue, we need to clone the updates. We usually clone during\n                    // processUpdateQueue, but that didn't happen in this case because we\n                    // skipped over the parent when we bailed out.\n                    var newFirst = null;\n                    var newLast = null;\n                    var firstBaseUpdate = queue.firstBaseUpdate;\n                    if (firstBaseUpdate !== null) {\n                        // Loop through the updates and clone them.\n                        var update = firstBaseUpdate;\n                        do {\n                            var clone = {\n                                eventTime: update.eventTime,\n                                lane: update.lane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                callback: update.callback,\n                                next: null\n                            };\n                            if (newLast === null) {\n                                newFirst = newLast = clone;\n                            } else {\n                                newLast.next = clone;\n                                newLast = clone;\n                            }\n                            update = update.next;\n                        }while (update !== null); // Append the captured update the end of the cloned list.\n                        if (newLast === null) {\n                            newFirst = newLast = capturedUpdate;\n                        } else {\n                            newLast.next = capturedUpdate;\n                            newLast = capturedUpdate;\n                        }\n                    } else {\n                        // There are no base updates.\n                        newFirst = newLast = capturedUpdate;\n                    }\n                    queue = {\n                        baseState: currentQueue.baseState,\n                        firstBaseUpdate: newFirst,\n                        lastBaseUpdate: newLast,\n                        shared: currentQueue.shared,\n                        effects: currentQueue.effects\n                    };\n                    workInProgress.updateQueue = queue;\n                    return;\n                }\n            } // Append the update to the end of the list.\n            var lastBaseUpdate = queue.lastBaseUpdate;\n            if (lastBaseUpdate === null) {\n                queue.firstBaseUpdate = capturedUpdate;\n            } else {\n                lastBaseUpdate.next = capturedUpdate;\n            }\n            queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n            switch(update.tag){\n                case ReplaceState:\n                    {\n                        var payload = update.payload;\n                        if (typeof payload === \"function\") {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            var nextState = payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                            return nextState;\n                        } // State object\n                        return payload;\n                    }\n                case CaptureUpdate:\n                    {\n                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n                    }\n                // Intentional fallthrough\n                case UpdateState:\n                    {\n                        var _payload = update.payload;\n                        var partialState;\n                        if (typeof _payload === \"function\") {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            partialState = _payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        _payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                        } else {\n                            // Partial state object\n                            partialState = _payload;\n                        }\n                        if (partialState === null || partialState === undefined) {\n                            // Null and undefined are treated as no-ops.\n                            return prevState;\n                        } // Merge the partial state and the previous state.\n                        return assign({}, prevState, partialState);\n                    }\n                case ForceUpdate:\n                    {\n                        hasForceUpdate = true;\n                        return prevState;\n                    }\n            }\n            return prevState;\n        }\n        function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n            // This is always non-null on a ClassComponent or HostRoot\n            var queue = workInProgress.updateQueue;\n            hasForceUpdate = false;\n            {\n                currentlyProcessingQueue = queue.shared;\n            }\n            var firstBaseUpdate = queue.firstBaseUpdate;\n            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n            var pendingQueue = queue.shared.pending;\n            if (pendingQueue !== null) {\n                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n                // and last so that it's non-circular.\n                var lastPendingUpdate = pendingQueue;\n                var firstPendingUpdate = lastPendingUpdate.next;\n                lastPendingUpdate.next = null; // Append pending updates to base queue\n                if (lastBaseUpdate === null) {\n                    firstBaseUpdate = firstPendingUpdate;\n                } else {\n                    lastBaseUpdate.next = firstPendingUpdate;\n                }\n                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n                // we need to transfer the updates to that queue, too. Because the base\n                // queue is a singly-linked list with no cycles, we can append to both\n                // lists and take advantage of structural sharing.\n                // TODO: Pass `current` as argument\n                var current = workInProgress.alternate;\n                if (current !== null) {\n                    // This is always non-null on a ClassComponent or HostRoot\n                    var currentQueue = current.updateQueue;\n                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n                    if (currentLastBaseUpdate !== lastBaseUpdate) {\n                        if (currentLastBaseUpdate === null) {\n                            currentQueue.firstBaseUpdate = firstPendingUpdate;\n                        } else {\n                            currentLastBaseUpdate.next = firstPendingUpdate;\n                        }\n                        currentQueue.lastBaseUpdate = lastPendingUpdate;\n                    }\n                }\n            } // These values may change as we process the queue.\n            if (firstBaseUpdate !== null) {\n                // Iterate through the list of updates to compute the result.\n                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n                // from the original lanes.\n                var newLanes = NoLanes;\n                var newBaseState = null;\n                var newFirstBaseUpdate = null;\n                var newLastBaseUpdate = null;\n                var update = firstBaseUpdate;\n                do {\n                    var updateLane = update.lane;\n                    var updateEventTime = update.eventTime;\n                    if (!isSubsetOfLanes(renderLanes, updateLane)) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            eventTime: updateEventTime,\n                            lane: updateLane,\n                            tag: update.tag,\n                            payload: update.payload,\n                            callback: update.callback,\n                            next: null\n                        };\n                        if (newLastBaseUpdate === null) {\n                            newFirstBaseUpdate = newLastBaseUpdate = clone;\n                            newBaseState = newState;\n                        } else {\n                            newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                        } // Update the remaining priority in the queue.\n                        newLanes = mergeLanes(newLanes, updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        if (newLastBaseUpdate !== null) {\n                            var _clone = {\n                                eventTime: updateEventTime,\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                callback: update.callback,\n                                next: null\n                            };\n                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                        } // Process this update.\n                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n                        var callback = update.callback;\n                        if (callback !== null && // If the update was already committed, we should not queue its\n                        // callback again.\n                        update.lane !== NoLane) {\n                            workInProgress.flags |= Callback;\n                            var effects = queue.effects;\n                            if (effects === null) {\n                                queue.effects = [\n                                    update\n                                ];\n                            } else {\n                                effects.push(update);\n                            }\n                        }\n                    }\n                    update = update.next;\n                    if (update === null) {\n                        pendingQueue = queue.shared.pending;\n                        if (pendingQueue === null) {\n                            break;\n                        } else {\n                            // An update was scheduled from inside a reducer. Add the new\n                            // pending updates to the end of the list and keep processing.\n                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n                            // unravel them when transferring them to the base queue.\n                            var _firstPendingUpdate = _lastPendingUpdate.next;\n                            _lastPendingUpdate.next = null;\n                            update = _firstPendingUpdate;\n                            queue.lastBaseUpdate = _lastPendingUpdate;\n                            queue.shared.pending = null;\n                        }\n                    }\n                }while (true);\n                if (newLastBaseUpdate === null) {\n                    newBaseState = newState;\n                }\n                queue.baseState = newBaseState;\n                queue.firstBaseUpdate = newFirstBaseUpdate;\n                queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n                // process them during this render, but we do need to track which lanes\n                // are remaining.\n                var lastInterleaved = queue.shared.interleaved;\n                if (lastInterleaved !== null) {\n                    var interleaved = lastInterleaved;\n                    do {\n                        newLanes = mergeLanes(newLanes, interleaved.lane);\n                        interleaved = interleaved.next;\n                    }while (interleaved !== lastInterleaved);\n                } else if (firstBaseUpdate === null) {\n                    // `queue.lanes` is used for entangling transitions. We can set it back to\n                    // zero once the queue is empty.\n                    queue.shared.lanes = NoLanes;\n                } // Set the remaining expiration time to be whatever is remaining in the queue.\n                // This should be fine because the only two other things that contribute to\n                // expiration time are props and context. We're already in the middle of the\n                // begin phase by the time we start processing the queue, so we've already\n                // dealt with the props. Context in components that specify\n                // shouldComponentUpdate is tricky; but we'll have to account for\n                // that regardless.\n                markSkippedUpdateLanes(newLanes);\n                workInProgress.lanes = newLanes;\n                workInProgress.memoizedState = newState;\n            }\n            {\n                currentlyProcessingQueue = null;\n            }\n        }\n        function callCallback(callback, context) {\n            if (typeof callback !== \"function\") {\n                throw new Error(\"Invalid argument passed as callback. Expected a function. Instead \" + (\"received: \" + callback));\n            }\n            callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n            hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n            return hasForceUpdate;\n        }\n        function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n            // Commit the effects\n            var effects = finishedQueue.effects;\n            finishedQueue.effects = null;\n            if (effects !== null) {\n                for(var i = 0; i < effects.length; i++){\n                    var effect = effects[i];\n                    var callback = effect.callback;\n                    if (callback !== null) {\n                        effect.callback = null;\n                        callCallback(callback, instance);\n                    }\n                }\n            }\n        }\n        var fakeInternalInstance = {}; // React.Component uses a shared frozen object by default.\n        // We'll use it to determine whether we need to initialize legacy refs.\n        var emptyRefsObject = new React.Component().refs;\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var warnOnUndefinedDerivedState;\n        var warnOnInvalidCallback;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        {\n            didWarnAboutStateAssignmentForComponent = new Set();\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            var didWarnOnInvalidCallback = new Set();\n            warnOnInvalidCallback = function(callback, callerName) {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            };\n            warnOnUndefinedDerivedState = function(type, partialState) {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }; // This is so gross but it's at least non-critical and can be removed if\n            // it causes problems. This is meant to give a nicer error message for\n            // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n            // ...)) which otherwise throws a \"_processChildContext is not a function\"\n            // exception.\n            Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n                enumerable: false,\n                value: function() {\n                    throw new Error(\"_processChildContext is not available in React 16+. This likely \" + \"means you have multiple copies of React and are attempting to nest \" + \"a React 15 tree inside a React 16 tree using \" + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + \"to make sure you have only one copy of React (and ideally, switch \" + \"to ReactDOM.createPortal).\");\n                }\n            });\n            Object.freeze(fakeInternalInstance);\n        }\n        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n            var prevState = workInProgress.memoizedState;\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        // Invoke the function an extra time to help detect side-effects.\n                        partialState = getDerivedStateFromProps(nextProps, prevState);\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n            // base state.\n            if (workInProgress.lanes === NoLanes) {\n                // Queue is always non-null for classes\n                var updateQueue = workInProgress.updateQueue;\n                updateQueue.baseState = memoizedState;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: isMounted,\n            enqueueSetState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.tag = ReplaceState;\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"replaceState\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueForceUpdate: function(inst, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.tag = ForceUpdate;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"forceUpdate\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        };\n        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n            var instance = workInProgress.stateNode;\n            if (typeof instance.shouldComponentUpdate === \"function\") {\n                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            // Invoke the function an extra time to help detect side-effects.\n                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    if (shouldUpdate === undefined) {\n                        error(\"%s.shouldComponentUpdate(): Returned undefined instead of a \" + \"boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n                    }\n                }\n                return shouldUpdate;\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n            }\n            return true;\n        }\n        function checkClassInstance(workInProgress, ctor, newProps) {\n            var instance = workInProgress.stateNode;\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var _state = instance.state;\n                if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function adoptClassInstance(workInProgress, instance) {\n            instance.updater = classComponentUpdater;\n            workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n            set(instance, workInProgress);\n            {\n                instance._reactInternalInstance = fakeInternalInstance;\n            }\n        }\n        function constructClassInstance(workInProgress, ctor, props) {\n            var isLegacyContextConsumer = false;\n            var unmaskedContext = emptyContextObject;\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext(contextType);\n            } else {\n                unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                var contextTypes = ctor.contextTypes;\n                isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n                context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n            }\n            var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        instance = new ctor(props, context); // eslint-disable-line no-new\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n            }\n            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n            adoptClassInstance(workInProgress, instance);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            // ReactFiberContext usually updates this cache but can't for newly-created instances.\n            if (isLegacyContextConsumer) {\n                cacheContext(workInProgress, unmaskedContext, context);\n            }\n            return instance;\n        }\n        function callComponentWillMount(workInProgress, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillReceiveProps === \"function\") {\n                instance.componentWillReceiveProps(newProps, nextContext);\n            }\n            if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n            }\n            if (instance.state !== oldState) {\n                {\n                    var componentName = getComponentNameFromFiber(workInProgress) || \"Component\";\n                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                        didWarnAboutStateAssignmentForComponent.add(componentName);\n                        error(\"%s.componentWillReceiveProps(): Assigning directly to \" + \"this.state is deprecated (except inside a component's \" + \"constructor). Use setState instead.\", componentName);\n                    }\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            {\n                checkClassInstance(workInProgress, ctor, newProps);\n            }\n            var instance = workInProgress.stateNode;\n            instance.props = newProps;\n            instance.state = workInProgress.memoizedState;\n            instance.refs = emptyRefsObject;\n            initializeUpdateQueue(workInProgress);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                instance.context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n                }\n                {\n                    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n                }\n            }\n            instance.state = workInProgress.memoizedState;\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                instance.state = workInProgress.memoizedState;\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n                instance.state = workInProgress.memoizedState;\n            }\n            if (typeof instance.componentDidMount === \"function\") {\n                var fiberFlags = Update;\n                {\n                    fiberFlags |= LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    fiberFlags |= MountLayoutDev;\n                }\n                workInProgress.flags |= fiberFlags;\n            }\n        }\n        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            var oldProps = workInProgress.memoizedProps;\n            instance.props = oldProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                nextContext = readContext(contextType);\n            } else {\n                var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\"; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n                if (oldProps !== newProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            newState = workInProgress.memoizedState;\n            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === \"function\") {\n                    var fiberFlags = Update;\n                    {\n                        fiberFlags |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        fiberFlags |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= fiberFlags;\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                    if (typeof instance.componentWillMount === \"function\") {\n                        instance.componentWillMount();\n                    }\n                    if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        instance.UNSAFE_componentWillMount();\n                    }\n                }\n                if (typeof instance.componentDidMount === \"function\") {\n                    var _fiberFlags = Update;\n                    {\n                        _fiberFlags |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        _fiberFlags |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= _fiberFlags;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === \"function\") {\n                    var _fiberFlags2 = Update;\n                    {\n                        _fiberFlags2 |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        _fiberFlags2 |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= _fiberFlags2;\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        } // Invokes the update life-cycles and returns false if it shouldn't rerender.\n        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n            instance.props = oldProps;\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                nextContext = readContext(contextType);\n            } else {\n                var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\"; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            newState = workInProgress.memoizedState;\n            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n            // both before and after `shouldComponentUpdate` has been called. Not ideal,\n            // but I'm loath to refactor this function. This only happens for memoized\n            // components so it's not that common.\n            enableLazyContextPropagation;\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === \"function\" || typeof instance.componentWillUpdate === \"function\")) {\n                    if (typeof instance.componentWillUpdate === \"function\") {\n                        instance.componentWillUpdate(newProps, newState, nextContext);\n                    }\n                    if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n                    }\n                }\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    workInProgress.flags |= Update;\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    workInProgress.flags |= Snapshot;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized props/state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        }\n        // TODO: Use the unified fiber stack module instead of this local one?\n        // Intentionally not using it yet to derisk the initial implementation, because\n        // the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n        // rather the ids be wrong than crash the whole reconciler.\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = \"\";\n        function isForkedChild(workInProgress) {\n            warnIfNotHydrating();\n            return (workInProgress.flags & Forked) !== NoFlags;\n        }\n        function getForksAtLevel(workInProgress) {\n            warnIfNotHydrating();\n            return treeForkCount;\n        }\n        function getTreeId() {\n            var overflow = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress, totalChildren) {\n            // This is called right after we reconcile an array (or iterator) of child\n            // fibers, because that's the only place where we know how many children in\n            // the whole set without doing extra work later, or storing addtional\n            // information on the fiber.\n            //\n            // That's why this function is separate from pushTreeId — it's called during\n            // the render phase of the fork parent, not the child, which is where we push\n            // the other context values.\n            //\n            // In the Fizz implementation this is much simpler because the child is\n            // rendered in the same callstack as the parent.\n            //\n            // It might be better to just add a `forks` field to the Fiber type. It would\n            // make this module simpler.\n            warnIfNotHydrating();\n            forkStack[forkStackIndex++] = treeForkCount;\n            forkStack[forkStackIndex++] = treeForkProvider;\n            treeForkProvider = workInProgress;\n            treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress, totalChildren, index) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextProvider = workInProgress;\n            var baseIdWithLeadingBit = treeContextId;\n            var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                treeContextId = 1 << restOfLength | id;\n                treeContextOverflow = overflow;\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                treeContextId = 1 << length | _id;\n                treeContextOverflow = _overflow;\n            }\n        }\n        function pushMaterializedTreeId(workInProgress) {\n            warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n            // in its children.\n            var returnFiber = workInProgress.return;\n            if (returnFiber !== null) {\n                var numberOfForks = 1;\n                var slotIndex = 0;\n                pushTreeFork(workInProgress, numberOfForks);\n                pushTreeId(workInProgress, numberOfForks, slotIndex);\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress) {\n            // Restore the previous values.\n            // This is a bit more complicated than other context-like modules in Fiber\n            // because the same Fiber may appear on the stack multiple times and for\n            // different reasons. We have to keep popping until the work-in-progress is\n            // no longer at the top of the stack.\n            while(workInProgress === treeForkProvider){\n                treeForkProvider = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n                treeForkCount = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n            }\n            while(workInProgress === treeContextProvider){\n                treeContextProvider = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextOverflow = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextId = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n            }\n        }\n        function getSuspendedTreeContext() {\n            warnIfNotHydrating();\n            if (treeContextProvider !== null) {\n                return {\n                    id: treeContextId,\n                    overflow: treeContextOverflow\n                };\n            } else {\n                return null;\n            }\n        }\n        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextId = suspendedContext.id;\n            treeContextOverflow = suspendedContext.overflow;\n            treeContextProvider = workInProgress;\n        }\n        function warnIfNotHydrating() {\n            {\n                if (!getIsHydrating()) {\n                    error(\"Expected to be hydrating. This is a bug in React. Please file \" + \"an issue.\");\n                }\n            }\n        }\n        // This may have been an insertion or a hydration.\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false;\n        var didSuspend = false; // Hydration errors that were thrown inside this boundary\n        var hydrationErrors = null;\n        function warnIfHydrating() {\n            {\n                if (isHydrating) {\n                    error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\");\n                }\n            }\n        }\n        function markDidSuspendWhileHydratingDEV() {\n            {\n                didSuspend = true;\n            }\n        }\n        function enterHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            var parentInstance = fiber.stateNode.containerInfo;\n            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspend = false;\n            return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n            if (!supportsHydration) {\n                return false;\n            }\n            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspend = false;\n            if (treeContext !== null) {\n                restoreSuspendedTreeContext(fiber, treeContext);\n            }\n            return true;\n        }\n        function warnUnhydratedInstance(returnFiber, instance) {\n            {\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n                        break;\n                    case HostComponent:\n                        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n                        break;\n                    case SuspenseComponent:\n                        var suspenseState = returnFiber.memoizedState;\n                        if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n                        break;\n                }\n            }\n        }\n        function deleteHydratableInstance(returnFiber, instance) {\n            warnUnhydratedInstance(returnFiber, instance);\n            var childToDelete = createFiberFromHostInstanceForDeletion();\n            childToDelete.stateNode = instance;\n            childToDelete.return = returnFiber;\n            var deletions = returnFiber.deletions;\n            if (deletions === null) {\n                returnFiber.deletions = [\n                    childToDelete\n                ];\n                returnFiber.flags |= ChildDeletion;\n            } else {\n                deletions.push(childToDelete);\n            }\n        }\n        function warnNonhydratedInstance(returnFiber, fiber) {\n            {\n                if (didSuspend) {\n                    // Inside a boundary that already suspended. We're currently rendering the\n                    // siblings of a suspended node. The mismatch may be due to the missing\n                    // data, so it's probably a false positive.\n                    return;\n                }\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        {\n                            var parentContainer = returnFiber.stateNode.containerInfo;\n                            switch(fiber.tag){\n                                case HostComponent:\n                                    var type = fiber.type;\n                                    var props = fiber.pendingProps;\n                                    didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n                                    break;\n                                case HostText:\n                                    var text = fiber.pendingProps;\n                                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n                                    break;\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            var parentType = returnFiber.type;\n                            var parentProps = returnFiber.memoizedProps;\n                            var parentInstance = returnFiber.stateNode;\n                            switch(fiber.tag){\n                                case HostComponent:\n                                    var _type = fiber.type;\n                                    var _props = fiber.pendingProps;\n                                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                                    break;\n                                case HostText:\n                                    var _text = fiber.pendingProps;\n                                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n                                    break;\n                            }\n                            break;\n                        }\n                    case SuspenseComponent:\n                        {\n                            var suspenseState = returnFiber.memoizedState;\n                            var _parentInstance = suspenseState.dehydrated;\n                            if (_parentInstance !== null) switch(fiber.tag){\n                                case HostComponent:\n                                    var _type2 = fiber.type;\n                                    var _props2 = fiber.pendingProps;\n                                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);\n                                    break;\n                                case HostText:\n                                    var _text2 = fiber.pendingProps;\n                                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);\n                                    break;\n                            }\n                            break;\n                        }\n                    default:\n                        return;\n                }\n            }\n        }\n        function insertNonHydratedInstance(returnFiber, fiber) {\n            fiber.flags = fiber.flags & ~Hydrating | Placement;\n            warnNonhydratedInstance(returnFiber, fiber);\n        }\n        function tryHydrate(fiber, nextInstance) {\n            switch(fiber.tag){\n                case HostComponent:\n                    {\n                        var type = fiber.type;\n                        var props = fiber.pendingProps;\n                        var instance = canHydrateInstance(nextInstance, type, props);\n                        if (instance !== null) {\n                            fiber.stateNode = instance;\n                            hydrationParentFiber = fiber;\n                            nextHydratableInstance = getFirstHydratableChild(instance);\n                            return true;\n                        }\n                        return false;\n                    }\n                case HostText:\n                    {\n                        var text = fiber.pendingProps;\n                        var textInstance = canHydrateTextInstance(nextInstance, text);\n                        if (textInstance !== null) {\n                            fiber.stateNode = textInstance;\n                            hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n                            nextHydratableInstance = null;\n                            return true;\n                        }\n                        return false;\n                    }\n                case SuspenseComponent:\n                    {\n                        {\n                            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n                            if (suspenseInstance !== null) {\n                                var suspenseState = {\n                                    dehydrated: suspenseInstance,\n                                    treeContext: getSuspendedTreeContext(),\n                                    retryLane: OffscreenLane\n                                };\n                                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n                                // This simplifies the code for getHostSibling and deleting nodes,\n                                // since it doesn't have to consider all Suspense boundaries and\n                                // check if they're dehydrated ones or not.\n                                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                                dehydratedFragment.return = fiber;\n                                fiber.child = dehydratedFragment;\n                                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n                                // it during the first pass. Instead, we'll reenter it later.\n                                nextHydratableInstance = null;\n                                return true;\n                            }\n                        }\n                        return false;\n                    }\n                default:\n                    return false;\n            }\n        }\n        function shouldClientRenderOnMismatch(fiber) {\n            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n        }\n        function throwOnHydrationMismatch(fiber) {\n            throw new Error(\"Hydration failed because the initial UI does not match what was \" + \"rendered on the server.\");\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance) {\n                if (shouldClientRenderOnMismatch(fiber)) {\n                    warnNonhydratedInstance(hydrationParentFiber, fiber);\n                    throwOnHydrationMismatch();\n                } // Nothing to hydrate. Make it an insertion.\n                insertNonHydratedInstance(hydrationParentFiber, fiber);\n                isHydrating = false;\n                hydrationParentFiber = fiber;\n                return;\n            }\n            var firstAttemptedInstance = nextInstance;\n            if (!tryHydrate(fiber, nextInstance)) {\n                if (shouldClientRenderOnMismatch(fiber)) {\n                    warnNonhydratedInstance(hydrationParentFiber, fiber);\n                    throwOnHydrationMismatch();\n                } // If we can't hydrate this instance let's try the next one.\n                // We use this as a heuristic. It's based on intuition and not data so it\n                // might be flawed or unnecessary.\n                nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n                var prevHydrationParentFiber = hydrationParentFiber;\n                if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n                    // Nothing to hydrate. Make it an insertion.\n                    insertNonHydratedInstance(hydrationParentFiber, fiber);\n                    isHydrating = false;\n                    hydrationParentFiber = fiber;\n                    return;\n                } // We matched the next one, we'll now assume that the first one was\n                // superfluous and we'll delete it. Since we can't eagerly delete it\n                // we'll have to schedule a deletion. To do that, this node needs a dummy\n                // fiber associated with it.\n                deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n            }\n        }\n        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var instance = fiber.stateNode;\n            var shouldWarnIfMismatchDev = !didSuspend;\n            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n            fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n            // is a new ref we mark this as an update.\n            if (updatePayload !== null) {\n                return true;\n            }\n            return false;\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostTextInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var textInstance = fiber.stateNode;\n            var textContent = fiber.memoizedProps;\n            var shouldWarnIfMismatchDev = !didSuspend;\n            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n            if (shouldUpdate) {\n                // We assume that prepareToHydrateHostTextInstance is called in a context where the\n                // hydration parent is the parent host component of this host text.\n                var returnFiber = hydrationParentFiber;\n                if (returnFiber !== null) {\n                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                    switch(returnFiber.tag){\n                        case HostRoot:\n                            {\n                                var parentContainer = returnFiber.stateNode.containerInfo;\n                                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode);\n                                break;\n                            }\n                        case HostComponent:\n                            {\n                                var parentType = returnFiber.type;\n                                var parentProps = returnFiber.memoizedProps;\n                                var parentInstance = returnFiber.stateNode;\n                                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, isConcurrentMode);\n                                break;\n                            }\n                    }\n                }\n            }\n            return shouldUpdate;\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error(\"Expected to have a hydrated suspense instance. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error(\"Expected to have a hydrated suspense instance. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n            var parent = fiber.return;\n            while(parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent){\n                parent = parent.return;\n            }\n            hydrationParentFiber = parent;\n        }\n        function popHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            if (fiber !== hydrationParentFiber) {\n                // We're deeper than the current hydration context, inside an inserted\n                // tree.\n                return false;\n            }\n            if (!isHydrating) {\n                // If we're not currently hydrating but we're in a hydration context, then\n                // we were an insertion and now need to pop up reenter hydration of our\n                // siblings.\n                popToNextHostParent(fiber);\n                isHydrating = true;\n                return false;\n            } // If we have any remaining hydratable nodes, we need to delete them now.\n            // We only do this deeper than head and body since they tend to have random\n            // other nodes in them. We also ignore components with pure text content in\n            // side of them. We also don't delete anything inside the root container.\n            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n                var nextInstance = nextHydratableInstance;\n                if (nextInstance) {\n                    if (shouldClientRenderOnMismatch(fiber)) {\n                        warnIfUnhydratedTailNodes(fiber);\n                        throwOnHydrationMismatch();\n                    } else {\n                        while(nextInstance){\n                            deleteHydratableInstance(fiber, nextInstance);\n                            nextInstance = getNextHydratableSibling(nextInstance);\n                        }\n                    }\n                }\n            }\n            popToNextHostParent(fiber);\n            if (fiber.tag === SuspenseComponent) {\n                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n            } else {\n                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n            }\n            return true;\n        }\n        function hasUnhydratedTailNodes() {\n            return isHydrating && nextHydratableInstance !== null;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n            var nextInstance = nextHydratableInstance;\n            while(nextInstance){\n                warnUnhydratedInstance(fiber, nextInstance);\n                nextInstance = getNextHydratableSibling(nextInstance);\n            }\n        }\n        function resetHydrationState() {\n            if (!supportsHydration) {\n                return;\n            }\n            hydrationParentFiber = null;\n            nextHydratableInstance = null;\n            isHydrating = false;\n            didSuspend = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n            if (hydrationErrors !== null) {\n                // Successfully completed a forced client render. The errors that occurred\n                // during the hydration attempt are now recovered. We will log them in\n                // commit phase, once the entire tree has finished.\n                queueRecoverableErrors(hydrationErrors);\n                hydrationErrors = null;\n            }\n        }\n        function getIsHydrating() {\n            return isHydrating;\n        }\n        function queueHydrationError(error) {\n            if (hydrationErrors === null) {\n                hydrationErrors = [\n                    error\n                ];\n            } else {\n                hydrationErrors.push(error);\n            }\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var didWarnAboutStringRefs;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {};\n        {\n            didWarnAboutMaps = false;\n            didWarnAboutGenerators = false;\n            didWarnAboutStringRefs = {};\n            /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ ownerHasKeyUseWarning = {};\n            ownerHasFunctionTypeWarning = {};\n            warnForMissingKey = function(child, returnFiber) {\n                if (child === null || typeof child !== \"object\") {\n                    return;\n                }\n                if (!child._store || child._store.validated || child.key != null) {\n                    return;\n                }\n                if (typeof child._store !== \"object\") {\n                    throw new Error(\"React Component in warnForMissingKey should have a _store. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                child._store.validated = true;\n                var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                if (ownerHasKeyUseWarning[componentName]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[componentName] = true;\n                error(\"Each child in a list should have a unique \" + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + \"more information.\");\n            };\n        }\n        function coerceRef(returnFiber, current, element) {\n            var mixedRef = element.ref;\n            if (mixedRef !== null && typeof mixedRef !== \"function\" && typeof mixedRef !== \"object\") {\n                {\n                    // TODO: Clean this up once we turn on the string ref warning for\n                    // everyone, because the strict mode case will no longer be relevant\n                    if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n                    // because these cannot be automatically converted to an arrow function\n                    // using a codemod. Therefore, we don't have to warn about string refs again.\n                    !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n                        var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                        if (!didWarnAboutStringRefs[componentName]) {\n                            {\n                                error('A string ref, \"%s\", has been found within a strict mode tree. ' + \"String refs are a source of potential bugs and should be avoided. \" + \"We recommend using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", mixedRef);\n                            }\n                            didWarnAboutStringRefs[componentName] = true;\n                        }\n                    }\n                }\n                if (element._owner) {\n                    var owner = element._owner;\n                    var inst;\n                    if (owner) {\n                        var ownerFiber = owner;\n                        if (ownerFiber.tag !== ClassComponent) {\n                            throw new Error(\"Function components cannot have string refs. \" + \"We recommend using useRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\");\n                        }\n                        inst = ownerFiber.stateNode;\n                    }\n                    if (!inst) {\n                        throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n                    } // Assigning this to a const so Flow knows it won't change in the closure\n                    var resolvedInst = inst;\n                    {\n                        checkPropStringCoercion(mixedRef, \"ref\");\n                    }\n                    var stringRef = \"\" + mixedRef; // Check if previous string ref matches new string ref\n                    if (current !== null && current.ref !== null && typeof current.ref === \"function\" && current.ref._stringRef === stringRef) {\n                        return current.ref;\n                    }\n                    var ref = function(value) {\n                        var refs = resolvedInst.refs;\n                        if (refs === emptyRefsObject) {\n                            // This is a lazy pooled frozen object, so we need to initialize.\n                            refs = resolvedInst.refs = {};\n                        }\n                        if (value === null) {\n                            delete refs[stringRef];\n                        } else {\n                            refs[stringRef] = value;\n                        }\n                    };\n                    ref._stringRef = stringRef;\n                    return ref;\n                } else {\n                    if (typeof mixedRef !== \"string\") {\n                        throw new Error(\"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\");\n                    }\n                    if (!element._owner) {\n                        throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of\" + \" the following reasons:\\n\" + \"1. You may be adding a ref to a function component\\n\" + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + \"3. You have multiple copies of React loaded\\n\" + \"See https://reactjs.org/link/refs-must-have-owner for more information.\");\n                    }\n                }\n            }\n            return mixedRef;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n            var childString = Object.prototype.toString.call(newChild);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n        }\n        function warnOnFunctionType(returnFiber) {\n            {\n                var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                if (ownerHasFunctionTypeWarning[componentName]) {\n                    return;\n                }\n                ownerHasFunctionTypeWarning[componentName] = true;\n                error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n            }\n        }\n        function resolveLazy(lazyType) {\n            var payload = lazyType._payload;\n            var init = lazyType._init;\n            return init(payload);\n        } // This wrapper function exists because I expect to clone the code in each path\n        // to be able to optimize each path individually by branching early. This needs\n        // a compiler or we can do it manually. Helpers that don't need this branching\n        // live outside of this function.\n        function ChildReconciler(shouldTrackSideEffects) {\n            function deleteChild(returnFiber, childToDelete) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return;\n                }\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        childToDelete\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(childToDelete);\n                }\n            }\n            function deleteRemainingChildren(returnFiber, currentFirstChild) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return null;\n                } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n                // assuming that after the first child we've already added everything.\n                var childToDelete = currentFirstChild;\n                while(childToDelete !== null){\n                    deleteChild(returnFiber, childToDelete);\n                    childToDelete = childToDelete.sibling;\n                }\n                return null;\n            }\n            function mapRemainingChildren(returnFiber, currentFirstChild) {\n                // Add the remaining children to a temporary map so that we can find them by\n                // keys quickly. Implicit (null) keys get added to this set with their index\n                // instead.\n                var existingChildren = new Map();\n                var existingChild = currentFirstChild;\n                while(existingChild !== null){\n                    if (existingChild.key !== null) {\n                        existingChildren.set(existingChild.key, existingChild);\n                    } else {\n                        existingChildren.set(existingChild.index, existingChild);\n                    }\n                    existingChild = existingChild.sibling;\n                }\n                return existingChildren;\n            }\n            function useFiber(fiber, pendingProps) {\n                // We currently set sibling to null and index to 0 here because it is easy\n                // to forget to do before returning it. E.g. for the single child case.\n                var clone = createWorkInProgress(fiber, pendingProps);\n                clone.index = 0;\n                clone.sibling = null;\n                return clone;\n            }\n            function placeChild(newFiber, lastPlacedIndex, newIndex) {\n                newFiber.index = newIndex;\n                if (!shouldTrackSideEffects) {\n                    // During hydration, the useId algorithm needs to know which fibers are\n                    // part of a list of children (arrays, iterators).\n                    newFiber.flags |= Forked;\n                    return lastPlacedIndex;\n                }\n                var current = newFiber.alternate;\n                if (current !== null) {\n                    var oldIndex = current.index;\n                    if (oldIndex < lastPlacedIndex) {\n                        // This is a move.\n                        newFiber.flags |= Placement;\n                        return lastPlacedIndex;\n                    } else {\n                        // This item can stay in place.\n                        return oldIndex;\n                    }\n                } else {\n                    // This is an insertion.\n                    newFiber.flags |= Placement;\n                    return lastPlacedIndex;\n                }\n            }\n            function placeSingleChild(newFiber) {\n                // This is simpler for the single child case. We only need to do a\n                // placement for inserting new children.\n                if (shouldTrackSideEffects && newFiber.alternate === null) {\n                    newFiber.flags |= Placement;\n                }\n                return newFiber;\n            }\n            function updateTextNode(returnFiber, current, textContent, lanes) {\n                if (current === null || current.tag !== HostText) {\n                    // Insert\n                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function updateElement(returnFiber, current, element, lanes) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                    return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n                }\n                if (current !== null) {\n                    if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.\n                    // We need to do this after the Hot Reloading check above,\n                    // because hot reloading has different semantics than prod because\n                    // it doesn't resuspend. So we can't let the call below suspend.\n                    typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n                        // Move based on index\n                        var existing = useFiber(current, element.props);\n                        existing.ref = coerceRef(returnFiber, current, element);\n                        existing.return = returnFiber;\n                        {\n                            existing._debugSource = element._source;\n                            existing._debugOwner = element._owner;\n                        }\n                        return existing;\n                    }\n                } // Insert\n                var created = createFiberFromElement(element, returnFiber.mode, lanes);\n                created.ref = coerceRef(returnFiber, current, element);\n                created.return = returnFiber;\n                return created;\n            }\n            function updatePortal(returnFiber, current, portal, lanes) {\n                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n                    // Insert\n                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, portal.children || []);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function updateFragment(returnFiber, current, fragment, lanes, key) {\n                if (current === null || current.tag !== Fragment) {\n                    // Insert\n                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, fragment);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function createChild(returnFiber, newChild, lanes) {\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    var created = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                                _created.ref = coerceRef(returnFiber, null, newChild);\n                                _created.return = returnFiber;\n                                return _created;\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                                _created2.return = returnFiber;\n                                return _created2;\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                {\n                                    var payload = newChild._payload;\n                                    var init = newChild._init;\n                                    return createChild(returnFiber, init(payload), lanes);\n                                }\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                        _created3.return = returnFiber;\n                        return _created3;\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n                // Update the fiber if the keys match, otherwise return null.\n                var key = oldFiber !== null ? oldFiber.key : null;\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    if (key !== null) {\n                        return null;\n                    }\n                    return updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updateElement(returnFiber, oldFiber, newChild, lanes);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updatePortal(returnFiber, oldFiber, newChild, lanes);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                {\n                                    var payload = newChild._payload;\n                                    var init = newChild._init;\n                                    return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n                                }\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        if (key !== null) {\n                            return null;\n                        }\n                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys, so we neither have to check the old nor\n                    // new node for the key. If both are text nodes, they match.\n                    var matchedFiber = existingChildren.get(newIdx) || null;\n                    return updateTextNode(returnFiber, matchedFiber, \"\" + newChild, lanes);\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            /**\n   * Warns if there is a duplicate or missing key\n   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {\n                {\n                    if (typeof child !== \"object\" || child === null) {\n                        return knownKeys;\n                    }\n                    switch(child.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                        case REACT_PORTAL_TYPE:\n                            warnForMissingKey(child, returnFiber);\n                            var key = child.key;\n                            if (typeof key !== \"string\") {\n                                break;\n                            }\n                            if (knownKeys === null) {\n                                knownKeys = new Set();\n                                knownKeys.add(key);\n                                break;\n                            }\n                            if (!knownKeys.has(key)) {\n                                knownKeys.add(key);\n                                break;\n                            }\n                            error(\"Encountered two children with the same key, `%s`. \" + \"Keys should be unique so that components maintain their identity \" + \"across updates. Non-unique keys may cause children to be \" + \"duplicated and/or omitted — the behavior is unsupported and \" + \"could change in a future version.\", key);\n                            break;\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = child._payload;\n                                var init = child._init;\n                                warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                                break;\n                            }\n                    }\n                }\n                return knownKeys;\n            }\n            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n                // This algorithm can't optimize by searching from both ends since we\n                // don't have backpointers on fibers. I'm trying to see how far we can get\n                // with that model. If it ends up not being worth the tradeoffs, we can\n                // add it later.\n                // Even with a two ended optimization, we'd want to optimize for the case\n                // where there are few changes and brute force the comparison instead of\n                // going for the Map. It'd like to explore hitting that path first in\n                // forward-only mode and only go for the Map once we notice that we need\n                // lots of look ahead. This doesn't handle reversal as well as two ended\n                // search but that's unusual. Besides, for the two ended optimization to\n                // work on Iterables, we'd need to copy the whole set.\n                // In this first iteration, we'll just live with hitting the bad case\n                // (adding everything to a Map) in for every insert/move.\n                // If you change this code, also update reconcileChildrenIterator() which\n                // uses the same algorithm.\n                {\n                    // First, validate keys.\n                    var knownKeys = null;\n                    for(var i = 0; i < newChildren.length; i++){\n                        var child = newChildren[i];\n                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                    }\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (newIdx === newChildren.length) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; newIdx < newChildren.length; newIdx++){\n                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n                        if (_newFiber === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber;\n                        } else {\n                            previousNewFiber.sibling = _newFiber;\n                        }\n                        previousNewFiber = _newFiber;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; newIdx < newChildren.length; newIdx++){\n                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n                    if (_newFiber2 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber2.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber2;\n                        } else {\n                            previousNewFiber.sibling = _newFiber2;\n                        }\n                        previousNewFiber = _newFiber2;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks2 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks2);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n                // This is the same implementation as reconcileChildrenArray(),\n                // but using the iterator instead.\n                var iteratorFn = getIteratorFn(newChildrenIterable);\n                if (typeof iteratorFn !== \"function\") {\n                    throw new Error(\"An object is not an iterable. This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n                }\n                {\n                    // We don't support rendering Generators because it's a mutation.\n                    // See https://github.com/facebook/react/issues/12995\n                    if (typeof Symbol === \"function\" && // $FlowFixMe Flow doesn't know about toStringTag\n                    newChildrenIterable[Symbol.toStringTag] === \"Generator\") {\n                        if (!didWarnAboutGenerators) {\n                            error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                        }\n                        didWarnAboutGenerators = true;\n                    } // Warn about using Maps as children\n                    if (newChildrenIterable.entries === iteratorFn) {\n                        if (!didWarnAboutMaps) {\n                            error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                        }\n                        didWarnAboutMaps = true;\n                    } // First, validate keys.\n                    // We'll get a different iterator later for the main pass.\n                    var _newChildren = iteratorFn.call(newChildrenIterable);\n                    if (_newChildren) {\n                        var knownKeys = null;\n                        var _step = _newChildren.next();\n                        for(; !_step.done; _step = _newChildren.next()){\n                            var child = _step.value;\n                            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                        }\n                    }\n                }\n                var newChildren = iteratorFn.call(newChildrenIterable);\n                if (newChildren == null) {\n                    throw new Error(\"An iterable object provided no iterator.\");\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                var step = newChildren.next();\n                for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (step.done) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; !step.done; newIdx++, step = newChildren.next()){\n                        var _newFiber3 = createChild(returnFiber, step.value, lanes);\n                        if (_newFiber3 === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber3;\n                        } else {\n                            previousNewFiber.sibling = _newFiber3;\n                        }\n                        previousNewFiber = _newFiber3;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks3 = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks3);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; !step.done; newIdx++, step = newChildren.next()){\n                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n                    if (_newFiber4 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber4.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber4;\n                        } else {\n                            previousNewFiber.sibling = _newFiber4;\n                        }\n                        previousNewFiber = _newFiber4;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks4 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks4);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n                // There's no need to check for keys on text nodes since we don't have a\n                // way to define them.\n                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n                    // We already have an existing node so let's just update it and delete\n                    // the rest.\n                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                    var existing = useFiber(currentFirstChild, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                } // The existing first child is not a text node so we need to create one\n                // and delete the existing ones.\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            }\n            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n                var key = element.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        var elementType = element.type;\n                        if (elementType === REACT_FRAGMENT_TYPE) {\n                            if (child.tag === Fragment) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var existing = useFiber(child, element.props.children);\n                                existing.return = returnFiber;\n                                {\n                                    existing._debugSource = element._source;\n                                    existing._debugOwner = element._owner;\n                                }\n                                return existing;\n                            }\n                        } else {\n                            if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                            // We need to do this after the Hot Reloading check above,\n                            // because hot reloading has different semantics than prod because\n                            // it doesn't resuspend. So we can't let the call below suspend.\n                            typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var _existing = useFiber(child, element.props);\n                                _existing.ref = coerceRef(returnFiber, child, element);\n                                _existing.return = returnFiber;\n                                {\n                                    _existing._debugSource = element._source;\n                                    _existing._debugOwner = element._owner;\n                                }\n                                return _existing;\n                            }\n                        } // Didn't match.\n                        deleteRemainingChildren(returnFiber, child);\n                        break;\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                if (element.type === REACT_FRAGMENT_TYPE) {\n                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n                    _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n                    _created4.return = returnFiber;\n                    return _created4;\n                }\n            }\n            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n                var key = portal.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                            deleteRemainingChildren(returnFiber, child.sibling);\n                            var existing = useFiber(child, portal.children || []);\n                            existing.return = returnFiber;\n                            return existing;\n                        } else {\n                            deleteRemainingChildren(returnFiber, child);\n                            break;\n                        }\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            } // This API will tag the children with the side-effect of the reconciliation\n            // itself. They will be added to the side-effect list as we pass through the\n            // children and the parent.\n            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n                // This function is not recursive.\n                // If the top level item is an array, we treat it as a set of children,\n                // not as a fragment. Nested arrays on the other hand will be treated as\n                // fragment nodes. Recursion happens at the normal flow.\n                // Handle top level unkeyed fragments as if they were arrays.\n                // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n                // We treat the ambiguous cases above the same.\n                var isUnkeyedTopLevelFragment = typeof newChild === \"object\" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n                if (isUnkeyedTopLevelFragment) {\n                    newChild = newChild.props.children;\n                } // Handle object types\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_PORTAL_TYPE:\n                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n                                return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n                            }\n                    }\n                    if (isArray(newChild)) {\n                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n                    }\n                    if (getIteratorFn(newChild)) {\n                        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, \"\" + newChild, lanes));\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return deleteRemainingChildren(returnFiber, currentFirstChild);\n            }\n            return reconcileChildFibers;\n        }\n        var reconcileChildFibers = ChildReconciler(true);\n        var mountChildFibers = ChildReconciler(false);\n        function cloneChildFibers(current, workInProgress) {\n            if (current !== null && workInProgress.child !== current.child) {\n                throw new Error(\"Resuming work not yet implemented.\");\n            }\n            if (workInProgress.child === null) {\n                return;\n            }\n            var currentChild = workInProgress.child;\n            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n            workInProgress.child = newChild;\n            newChild.return = workInProgress;\n            while(currentChild.sibling !== null){\n                currentChild = currentChild.sibling;\n                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n                newChild.return = workInProgress;\n            }\n            newChild.sibling = null;\n        } // Reset a workInProgress child set to prepare it for a second pass.\n        function resetChildFibers(workInProgress, lanes) {\n            var child = workInProgress.child;\n            while(child !== null){\n                resetWorkInProgress(child, lanes);\n                child = child.sibling;\n            }\n        }\n        var NO_CONTEXT = {};\n        var contextStackCursor$1 = createCursor(NO_CONTEXT);\n        var contextFiberStackCursor = createCursor(NO_CONTEXT);\n        var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n        function requiredContext(c) {\n            if (c === NO_CONTEXT) {\n                throw new Error(\"Expected host context to exist. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n            }\n            return c;\n        }\n        function getRootHostContainer() {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n            // Push current root instance onto the stack;\n            // This allows us to reset root when portals are popped.\n            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n            // However, we can't just call getRootHostContext() and push it because\n            // we'd have a different number of entries on the stack depending on\n            // whether getRootHostContext() throws somewhere in renderer code or not.\n            // So we push an empty value first. This lets us safely unwind on errors.\n            push(contextStackCursor$1, NO_CONTEXT, fiber);\n            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n            pop(contextStackCursor$1, fiber);\n            push(contextStackCursor$1, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n            pop(contextStackCursor$1, fiber);\n            pop(contextFiberStackCursor, fiber);\n            pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n            var context = requiredContext(contextStackCursor$1.current);\n            return context;\n        }\n        function pushHostContext(fiber) {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            var context = requiredContext(contextStackCursor$1.current);\n            var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n            if (context === nextContext) {\n                return;\n            } // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber);\n            push(contextStackCursor$1, nextContext, fiber);\n        }\n        function popHostContext(fiber) {\n            // Do not pop unless this Fiber provided the current context.\n            // pushHostContext() only pushes Fibers that provide unique contexts.\n            if (contextFiberStackCursor.current !== fiber) {\n                return;\n            }\n            pop(contextStackCursor$1, fiber);\n            pop(contextFiberStackCursor, fiber);\n        }\n        var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is\n        // inherited deeply down the subtree. The upper bits only affect\n        // this immediate suspense boundary and gets reset each new\n        // boundary or suspense list.\n        var SubtreeSuspenseContextMask = 1; // Subtree Flags:\n        // InvisibleParentSuspenseContext indicates that one of our parent Suspense\n        // boundaries is not currently showing visible main content.\n        // Either because it is already showing a fallback or is not mounted at all.\n        // We can use this to determine if it is desirable to trigger a fallback at\n        // the parent. If not, then we might need to trigger undesirable boundaries\n        // and/or suspend the commit to avoid hiding the parent content.\n        var InvisibleParentSuspenseContext = 1; // Shallow Flags:\n        // ForceSuspenseFallback can be used by SuspenseList to force newly added\n        // items into their fallback state during one of the render passes.\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseContext(parentContext, flag) {\n            return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseContext(parentContext) {\n            return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseContext(parentContext, shallowContext) {\n            return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function addSubtreeSuspenseContext(parentContext, subtreeContext) {\n            return parentContext | subtreeContext;\n        }\n        function pushSuspenseContext(fiber, newContext) {\n            push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseContext(fiber) {\n            pop(suspenseStackCursor, fiber);\n        }\n        function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n            // If it was the primary children that just suspended, capture and render the\n            // fallback. Otherwise, don't capture and bubble to the next boundary.\n            var nextState = workInProgress.memoizedState;\n            if (nextState !== null) {\n                if (nextState.dehydrated !== null) {\n                    // A dehydrated boundary always captures.\n                    return true;\n                }\n                return false;\n            }\n            var props = workInProgress.memoizedProps; // Regular boundaries always capture.\n            {\n                return true;\n            }\n        }\n        function findFirstSuspended(row) {\n            var node = row;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        var dehydrated = state.dehydrated;\n                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                            return node;\n                        }\n                    }\n                } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n                // keep track of whether it suspended or not.\n                node.memoizedProps.revealOrder !== undefined) {\n                    var didSuspend = (node.flags & DidCapture) !== NoFlags;\n                    if (didSuspend) {\n                        return node;\n                    }\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === row) {\n                    return null;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === row) {\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n            return null;\n        }\n        var NoFlags$1 = /*   */ 0; // Represents whether effect should fire.\n        var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.\n        var Insertion = /*  */ 2;\n        var Layout = /*    */ 4;\n        var Passive$1 = /*   */ 8;\n        // and should be reset before starting a new render.\n        // This tracks which mutable sources need to be reset after a render.\n        var workInProgressSources = [];\n        function resetWorkInProgressVersions() {\n            for(var i = 0; i < workInProgressSources.length; i++){\n                var mutableSource = workInProgressSources[i];\n                if (isPrimaryRenderer) {\n                    mutableSource._workInProgressVersionPrimary = null;\n                } else {\n                    mutableSource._workInProgressVersionSecondary = null;\n                }\n            }\n            workInProgressSources.length = 0;\n        }\n        // This ensures that the version used for server rendering matches the one\n        // that is eventually read during hydration.\n        // If they don't match there's a potential tear and a full deopt render is required.\n        function registerMutableSourceForHydration(root, mutableSource) {\n            var getVersion = mutableSource._getVersion;\n            var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.\n            // Retaining it forever may interfere with GC.\n            if (root.mutableSourceEagerHydrationData == null) {\n                root.mutableSourceEagerHydrationData = [\n                    mutableSource,\n                    version\n                ];\n            } else {\n                root.mutableSourceEagerHydrationData.push(mutableSource, version);\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        {\n            didWarnAboutMismatchedHooksForComponent = new Set();\n        }\n        // These are set right before calling the component.\n        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n        // the work-in-progress hook.\n        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n        // current hook list is the list that belongs to the current fiber. The\n        // work-in-progress hook list is a new list that will be added to the\n        // work-in-progress fiber.\n        var currentHook = null;\n        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n        // does not get reset if we do another render pass; only when we're completely\n        // finished evaluating this component. This is an optimization so we know\n        // whether we need to clear render phase updates after a throw.\n        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n        // gets reset after each attempt.\n        // TODO: Maybe there's some way to consolidate this with\n        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n        var didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n        var localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n        // hydration). This counter is global, so client ids are not stable across\n        // render attempts.\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n        // The list stores the order of hooks used during the initial render (mount).\n        // Subsequent renders (updates) reference this list.\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n        // When true, such Hooks will always be \"remounted\". Only used during hot reload.\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev === null) {\n                    hookTypesDev = [\n                        hookName\n                    ];\n                } else {\n                    hookTypesDev.push(hookName);\n                }\n            }\n        }\n        function updateHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev !== null) {\n                    hookTypesUpdateIndexDev++;\n                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                        warnOnHookMismatchInDev(hookName);\n                    }\n                }\n            }\n        }\n        function checkDepsAreArrayDev(deps) {\n            {\n                if (deps !== undefined && deps !== null && !isArray(deps)) {\n                    // Verify deps, but only on mount to avoid extra checks.\n                    // It's unlikely their type would change as usually you define them inline.\n                    error(\"%s received a final argument that is not an array (instead, received `%s`). When \" + \"specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n                }\n            }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n                    didWarnAboutMismatchedHooksForComponent.add(componentName);\n                    if (hookTypesDev !== null) {\n                        var table = \"\";\n                        var secondColumnStart = 30;\n                        for(var i = 0; i <= hookTypesUpdateIndexDev; i++){\n                            var oldHookName = hookTypesDev[i];\n                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                            var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n                            // lol @ IE not supporting String#repeat\n                            while(row.length < secondColumnStart){\n                                row += \" \";\n                            }\n                            row += newHookName + \"\\n\";\n                            table += row;\n                        }\n                        error(\"React has detected a change in the order of Hooks called by %s. \" + \"This will lead to bugs and errors if not fixed. \" + \"For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n\" + \"   Previous render            Next render\\n\" + \"   ------------------------------------------------------\\n\" + \"%s\" + \"   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n                    }\n                }\n            }\n        }\n        function throwInvalidHookError() {\n            throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            {\n                if (ignorePreviousDependencies) {\n                    // Only true when this component is being hot reloaded.\n                    return false;\n                }\n            }\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n            renderLanes = nextRenderLanes;\n            currentlyRenderingFiber$1 = workInProgress;\n            {\n                hookTypesDev = current !== null ? current._debugHookTypes : null;\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n            }\n            workInProgress.memoizedState = null;\n            workInProgress.updateQueue = null;\n            workInProgress.lanes = NoLanes; // The following should have already been reset\n            // currentHook = null;\n            // workInProgressHook = null;\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // TODO Warn if no hooks are used at all during mount, then some are used during update.\n            // Currently we will identify the update render as a mount because memoizedState === null.\n            // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n            // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n            // so memoizedState would be null during updates and mounts.\n            {\n                if (current !== null && current.memoizedState !== null) {\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n                } else if (hookTypesDev !== null) {\n                    // This dispatcher handles an edge case where a component is updating,\n                    // but no stateful hooks have been used.\n                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n                    // This dispatcher does that.\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n                } else {\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n                }\n            }\n            var children = Component(props, secondArg); // Check if there was a render phase update\n            if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                // Keep rendering in a loop for as long as render phase updates continue to\n                // be scheduled. Use a counter to prevent infinite loops.\n                var numberOfReRenders = 0;\n                do {\n                    didScheduleRenderPhaseUpdateDuringThisPass = false;\n                    localIdCounter = 0;\n                    if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                        throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n                    }\n                    numberOfReRenders += 1;\n                    {\n                        // Even when hot reloading, allow dependencies to stabilize\n                        // after first render to prevent infinite render phase updates.\n                        ignorePreviousDependencies = false;\n                    }\n                    currentHook = null;\n                    workInProgressHook = null;\n                    workInProgress.updateQueue = null;\n                    {\n                        // Also validate hook order for cascading updates.\n                        hookTypesUpdateIndexDev = -1;\n                    }\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;\n                    children = Component(props, secondArg);\n                }while (didScheduleRenderPhaseUpdateDuringThisPass);\n            } // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n            {\n                workInProgress._debugHookTypes = hookTypesDev;\n            }\n            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                currentHookNameInDev = null;\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n                // render. If this fires, it suggests that we incorrectly reset the static\n                // flags in some other part of the codebase. This has happened before, for\n                // example, in the SuspenseList implementation.\n                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n                // and creates false positives. To make this work in legacy mode, we'd\n                // need to mark fibers that commit in an incomplete state, somehow. For\n                // now I'll disable the warning that most of the bugs that would trigger\n                // it are either exclusive to concurrent mode or exist in both.\n                (current.mode & ConcurrentMode) !== NoMode) {\n                    error(\"Internal React error: Expected static flag was missing. Please \" + \"notify the React team.\");\n                }\n            }\n            didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n            // localIdCounter = 0;\n            if (didRenderTooFewHooks) {\n                throw new Error(\"Rendered fewer hooks than expected. This may be caused by an accidental \" + \"early return statement.\");\n            }\n            return children;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every renderWithHooks call.\n            // Conceptually, it's part of the return value of renderWithHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            localIdCounter = 0;\n            return didRenderIdHook;\n        }\n        function bailoutHooks(current, workInProgress, lanes) {\n            workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n            // complete phase (bubbleProperties).\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n            } else {\n                workInProgress.flags &= ~(Passive | Update);\n            }\n            current.lanes = removeLanes(current.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n            // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n            if (didScheduleRenderPhaseUpdate) {\n                // There were render phase updates. These are only valid for this render\n                // phase, which we are now aborting. Remove the updates from the queues so\n                // they do not persist to the next render. Do not remove updates from hooks\n                // that weren't processed.\n                //\n                // Only reset the updates from the queue if it has a clone. If it does\n                // not have a clone, that means it wasn't processed, and the updates were\n                // scheduled before we entered the render phase.\n                var hook = currentlyRenderingFiber$1.memoizedState;\n                while(hook !== null){\n                    var queue = hook.queue;\n                    if (queue !== null) {\n                        queue.pending = null;\n                    }\n                    hook = hook.next;\n                }\n                didScheduleRenderPhaseUpdate = false;\n            }\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1;\n                currentHookNameInDev = null;\n                isUpdatingOpaqueValueInRenderPhase = false;\n            }\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\n            localIdCounter = 0;\n        }\n        function mountWorkInProgressHook() {\n            var hook = {\n                memoizedState: null,\n                baseState: null,\n                baseQueue: null,\n                queue: null,\n                next: null\n            };\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n            } else {\n                // Append to the end of the list\n                workInProgressHook = workInProgressHook.next = hook;\n            }\n            return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n            // This function is used both for updates and for re-renders triggered by a\n            // render phase update. It assumes there is either a current hook we can\n            // clone, or a work-in-progress hook from a previous render pass that we can\n            // use as a base. When we reach the end of the base list, we must switch to\n            // the dispatcher used for mounts.\n            var nextCurrentHook;\n            if (currentHook === null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    nextCurrentHook = current.memoizedState;\n                } else {\n                    nextCurrentHook = null;\n                }\n            } else {\n                nextCurrentHook = currentHook.next;\n            }\n            var nextWorkInProgressHook;\n            if (workInProgressHook === null) {\n                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n            } else {\n                nextWorkInProgressHook = workInProgressHook.next;\n            }\n            if (nextWorkInProgressHook !== null) {\n                // There's already a work-in-progress. Reuse it.\n                workInProgressHook = nextWorkInProgressHook;\n                nextWorkInProgressHook = workInProgressHook.next;\n                currentHook = nextCurrentHook;\n            } else {\n                // Clone from the current hook.\n                if (nextCurrentHook === null) {\n                    throw new Error(\"Rendered more hooks than during the previous render.\");\n                }\n                currentHook = nextCurrentHook;\n                var newHook = {\n                    memoizedState: currentHook.memoizedState,\n                    baseState: currentHook.baseState,\n                    baseQueue: currentHook.baseQueue,\n                    queue: currentHook.queue,\n                    next: null\n                };\n                if (workInProgressHook === null) {\n                    // This is the first hook in the list.\n                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n                } else {\n                    // Append to the end of the list.\n                    workInProgressHook = workInProgressHook.next = newHook;\n                }\n            }\n            return workInProgressHook;\n        }\n        function createFunctionComponentUpdateQueue() {\n            return {\n                lastEffect: null,\n                stores: null\n            };\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n            var hook = mountWorkInProgressHook();\n            var initialState;\n            if (init !== undefined) {\n                initialState = init(initialArg);\n            } else {\n                initialState = initialArg;\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                interleaved: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: reducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n            }\n            queue.lastRenderedReducer = reducer;\n            var current = currentHook; // The last rebase update that is NOT part of the base state.\n            var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n            var pendingQueue = queue.pending;\n            if (pendingQueue !== null) {\n                // We have new updates that haven't been processed yet.\n                // We'll add them to the base queue.\n                if (baseQueue !== null) {\n                    // Merge the pending queue and the base queue.\n                    var baseFirst = baseQueue.next;\n                    var pendingFirst = pendingQueue.next;\n                    baseQueue.next = pendingFirst;\n                    pendingQueue.next = baseFirst;\n                }\n                {\n                    if (current.baseQueue !== baseQueue) {\n                        // Internal invariant that should never happen, but feasibly could in\n                        // the future if we implement resuming, or some form of that.\n                        error(\"Internal error: Expected work-in-progress queue to be a clone. \" + \"This is a bug in React.\");\n                    }\n                }\n                current.baseQueue = baseQueue = pendingQueue;\n                queue.pending = null;\n            }\n            if (baseQueue !== null) {\n                // We have a queue to process.\n                var first = baseQueue.next;\n                var newState = current.baseState;\n                var newBaseState = null;\n                var newBaseQueueFirst = null;\n                var newBaseQueueLast = null;\n                var update = first;\n                do {\n                    var updateLane = update.lane;\n                    if (!isSubsetOfLanes(renderLanes, updateLane)) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            action: update.action,\n                            hasEagerState: update.hasEagerState,\n                            eagerState: update.eagerState,\n                            next: null\n                        };\n                        if (newBaseQueueLast === null) {\n                            newBaseQueueFirst = newBaseQueueLast = clone;\n                            newBaseState = newState;\n                        } else {\n                            newBaseQueueLast = newBaseQueueLast.next = clone;\n                        } // Update the remaining priority in the queue.\n                        // TODO: Don't need to accumulate this. Instead, we can remove\n                        // renderLanes from the original lanes.\n                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                        markSkippedUpdateLanes(updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        if (newBaseQueueLast !== null) {\n                            var _clone = {\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                action: update.action,\n                                hasEagerState: update.hasEagerState,\n                                eagerState: update.eagerState,\n                                next: null\n                            };\n                            newBaseQueueLast = newBaseQueueLast.next = _clone;\n                        } // Process this update.\n                        if (update.hasEagerState) {\n                            // If this update is a state update (not a reducer) and was processed eagerly,\n                            // we can use the eagerly computed state\n                            newState = update.eagerState;\n                        } else {\n                            var action = update.action;\n                            newState = reducer(newState, action);\n                        }\n                    }\n                    update = update.next;\n                }while (update !== null && update !== first);\n                if (newBaseQueueLast === null) {\n                    newBaseState = newState;\n                } else {\n                    newBaseQueueLast.next = newBaseQueueFirst;\n                } // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState;\n                hook.baseState = newBaseState;\n                hook.baseQueue = newBaseQueueLast;\n                queue.lastRenderedState = newState;\n            } // Interleaved updates are stored on a separate queue. We aren't going to\n            // process them during this render, but we do need to track which lanes\n            // are remaining.\n            var lastInterleaved = queue.interleaved;\n            if (lastInterleaved !== null) {\n                var interleaved = lastInterleaved;\n                do {\n                    var interleavedLane = interleaved.lane;\n                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n                    markSkippedUpdateLanes(interleavedLane);\n                    interleaved = interleaved.next;\n                }while (interleaved !== lastInterleaved);\n            } else if (baseQueue === null) {\n                // `queue.lanes` is used for entangling transitions. We can set it back to\n                // zero once the queue is empty.\n                queue.lanes = NoLanes;\n            }\n            var dispatch = queue.dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n            }\n            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n            // work-in-progress hook.\n            var dispatch = queue.dispatch;\n            var lastRenderPhaseUpdate = queue.pending;\n            var newState = hook.memoizedState;\n            if (lastRenderPhaseUpdate !== null) {\n                // The queue doesn't persist past this render pass.\n                queue.pending = null;\n                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                var update = firstRenderPhaseUpdate;\n                do {\n                    // Process this render phase update. We don't have to check the\n                    // priority because it will always be the same as the current\n                    // render's.\n                    var action = update.action;\n                    newState = reducer(newState, action);\n                    update = update.next;\n                }while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n                // the base state unless the queue is empty.\n                // TODO: Not sure if this is the desired semantics, but it's what we\n                // do for gDSFP. I can't remember why.\n                if (hook.baseQueue === null) {\n                    hook.baseState = newState;\n                }\n                queue.lastRenderedState = newState;\n            }\n            return [\n                newState,\n                dispatch\n            ];\n        }\n        function mountMutableSource(source, getSnapshot, subscribe) {\n            {\n                return undefined;\n            }\n        }\n        function updateMutableSource(source, getSnapshot, subscribe) {\n            {\n                return undefined;\n            }\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = mountWorkInProgressHook();\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                if (getServerSnapshot === undefined) {\n                    throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n                }\n                nextSnapshot = getServerSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        if (nextSnapshot !== getServerSnapshot()) {\n                            error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\");\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                //\n                // We won't do this if we're hydrating server-rendered content, because if\n                // the content is stale, it's already visible anyway. Instead we'll patch\n                // it up in a passive effect.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                }\n                if (!includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            } // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            hook.memoizedState = nextSnapshot;\n            var inst = {\n                value: nextSnapshot,\n                getSnapshot: getSnapshot\n            };\n            hook.queue = inst; // Schedule an effect to subscribe to the store.\n            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Schedule an effect to update the mutable instance fields. We will update\n            // this whenever subscribe, getSnapshot, or value changes. Because there's no\n            // clean-up function, and we track the deps correctly, we can call pushEffect\n            // directly, without storing any additional state. For the same reason, we\n            // don't need to set a static flag, either.\n            // TODO: We can move this to the passive phase once we add a pre-commit\n            // consistency check. See the next comment.\n            fiber.flags |= Passive;\n            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n            return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            var nextSnapshot = getSnapshot();\n            {\n                if (!didWarnUncachedGetSnapshot) {\n                    var cachedSnapshot = getSnapshot();\n                    if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                        error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                        didWarnUncachedGetSnapshot = true;\n                    }\n                }\n            }\n            var prevSnapshot = hook.memoizedState;\n            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n            if (snapshotChanged) {\n                hook.memoizedState = nextSnapshot;\n                markWorkInProgressReceivedUpdate();\n            }\n            var inst = hook.queue;\n            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Whenever getSnapshot or subscribe changes, we need to check in the\n            // commit phase if there was an interleaved mutation. In concurrent mode\n            // this can happen all the time, but even in synchronous mode, an earlier\n            // effect may have mutated the store.\n            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n            // checking whether we scheduled a subscription effect above.\n            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n                fiber.flags |= Passive;\n                pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                }\n                if (!includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            }\n            return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n            fiber.flags |= StoreConsistency;\n            var check = {\n                getSnapshot: getSnapshot,\n                value: renderedSnapshot\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.stores = [\n                    check\n                ];\n            } else {\n                var stores = componentUpdateQueue.stores;\n                if (stores === null) {\n                    componentUpdateQueue.stores = [\n                        check\n                    ];\n                } else {\n                    stores.push(check);\n                }\n            }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n            // These are updated in the passive phase\n            inst.value = nextSnapshot;\n            inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n            // have been in an event that fired before the passive effects, or it could\n            // have been in a layout effect. In that case, we would have used the old\n            // snapsho and getSnapshot values to bail out. We need to check one more time.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceStoreRerender(fiber);\n            }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n            var handleStoreChange = function() {\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceStoreRerender(fiber);\n                }\n            }; // Subscribe to the store and return a clean-up function.\n            return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function forceStoreRerender(fiber) {\n            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n        }\n        function mountState(initialState) {\n            var hook = mountWorkInProgressHook();\n            if (typeof initialState === \"function\") {\n                // $FlowFixMe: Flow doesn't like mixed types\n                initialState = initialState();\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                interleaved: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateState(initialState) {\n            return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n            return rerenderReducer(basicStateReducer);\n        }\n        function pushEffect(tag, create, destroy, deps) {\n            var effect = {\n                tag: tag,\n                create: create,\n                destroy: destroy,\n                deps: deps,\n                // Circular\n                next: null\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n                var lastEffect = componentUpdateQueue.lastEffect;\n                if (lastEffect === null) {\n                    componentUpdateQueue.lastEffect = effect.next = effect;\n                } else {\n                    var firstEffect = lastEffect.next;\n                    lastEffect.next = effect;\n                    effect.next = firstEffect;\n                    componentUpdateQueue.lastEffect = effect;\n                }\n            }\n            return effect;\n        }\n        function mountRef(initialValue) {\n            var hook = mountWorkInProgressHook();\n            {\n                var _ref2 = {\n                    current: initialValue\n                };\n                hook.memoizedState = _ref2;\n                return _ref2;\n            }\n        }\n        function updateRef(initialValue) {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var destroy = undefined;\n            if (currentHook !== null) {\n                var prevEffect = currentHook.memoizedState;\n                destroy = prevEffect.destroy;\n                if (nextDeps !== null) {\n                    var prevDeps = prevEffect.deps;\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n                        return;\n                    }\n                }\n            }\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n        }\n        function mountEffect(create, deps) {\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n            } else {\n                return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n            }\n        }\n        function updateEffect(create, deps) {\n            return updateEffectImpl(Passive, Passive$1, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n            return mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n            return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n            var fiberFlags = Update;\n            {\n                fiberFlags |= LayoutStatic;\n            }\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n            return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n            if (typeof ref === \"function\") {\n                var refCallback = ref;\n                var _inst = create();\n                refCallback(_inst);\n                return function() {\n                    refCallback(null);\n                };\n            } else if (ref !== null && ref !== undefined) {\n                var refObject = ref;\n                {\n                    if (!refObject.hasOwnProperty(\"current\")) {\n                        error(\"Expected useImperativeHandle() first argument to either be a \" + \"ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(refObject).join(\", \") + \"}\");\n                    }\n                }\n                var _inst2 = create();\n                refObject.current = _inst2;\n                return function() {\n                    refObject.current = null;\n                };\n            }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== \"function\") {\n                    error(\"Expected useImperativeHandle() second argument to be a function \" + \"that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            var fiberFlags = Update;\n            {\n                fiberFlags |= LayoutStatic;\n            }\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== \"function\") {\n                    error(\"Expected useImperativeHandle() second argument to be a function \" + \"that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        // The react-debug-hooks package injects its own implementation\n        // so that e.g. DevTools can display custom hook values.\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function updateCallback(callback, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (prevState !== null) {\n                if (nextDeps !== null) {\n                    var prevDeps = prevState[1];\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        return prevState[0];\n                    }\n                }\n            }\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var nextValue = nextCreate();\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (prevState !== null) {\n                // Assume these are defined. If they're not, areHookInputsEqual will warn.\n                if (nextDeps !== null) {\n                    var prevDeps = prevState[1];\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        return prevState[0];\n                    }\n                }\n            }\n            var nextValue = nextCreate();\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function mountDeferredValue(value) {\n            var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];\n            mountEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function updateDeferredValue(value) {\n            var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];\n            updateEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function rerenderDeferredValue(value) {\n            var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];\n            updateEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function startTransition(setPending, callback, options) {\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n            setPending(true);\n            var prevTransition = ReactCurrentBatchConfig$1.transition;\n            ReactCurrentBatchConfig$1.transition = {};\n            var currentTransition = ReactCurrentBatchConfig$1.transition;\n            {\n                ReactCurrentBatchConfig$1.transition._updatedFibers = new Set();\n            }\n            try {\n                setPending(false);\n                callback();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$1.transition = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        if (updatedFibersCount > 10) {\n                            warn(\"Detected a large number of updates inside startTransition. \" + \"If this is due to a subscription please re-write it to use React provided hooks. \" + \"Otherwise concurrent mode guarantees are off the table.\");\n                        }\n                        currentTransition._updatedFibers.clear();\n                    }\n                }\n            }\n        }\n        function mountTransition() {\n            var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1]; // The `start` method never changes.\n            var start = startTransition.bind(null, setPending);\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = start;\n            return [\n                isPending,\n                start\n            ];\n        }\n        function updateTransition() {\n            var _updateState2 = updateState(), isPending = _updateState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            return [\n                isPending,\n                start\n            ];\n        }\n        function rerenderTransition() {\n            var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            return [\n                isPending,\n                start\n            ];\n        }\n        var isUpdatingOpaqueValueInRenderPhase = false;\n        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n            {\n                return isUpdatingOpaqueValueInRenderPhase;\n            }\n        }\n        function mountId() {\n            var hook = mountWorkInProgressHook();\n            var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n            // should do this in Fiber, too? Deferring this decision for now because\n            // there's no other place to store the prefix except for an internal field on\n            // the public createRoot object, which the fiber tree does not currently have\n            // a reference to.\n            var identifierPrefix = root.identifierPrefix;\n            var id;\n            if (getIsHydrating()) {\n                var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n                id = \":\" + identifierPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n                // that represents the position of this useId hook among all the useId\n                // hooks for this fiber.\n                var localId = localIdCounter++;\n                if (localId > 0) {\n                    id += \"H\" + localId.toString(32);\n                }\n                id += \":\";\n            } else {\n                // Use a lowercase r prefix for client-generated ids.\n                var globalClientId = globalClientIdCounter++;\n                id = \":\" + identifierPrefix + \"r\" + globalClientId.toString(32) + \":\";\n            }\n            hook.memoizedState = id;\n            return id;\n        }\n        function updateId() {\n            var hook = updateWorkInProgressHook();\n            var id = hook.memoizedState;\n            return id;\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === \"function\") {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + \"second callback argument. To execute a side effect after \" + \"rendering, declare it in the component body with useEffect().\");\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                enqueueUpdate$1(fiber, queue, update);\n                var eventTime = requestEventTime();\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === \"function\") {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + \"second callback argument. To execute a side effect after \" + \"rendering, declare it in the component body with useEffect().\");\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                enqueueUpdate$1(fiber, queue, update);\n                var alternate = fiber.alternate;\n                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    var lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        var prevDispatcher;\n                        {\n                            prevDispatcher = ReactCurrentDispatcher$1.current;\n                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                        }\n                        try {\n                            var currentState = queue.lastRenderedState;\n                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.hasEagerState = true;\n                            update.eagerState = eagerState;\n                            if (objectIs(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                return;\n                            }\n                        } catch (error) {} finally{\n                            {\n                                ReactCurrentDispatcher$1.current = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n                var eventTime = requestEventTime();\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n            var alternate = fiber.alternate;\n            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n            var pending = queue.pending;\n            if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n            } else {\n                update.next = pending.next;\n                pending.next = update;\n            }\n            queue.pending = update;\n        }\n        function enqueueUpdate$1(fiber, queue, update, lane) {\n            if (isInterleavedUpdate(fiber)) {\n                var interleaved = queue.interleaved;\n                if (interleaved === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update; // At the end of the current render, this queue's interleaved updates will\n                    // be transferred to the pending queue.\n                    pushInterleavedQueue(queue);\n                } else {\n                    update.next = interleaved.next;\n                    interleaved.next = update;\n                }\n                queue.interleaved = update;\n            } else {\n                var pending = queue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                queue.pending = update;\n            }\n        }\n        function entangleTransitionUpdate(root, queue, lane) {\n            if (isTransitionLane(lane)) {\n                var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n                // must have finished. We can remove them from the shared queue, which\n                // represents a superset of the actually pending lanes. In some cases we\n                // may entangle more than we need to, but that's OK. In fact it's worse if\n                // we *don't* entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n            {\n                markStateUpdateScheduled(fiber, lane);\n            }\n        }\n        var ContextOnlyDispatcher = {\n            readContext: readContext,\n            useCallback: throwInvalidHookError,\n            useContext: throwInvalidHookError,\n            useEffect: throwInvalidHookError,\n            useImperativeHandle: throwInvalidHookError,\n            useInsertionEffect: throwInvalidHookError,\n            useLayoutEffect: throwInvalidHookError,\n            useMemo: throwInvalidHookError,\n            useReducer: throwInvalidHookError,\n            useRef: throwInvalidHookError,\n            useState: throwInvalidHookError,\n            useDebugValue: throwInvalidHookError,\n            useDeferredValue: throwInvalidHookError,\n            useTransition: throwInvalidHookError,\n            useMutableSource: throwInvalidHookError,\n            useSyncExternalStore: throwInvalidHookError,\n            useId: throwInvalidHookError,\n            unstable_isNewReconciler: enableNewReconciler\n        };\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n            var warnInvalidContextAccess = function() {\n                error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n            };\n            var warnInvalidHookAccess = function() {\n                error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n            };\n            HooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    mountHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    mountHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    mountHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnMountWithHookTypesInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return updateDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n        }\n        var now$2 = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        /**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */ var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n            return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n            {\n                nestedUpdateScheduled = true;\n            }\n        }\n        function resetNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = false;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function syncNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = nestedUpdateScheduled;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function getCommitTime() {\n            return commitTime;\n        }\n        function recordCommitTime() {\n            commitTime = now$2();\n        }\n        function startProfilerTimer(fiber) {\n            profilerStartTime = now$2();\n            if (fiber.actualStartTime < 0) {\n                fiber.actualStartTime = now$2();\n            }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n            profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n            if (profilerStartTime >= 0) {\n                var elapsedTime = now$2() - profilerStartTime;\n                fiber.actualDuration += elapsedTime;\n                if (overrideBaseTime) {\n                    fiber.selfBaseDuration = elapsedTime;\n                }\n                profilerStartTime = -1;\n            }\n        }\n        function recordLayoutEffectDuration(fiber) {\n            if (layoutEffectStartTime >= 0) {\n                var elapsedTime = now$2() - layoutEffectStartTime;\n                layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            root.effectDuration += elapsedTime;\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            parentStateNode.effectDuration += elapsedTime;\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function recordPassiveEffectDuration(fiber) {\n            if (passiveEffectStartTime >= 0) {\n                var elapsedTime = now$2() - passiveEffectStartTime;\n                passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            if (root !== null) {\n                                root.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            if (parentStateNode !== null) {\n                                // Detached fibers have their state node cleared out.\n                                // In this case, the return pointer is also cleared out,\n                                // so we won't be able to report the time spent in this Profiler's subtree.\n                                parentStateNode.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function startLayoutEffectTimer() {\n            layoutEffectStartTime = now$2();\n        }\n        function startPassiveEffectTimer() {\n            passiveEffectStartTime = now$2();\n        }\n        function transferActualDuration(fiber) {\n            // Transfer time spent rendering these children so we don't lose it\n            // after we rerender. This is used as a helper in special cases\n            // where we should count the work of multiple passes.\n            var child = fiber.child;\n            while(child){\n                fiber.actualDuration += child.actualDuration;\n                child = child.sibling;\n            }\n        }\n        function createCapturedValue(value, source) {\n            // If the value is an error, call this function immediately after it is thrown\n            // so the stack is accurate.\n            return {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n        }\n        // This module is forked in different environments.\n        // By default, return `true` to log errors to the console.\n        // Forks can return `false` if this isn't desirable.\n        function showErrorDialog(boundary, errorInfo) {\n            return true;\n        }\n        function logCapturedError(boundary, errorInfo) {\n            try {\n                var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.\n                // This enables renderers like ReactNative to better manage redbox behavior.\n                if (logError === false) {\n                    return;\n                }\n                var error = errorInfo.value;\n                if (true) {\n                    var source = errorInfo.source;\n                    var stack = errorInfo.stack;\n                    var componentStack = stack !== null ? stack : \"\"; // Browsers support silencing uncaught errors by calling\n                    // `preventDefault()` in window `error` handler.\n                    // We record this information as an expando on the error.\n                    if (error != null && error._suppressLogging) {\n                        if (boundary.tag === ClassComponent) {\n                            // The error is recoverable and was silenced.\n                            // Ignore it and don't print the stack addendum.\n                            // This is handy for testing error boundaries without noise.\n                            return;\n                        } // The error is fatal. Since the silencing might have\n                        // been accidental, we'll surface it anyway.\n                        // However, the browser would have silenced the original error\n                        // so we'll print it first, and then print the stack addendum.\n                        console[\"error\"](error); // Don't transform to our wrapper\n                    // For a more detailed description of this block, see:\n                    // https://github.com/facebook/react/pull/13384\n                    }\n                    var componentName = source ? getComponentNameFromFiber(source) : null;\n                    var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : \"The above error occurred in one of your React components:\";\n                    var errorBoundaryMessage;\n                    if (boundary.tag === HostRoot) {\n                        errorBoundaryMessage = \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" + \"Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.\";\n                    } else {\n                        var errorBoundaryName = getComponentNameFromFiber(boundary) || \"Anonymous\";\n                        errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n                    }\n                    var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n                    // We don't include the original error message and JS stack because the browser\n                    // has already printed it. Even if the application swallows the error, it is still\n                    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n                    console[\"error\"](combinedMessage); // Don't transform to our wrapper\n                } else {}\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        var PossiblyWeakMap$1 = typeof WeakMap === \"function\" ? WeakMap : Map;\n        function createRootErrorUpdate(fiber, errorInfo, lane) {\n            var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n            update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: null\n            };\n            var error = errorInfo.value;\n            update.callback = function() {\n                onUncaughtError(error);\n                logCapturedError(fiber, errorInfo);\n            };\n            return update;\n        }\n        function createClassErrorUpdate(fiber, errorInfo, lane) {\n            var update = createUpdate(NoTimestamp, lane);\n            update.tag = CaptureUpdate;\n            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n            if (typeof getDerivedStateFromError === \"function\") {\n                var error$1 = errorInfo.value;\n                update.payload = function() {\n                    return getDerivedStateFromError(error$1);\n                };\n                update.callback = function() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    logCapturedError(fiber, errorInfo);\n                };\n            }\n            var inst = fiber.stateNode;\n            if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n                update.callback = function callback() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    logCapturedError(fiber, errorInfo);\n                    if (typeof getDerivedStateFromError !== \"function\") {\n                        // To preserve the preexisting retry behavior of error boundaries,\n                        // we keep track of which ones already failed during this batch.\n                        // This gets reset before we yield back to the browser.\n                        // TODO: Warn in strict mode if getDerivedStateFromError is\n                        // not defined.\n                        markLegacyErrorBoundaryAsFailed(this);\n                    }\n                    var error$1 = errorInfo.value;\n                    var stack = errorInfo.stack;\n                    this.componentDidCatch(error$1, {\n                        componentStack: stack !== null ? stack : \"\"\n                    });\n                    {\n                        if (typeof getDerivedStateFromError !== \"function\") {\n                            // If componentDidCatch is the only error boundary method defined,\n                            // then it needs to call setState to recover from errors.\n                            // If no state update is scheduled then the boundary will swallow the error.\n                            if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                                error(\"%s: Error boundaries should implement getDerivedStateFromError(). \" + \"In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n                            }\n                        }\n                    }\n                };\n            }\n            return update;\n        }\n        function attachPingListener(root, wakeable, lanes) {\n            // Attach a ping listener\n            //\n            // The data might resolve before we have a chance to commit the fallback. Or,\n            // in the case of a refresh, we'll never commit a fallback. So we need to\n            // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n            // try rendering the tree again.\n            //\n            // Only attach a listener if one does not already exist for the lanes\n            // we're currently rendering (which acts like a \"thread ID\" here).\n            //\n            // We only need to do this in concurrent mode. Legacy Suspense always\n            // commits fallbacks synchronously, so there are no pings.\n            var pingCache = root.pingCache;\n            var threadIDs;\n            if (pingCache === null) {\n                pingCache = root.pingCache = new PossiblyWeakMap$1();\n                threadIDs = new Set();\n                pingCache.set(wakeable, threadIDs);\n            } else {\n                threadIDs = pingCache.get(wakeable);\n                if (threadIDs === undefined) {\n                    threadIDs = new Set();\n                    pingCache.set(wakeable, threadIDs);\n                }\n            }\n            if (!threadIDs.has(lanes)) {\n                // Memoize using the thread ID to prevent redundant listeners.\n                threadIDs.add(lanes);\n                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n                {\n                    if (isDevToolsPresent) {\n                        // If we have pending work still, restore the original updaters\n                        restorePendingUpdaters(root, lanes);\n                    }\n                }\n                wakeable.then(ping, ping);\n            }\n        }\n        function attachRetryListener(suspenseBoundary, root, wakeable, lanes) {\n            // Retry listener\n            //\n            // If the fallback does commit, we need to attach a different type of\n            // listener. This one schedules an update on the Suspense boundary to turn\n            // the fallback state off.\n            //\n            // Stash the wakeable on the boundary fiber so we can access it in the\n            // commit phase.\n            //\n            // When the wakeable resolves, we'll attempt to render the boundary\n            // again (\"retry\").\n            var wakeables = suspenseBoundary.updateQueue;\n            if (wakeables === null) {\n                var updateQueue = new Set();\n                updateQueue.add(wakeable);\n                suspenseBoundary.updateQueue = updateQueue;\n            } else {\n                wakeables.add(wakeable);\n            }\n        }\n        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n            // A legacy mode Suspense quirk, only relevant to hook components.\n            var tag = sourceFiber.tag;\n            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n                var currentSource = sourceFiber.alternate;\n                if (currentSource) {\n                    sourceFiber.updateQueue = currentSource.updateQueue;\n                    sourceFiber.memoizedState = currentSource.memoizedState;\n                    sourceFiber.lanes = currentSource.lanes;\n                } else {\n                    sourceFiber.updateQueue = null;\n                    sourceFiber.memoizedState = null;\n                }\n            }\n        }\n        function getNearestSuspenseBoundaryToCapture(returnFiber) {\n            var node = returnFiber;\n            do {\n                if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n                    return node;\n                } // This boundary already captured during this render. Continue to the next\n                // boundary.\n                node = node.return;\n            }while (node !== null);\n            return null;\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n            // This marks a Suspense boundary so that when we're unwinding the stack,\n            // it captures the suspended \"exception\" and does a second (fallback) pass.\n            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n                // Legacy Mode Suspense\n                //\n                // If the boundary is in legacy mode, we should *not*\n                // suspend the commit. Pretend as if the suspended component rendered\n                // null and keep rendering. When the Suspense boundary completes,\n                // we'll do a second pass to render the fallback.\n                if (suspenseBoundary === returnFiber) {\n                    // Special case where we suspended while reconciling the children of\n                    // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n                    // when a React.lazy component is a direct child of a\n                    // Suspense boundary.\n                    //\n                    // Suspense boundaries are implemented as multiple fibers, but they\n                    // are a single conceptual unit. The legacy mode behavior where we\n                    // pretend the suspended fiber committed as `null` won't work,\n                    // because in this case the \"suspended\" fiber is the inner\n                    // Offscreen wrapper.\n                    //\n                    // Because the contents of the boundary haven't started rendering\n                    // yet (i.e. nothing in the tree has partially rendered) we can\n                    // switch to the regular, concurrent mode behavior: mark the\n                    // boundary with ShouldCapture and enter the unwind phase.\n                    suspenseBoundary.flags |= ShouldCapture;\n                } else {\n                    suspenseBoundary.flags |= DidCapture;\n                    sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n                    // But we shouldn't call any lifecycle methods or callbacks. Remove\n                    // all lifecycle effect tags.\n                    sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n                    if (supportsPersistence && enablePersistentOffscreenHostContainer) {\n                        // Another legacy Suspense quirk. In persistent mode, if this is the\n                        // initial mount, override the props of the host container to hide\n                        // its contents.\n                        var currentSuspenseBoundary = suspenseBoundary.alternate;\n                        if (currentSuspenseBoundary === null) {\n                            var offscreenFiber = suspenseBoundary.child;\n                            var offscreenContainer = offscreenFiber.child;\n                            if (offscreenContainer !== null) {\n                                var children = offscreenContainer.memoizedProps.children;\n                                var containerProps = getOffscreenContainerProps(\"hidden\", children);\n                                offscreenContainer.pendingProps = containerProps;\n                                offscreenContainer.memoizedProps = containerProps;\n                            }\n                        }\n                    }\n                    if (sourceFiber.tag === ClassComponent) {\n                        var currentSourceFiber = sourceFiber.alternate;\n                        if (currentSourceFiber === null) {\n                            // This is a new mount. Change the tag so it's not mistaken for a\n                            // completed class component. For example, we should not call\n                            // componentWillUnmount if it is deleted.\n                            sourceFiber.tag = IncompleteClassComponent;\n                        } else {\n                            // When we try rendering again, we should not reuse the current fiber,\n                            // since it's known to be in an inconsistent state. Use a force update to\n                            // prevent a bail out.\n                            var update = createUpdate(NoTimestamp, SyncLane);\n                            update.tag = ForceUpdate;\n                            enqueueUpdate(sourceFiber, update);\n                        }\n                    } // The source fiber did not complete. Mark it with Sync priority to\n                    // indicate that it still has pending work.\n                    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n                }\n                return suspenseBoundary;\n            } // Confirmed that the boundary is in a concurrent mode tree. Continue\n            // with the normal suspend path.\n            //\n            // After this we'll use a set of heuristics to determine whether this\n            // render pass will run to completion or restart or \"suspend\" the commit.\n            // The actual logic for this is spread out in different places.\n            //\n            // This first principle is that if we're going to suspend when we complete\n            // a root, then we should also restart if we get an update or ping that\n            // might unsuspend it, and vice versa. The only reason to suspend is\n            // because you think you might want to restart before committing. However,\n            // it doesn't make sense to restart only while in the period we're suspended.\n            //\n            // Restarting too aggressively is also not good because it starves out any\n            // intermediate loading state. So we use heuristics to determine when.\n            // Suspense Heuristics\n            //\n            // If nothing threw a Promise or all the same fallbacks are already showing,\n            // then don't suspend/restart.\n            //\n            // If this is an initial render of a new tree of Suspense boundaries and\n            // those trigger a fallback, then don't suspend/restart. We want to ensure\n            // that we can show the initial loading state as quickly as possible.\n            //\n            // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n            // a fallback, then we should always suspend/restart. Transitions apply\n            // to this case. If none is defined, JND is used instead.\n            //\n            // If we're already showing a fallback and it gets \"retried\", allowing us to show\n            // another level, but there's still an inner boundary that would show a fallback,\n            // then we suspend/restart for 500ms since the last time we showed a fallback\n            // anywhere in the tree. This effectively throttles progressive loading into a\n            // consistent train of commits. This also gives us an opportunity to restart to\n            // get to the completed state slightly earlier.\n            //\n            // If there's ambiguity due to batching it's resolved in preference of:\n            // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n            //\n            // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n            // ensure that new initial loading states can commit as soon as possible.\n            suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n            // the begin phase to prevent an early bailout.\n            suspenseBoundary.lanes = rootRenderLanes;\n            return suspenseBoundary;\n        }\n        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n            // The source fiber did not complete.\n            sourceFiber.flags |= Incomplete;\n            {\n                if (isDevToolsPresent) {\n                    // If we have pending work still, restore the original updaters\n                    restorePendingUpdaters(root, rootRenderLanes);\n                }\n            }\n            if (value !== null && typeof value === \"object\" && typeof value.then === \"function\") {\n                // This is a wakeable. The component suspended.\n                var wakeable = value;\n                resetSuspendedComponent(sourceFiber);\n                var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n                if (suspenseBoundary !== null) {\n                    suspenseBoundary.flags &= ~ForceClientRender;\n                    markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always\n                    // commits fallbacks synchronously, so there are no pings.\n                    if (suspenseBoundary.mode & ConcurrentMode) {\n                        attachPingListener(root, wakeable, rootRenderLanes);\n                    }\n                    attachRetryListener(suspenseBoundary, root, wakeable);\n                    return;\n                } else {\n                    // No boundary was found. Unless this is a sync update, this is OK.\n                    // We can suspend and wait for more data to arrive.\n                    if (!includesSyncLane(rootRenderLanes)) {\n                        // This is not a sync update. Suspend. Since we're not activating a\n                        // Suspense boundary, this will unwind all the way to the root without\n                        // performing a second pass to render a fallback. (This is arguably how\n                        // refresh transitions should work, too, since we're not going to commit\n                        // the fallbacks anyway.)\n                        //\n                        // This case also applies to initial hydration.\n                        attachPingListener(root, wakeable, rootRenderLanes);\n                        renderDidSuspendDelayIfPossible();\n                        return;\n                    } // This is a sync/discrete update. We treat this case like an error\n                    // because discrete renders are expected to produce a complete tree\n                    // synchronously to maintain consistency with external state.\n                    var uncaughtSuspenseError = new Error(\"A component suspended while responding to synchronous input. This \" + \"will cause the UI to be replaced with a loading indicator. To \" + \"fix, updates that suspend should be wrapped \" + \"with startTransition.\"); // If we're outside a transition, fall through to the regular error path.\n                    // The error will be caught by the nearest suspense boundary.\n                    value = uncaughtSuspenseError;\n                }\n            } else {\n                // This is a regular error, not a Suspense wakeable.\n                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n                    markDidSuspendWhileHydratingDEV();\n                    var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n                    // discarding the dehydrated content and switching to a client render.\n                    // Instead of surfacing the error, find the nearest Suspense boundary\n                    // and render it again without hydration.\n                    if (_suspenseBoundary !== null) {\n                        if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n                            // Set a flag to indicate that we should try rendering the normal\n                            // children again, not the fallback.\n                            _suspenseBoundary.flags |= ForceClientRender;\n                        }\n                        markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n                        // still log it so it can be fixed.\n                        queueHydrationError(value);\n                        return;\n                    }\n                }\n            } // We didn't find a boundary that could handle this type of exception. Start\n            // over and traverse parent path again, this time treating the exception\n            // as an error.\n            renderDidError(value);\n            value = createCapturedValue(value, sourceFiber);\n            var workInProgress = returnFiber;\n            do {\n                switch(workInProgress.tag){\n                    case HostRoot:\n                        {\n                            var _errorInfo = value;\n                            workInProgress.flags |= ShouldCapture;\n                            var lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n                            var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);\n                            enqueueCapturedUpdate(workInProgress, update);\n                            return;\n                        }\n                    case ClassComponent:\n                        // Capture and retry\n                        var errorInfo = value;\n                        var ctor = workInProgress.type;\n                        var instance = workInProgress.stateNode;\n                        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === \"function\" || instance !== null && typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state\n                            var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);\n                            enqueueCapturedUpdate(workInProgress, _update);\n                            return;\n                        }\n                        break;\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress !== null);\n        }\n        function getSuspendedCache() {\n            {\n                return null;\n            }\n        }\n        function markUpdate(workInProgress) {\n            // Tag the fiber with an update effect. This turns a Placement into\n            // a PlacementAndUpdate.\n            workInProgress.flags |= Update;\n        }\n        function markRef(workInProgress) {\n            workInProgress.flags |= Ref;\n            {\n                workInProgress.flags |= RefStatic;\n            }\n        }\n        function hadNoMutationsEffects(current, completedWork) {\n            var didBailout = current !== null && current.child === completedWork.child;\n            if (didBailout) {\n                return true;\n            }\n            if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n                return false;\n            } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n            // then we only have to check the `completedWork.subtreeFlags`.\n            var child = completedWork.child;\n            while(child !== null){\n                if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n                    return false;\n                }\n                child = child.sibling;\n            }\n            return true;\n        }\n        var appendAllChildren;\n        var updateHostContainer;\n        var updateHostComponent;\n        var updateHostText;\n        if (supportsMutation) {\n            // Mutation mode\n            appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent || node.tag === HostText) {\n                        appendInitialChild(parent, node.stateNode);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            };\n            updateHostContainer = function(current, workInProgress) {};\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps;\n                if (oldProps === newProps) {\n                    // In mutation mode, this is sufficient for a bailout because\n                    // we won't touch this node even if children changed.\n                    return;\n                } // If we get updated because one of our children updated, we don't\n                // have newProps so we'll have to reuse them.\n                // TODO: Split the update API as separate for the props vs. children.\n                // Even better would be if children weren't special cased at all tho.\n                var instance = workInProgress.stateNode;\n                var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n                // component is hitting the resume path. Figure out why. Possibly\n                // related to `hidden`.\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n                workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n                // is a new ref we mark this as an update. All the work is done in commitWork.\n                if (updatePayload) {\n                    markUpdate(workInProgress);\n                }\n            };\n            updateHostText = function(current, workInProgress, oldText, newText) {\n                // If the text differs, mark it as an update. All the work in done in commitWork.\n                if (oldText !== newText) {\n                    markUpdate(workInProgress);\n                }\n            };\n        } else if (supportsPersistence) {\n            // Persistent host tree mode\n            appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    // eslint-disable-next-line no-labels\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props, node);\n                        }\n                        appendInitialChild(parent, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance = cloneHiddenTextInstance(_instance, text, node);\n                        }\n                        appendInitialChild(parent, _instance);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        }\n                        {\n                            appendAllChildren(parent, node, true, true);\n                        }\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n            var appendAllChildrenToContainer = function(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    // eslint-disable-next-line no-labels\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props, node);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance2 = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance2 = cloneHiddenTextInstance(_instance2, text, node);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, _instance2);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        }\n                        {\n                            appendAllChildrenToContainer(containerChildSet, node, true, true);\n                        }\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            };\n            updateHostContainer = function(current, workInProgress) {\n                var portalOrRoot = workInProgress.stateNode;\n                var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n                if (childrenUnchanged) ;\n                else {\n                    var container = portalOrRoot.containerInfo;\n                    var newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n                    portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n                    markUpdate(workInProgress);\n                    finalizeContainerChildren(container, newChildSet);\n                }\n            };\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {\n                var currentInstance = current.stateNode;\n                var oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n                // This guarantees that we can reuse all of them.\n                var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n                if (childrenUnchanged && oldProps === newProps) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var recyclableInstance = workInProgress.stateNode;\n                var currentHostContext = getHostContext();\n                var updatePayload = null;\n                if (oldProps !== newProps) {\n                    updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n                }\n                if (childrenUnchanged && updatePayload === null) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n                if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n                    markUpdate(workInProgress);\n                }\n                workInProgress.stateNode = newInstance;\n                if (childrenUnchanged) {\n                    // If there are no other effects in this tree, we need to flag this node as having one.\n                    // Even though we're not going to use it for anything.\n                    // Otherwise parents won't know that there are new children to propagate upwards.\n                    markUpdate(workInProgress);\n                } else {\n                    // If children might have changed, we have to add them all to the set.\n                    appendAllChildren(newInstance, workInProgress, false, false);\n                }\n            };\n            updateHostText = function(current, workInProgress, oldText, newText) {\n                if (oldText !== newText) {\n                    // If the text content differs, we'll create a new text instance for it.\n                    var rootContainerInstance = getRootHostContainer();\n                    var currentHostContext = getHostContext();\n                    workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n                    // This lets the parents know that at least one of their children has changed.\n                    markUpdate(workInProgress);\n                } else {\n                    workInProgress.stateNode = current.stateNode;\n                }\n            };\n        } else {\n            // No host operations\n            updateHostContainer = function(current, workInProgress) {};\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {};\n            updateHostText = function(current, workInProgress, oldText, newText) {};\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n            if (getIsHydrating()) {\n                // If we're hydrating, we should consume as many items as we can\n                // so we don't leave any behind.\n                return;\n            }\n            switch(renderState.tailMode){\n                case \"hidden\":\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var tailNode = renderState.tail;\n                        var lastTailNode = null;\n                        while(tailNode !== null){\n                            if (tailNode.alternate !== null) {\n                                lastTailNode = tailNode;\n                            }\n                            tailNode = tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            renderState.tail = null;\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n                case \"collapsed\":\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var _tailNode = renderState.tail;\n                        var _lastTailNode = null;\n                        while(_tailNode !== null){\n                            if (_tailNode.alternate !== null) {\n                                _lastTailNode = _tailNode;\n                            }\n                            _tailNode = _tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (_lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            if (!hasRenderedATailFallback && renderState.tail !== null) {\n                                // We suspended during the head. We want to show at least one\n                                // row at the tail. So we'll keep on and cut off the rest.\n                                renderState.tail.sibling = null;\n                            } else {\n                                renderState.tail = null;\n                            }\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            _lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n            }\n        }\n        function bubbleProperties(completedWork) {\n            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n            var newChildLanes = NoLanes;\n            var subtreeFlags = NoFlags;\n            if (!didBailout) {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var actualDuration = completedWork.actualDuration;\n                    var treeBaseDuration = completedWork.selfBaseDuration;\n                    var child = completedWork.child;\n                    while(child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                        subtreeFlags |= child.subtreeFlags;\n                        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n                        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n                        // When work is done, it should bubble to the parent's actualDuration. If\n                        // the fiber has not been cloned though, (meaning no work was done), then\n                        // this value will reflect the amount of time spent working on a previous\n                        // render. In that case it should not bubble. We determine whether it was\n                        // cloned by comparing the child pointer.\n                        actualDuration += child.actualDuration;\n                        treeBaseDuration += child.treeBaseDuration;\n                        child = child.sibling;\n                    }\n                    completedWork.actualDuration = actualDuration;\n                    completedWork.treeBaseDuration = treeBaseDuration;\n                } else {\n                    var _child = completedWork.child;\n                    while(_child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                        subtreeFlags |= _child.subtreeFlags;\n                        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child.return = completedWork;\n                        _child = _child.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            } else {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var _treeBaseDuration = completedWork.selfBaseDuration;\n                    var _child2 = completedWork.child;\n                    while(_child2 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child2.flags & StaticMask;\n                        _treeBaseDuration += _child2.treeBaseDuration;\n                        _child2 = _child2.sibling;\n                    }\n                    completedWork.treeBaseDuration = _treeBaseDuration;\n                } else {\n                    var _child3 = completedWork.child;\n                    while(_child3 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child3.return = completedWork;\n                        _child3 = _child3.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            }\n            completedWork.childLanes = newChildLanes;\n            return didBailout;\n        }\n        function completeWork(current, workInProgress, renderLanes) {\n            var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case IndeterminateComponent:\n                case LazyComponent:\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                case ForwardRef:\n                case Fragment:\n                case Mode:\n                case Profiler:\n                case ContextConsumer:\n                case MemoComponent:\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            popContext(workInProgress);\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        var fiberRoot = workInProgress.stateNode;\n                        popHostContainer(workInProgress);\n                        popTopLevelContextObject(workInProgress);\n                        resetWorkInProgressVersions();\n                        if (fiberRoot.pendingContext) {\n                            fiberRoot.context = fiberRoot.pendingContext;\n                            fiberRoot.pendingContext = null;\n                        }\n                        if (current === null || current.child === null) {\n                            // If we hydrated, pop so that we can delete any remaining children\n                            // that weren't hydrated.\n                            var wasHydrated = popHydrationState(workInProgress);\n                            if (wasHydrated) {\n                                // If we hydrated, then we'll need to schedule an update for\n                                // the commit side-effects on the root.\n                                markUpdate(workInProgress);\n                            } else {\n                                if (current !== null) {\n                                    var prevState = current.memoizedState;\n                                    if (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                                    (workInProgress.flags & ForceClientRender) !== NoFlags) {\n                                        // Schedule an effect to clear this container at the start of the\n                                        // next commit. This handles the case of React rendering into a\n                                        // container with previous children. It's also safe to do for\n                                        // updates too, because current.child would only be null if the\n                                        // previous render was null (so the container would already\n                                        // be empty).\n                                        workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                                        // recoverable errors during first hydration attempt. If so, add\n                                        // them to a queue so we can log them in the commit phase.\n                                        upgradeHydrationErrorsToRecoverable();\n                                    }\n                                }\n                            }\n                        }\n                        updateHostContainer(current, workInProgress);\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(workInProgress);\n                        var rootContainerInstance = getRootHostContainer();\n                        var type = workInProgress.type;\n                        if (current !== null && workInProgress.stateNode != null) {\n                            updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n                            if (current.ref !== workInProgress.ref) {\n                                markRef(workInProgress);\n                            }\n                        } else {\n                            if (!newProps) {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error(\"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                                } // This can happen when we abort work.\n                                bubbleProperties(workInProgress);\n                                return null;\n                            }\n                            var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                            // \"stack\" as the parent. Then append children as we go in beginWork\n                            // or completeWork depending on whether we want to add them top->down or\n                            // bottom->up. Top->down is faster in IE11.\n                            var _wasHydrated = popHydrationState(workInProgress);\n                            if (_wasHydrated) {\n                                // TODO: Move this and createInstance step into the beginPhase\n                                // to consolidate.\n                                if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n                                    // If changes to the hydrated node need to be applied at the\n                                    // commit-phase we mark this as such.\n                                    markUpdate(workInProgress);\n                                }\n                            } else {\n                                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n                                appendAllChildren(instance, workInProgress, false, false);\n                                workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n                                // (eg DOM renderer supports auto-focus for certain elements).\n                                // Make sure such renderers get scheduled for later work.\n                                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                            if (workInProgress.ref !== null) {\n                                // If there is a ref on a host node we need to schedule a callback\n                                markRef(workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostText:\n                    {\n                        var newText = newProps;\n                        if (current && workInProgress.stateNode != null) {\n                            var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                            // to schedule a side-effect to do the updates.\n                            updateHostText(current, workInProgress, oldText, newText);\n                        } else {\n                            if (typeof newText !== \"string\") {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error(\"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                                } // This can happen when we abort work.\n                            }\n                            var _rootContainerInstance = getRootHostContainer();\n                            var _currentHostContext = getHostContext();\n                            var _wasHydrated2 = popHydrationState(workInProgress);\n                            if (_wasHydrated2) {\n                                if (prepareToHydrateHostTextInstance(workInProgress)) {\n                                    markUpdate(workInProgress);\n                                }\n                            } else {\n                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        var nextState = workInProgress.memoizedState;\n                        {\n                            if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n                                warnIfUnhydratedTailNodes(workInProgress);\n                                resetHydrationState();\n                                workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n                                return workInProgress;\n                            }\n                            if (nextState !== null && nextState.dehydrated !== null) {\n                                // We might be inside a hydration state the first time we're picking up this\n                                // Suspense boundary, and also after we've reentered it for further hydration.\n                                var _wasHydrated3 = popHydrationState(workInProgress);\n                                if (current === null) {\n                                    if (!_wasHydrated3) {\n                                        throw new Error(\"A dehydrated suspense component was completed without a hydrated node. \" + \"This is probably a bug in React.\");\n                                    }\n                                    prepareToHydrateHostSuspenseInstance(workInProgress);\n                                    bubbleProperties(workInProgress);\n                                    {\n                                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                            var isTimedOutSuspense = nextState !== null;\n                                            if (isTimedOutSuspense) {\n                                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                                var primaryChildFragment = workInProgress.child;\n                                                if (primaryChildFragment !== null) {\n                                                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return null;\n                                } else {\n                                    // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n                                    // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n                                    resetHydrationState();\n                                    if ((workInProgress.flags & DidCapture) === NoFlags) {\n                                        // This boundary did not suspend so it's now hydrated and unsuspended.\n                                        workInProgress.memoizedState = null;\n                                    } // If nothing suspended, we need to schedule an effect to mark this boundary\n                                    // as having hydrated so events know that they're free to be invoked.\n                                    // It's also a signal to replay events and the suspense callback.\n                                    // If something suspended, schedule an effect to attach retry listeners.\n                                    // So we might as well always mark this.\n                                    workInProgress.flags |= Update;\n                                    bubbleProperties(workInProgress);\n                                    {\n                                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                            var _isTimedOutSuspense = nextState !== null;\n                                            if (_isTimedOutSuspense) {\n                                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                                var _primaryChildFragment = workInProgress.child;\n                                                if (_primaryChildFragment !== null) {\n                                                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                                    workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return null;\n                                }\n                            } // Successfully completed this tree. If this was a forced client render,\n                            // there may have been recoverable errors during first hydration\n                            // attempt. If so, add them to a queue so we can log them in the\n                            // commit phase.\n                            upgradeHydrationErrorsToRecoverable();\n                        }\n                        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n                            // Something suspended. Re-render with the fallback children.\n                            workInProgress.lanes = renderLanes; // Do not reset the effect list.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            } // Don't bubble properties in this case.\n                            return workInProgress;\n                        }\n                        var nextDidTimeout = nextState !== null;\n                        var prevDidTimeout = false;\n                        if (current === null) {\n                            popHydrationState(workInProgress);\n                        } else {\n                            var _prevState = current.memoizedState;\n                            prevDidTimeout = _prevState !== null;\n                        }\n                        // an effect to toggle the subtree's visibility. When we switch from\n                        // fallback -> primary, the inner Offscreen fiber schedules this effect\n                        // as part of its normal complete phase. But when we switch from\n                        // primary -> fallback, the inner Offscreen fiber does not have a complete\n                        // phase. So we need to schedule its effect here.\n                        //\n                        // We also use this flag to connect/disconnect the effects, but the same\n                        // logic applies: when re-connecting, the Offscreen fiber's complete\n                        // phase will handle scheduling the effect. It's only when the fallback\n                        // is active that we have to do anything special.\n                        if (nextDidTimeout && !prevDidTimeout) {\n                            var _offscreenFiber = workInProgress.child;\n                            _offscreenFiber.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n                            // in the concurrent tree already suspended during this render.\n                            // This is a known bug.\n                            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n                                // TODO: Move this back to throwException because this is too late\n                                // if this is a large tree which is common for initial loads. We\n                                // don't know if we should restart a render or not until we get\n                                // this marker, and this is too late.\n                                // If this render already had a ping or lower pri updates,\n                                // and this is the first time we know we're going to suspend we\n                                // should be able to immediately restart from within throwException.\n                                var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n                                if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                                    // If this was in an invisible tree or a new render, then showing\n                                    // this boundary is ok.\n                                    renderDidSuspend();\n                                } else {\n                                    // Otherwise, we're going to have to hide content so we should\n                                    // suspend for longer if possible.\n                                    renderDidSuspendDelayIfPossible();\n                                }\n                            }\n                        }\n                        var wakeables = workInProgress.updateQueue;\n                        if (wakeables !== null) {\n                            // Schedule an effect to attach a retry listener to the promise.\n                            // TODO: Move to passive phase\n                            workInProgress.flags |= Update;\n                        }\n                        bubbleProperties(workInProgress);\n                        {\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                if (nextDidTimeout) {\n                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                    var _primaryChildFragment2 = workInProgress.child;\n                                    if (_primaryChildFragment2 !== null) {\n                                        // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                        workInProgress.treeBaseDuration -= _primaryChildFragment2.treeBaseDuration;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    updateHostContainer(current, workInProgress);\n                    if (current === null) {\n                        preparePortalMount(workInProgress.stateNode.containerInfo);\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ContextProvider:\n                    // Pop provider fiber\n                    var context = workInProgress.type._context;\n                    popProvider(context, workInProgress);\n                    bubbleProperties(workInProgress);\n                    return null;\n                case IncompleteClassComponent:\n                    {\n                        // Same as class component case. I put it down here so that the tags are\n                        // sequential to ensure this switch is compiled to a jump table.\n                        var _Component = workInProgress.type;\n                        if (isContextProvider(_Component)) {\n                            popContext(workInProgress);\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState === null) {\n                            // We're running in the default, \"independent\" mode.\n                            // We don't do anything in this mode.\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n                        var renderedTail = renderState.rendering;\n                        if (renderedTail === null) {\n                            // We just rendered the head.\n                            if (!didSuspendAlready) {\n                                // This is the first pass. We need to figure out if anything is still\n                                // suspended in the rendered set.\n                                // If new content unsuspended, but there's still some content that\n                                // didn't. Then we need to do a second pass that forces everything\n                                // to keep showing their fallbacks.\n                                // We might be suspended if something in this render pass suspended, or\n                                // something in the previous committed pass suspended. Otherwise,\n                                // there's no chance so we can skip the expensive call to\n                                // findFirstSuspended.\n                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n                                if (!cannotBeSuspended) {\n                                    var row = workInProgress.child;\n                                    while(row !== null){\n                                        var suspended = findFirstSuspended(row);\n                                        if (suspended !== null) {\n                                            didSuspendAlready = true;\n                                            workInProgress.flags |= DidCapture;\n                                            cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                                            // part of the second pass. In that case nothing will subscribe to\n                                            // its thenables. Instead, we'll transfer its thenables to the\n                                            // SuspenseList so that it can retry if they resolve.\n                                            // There might be multiple of these in the list but since we're\n                                            // going to wait for all of them anyway, it doesn't really matter\n                                            // which ones gets to ping. In theory we could get clever and keep\n                                            // track of how many dependencies remain but it gets tricky because\n                                            // in the meantime, we can add/remove/change items and dependencies.\n                                            // We might bail out of the loop before finding any but that\n                                            // doesn't matter since that means that the other boundaries that\n                                            // we did find already has their listeners attached.\n                                            var newThenables = suspended.updateQueue;\n                                            if (newThenables !== null) {\n                                                workInProgress.updateQueue = newThenables;\n                                                workInProgress.flags |= Update;\n                                            } // Rerender the whole list, but this time, we'll force fallbacks\n                                            // to stay in place.\n                                            // Reset the effect flags before doing the second pass since that's now invalid.\n                                            // Reset the child fibers to their original state.\n                                            workInProgress.subtreeFlags = NoFlags;\n                                            resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n                                            // rerender the children.\n                                            pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n                                            return workInProgress.child;\n                                        }\n                                        row = row.sibling;\n                                    }\n                                }\n                                if (renderState.tail !== null && now$1() > getRenderTargetTime()) {\n                                    // We have already passed our CPU deadline but we still have rows\n                                    // left in the tail. We'll just give up further attempts to render\n                                    // the main content and only render fallbacks.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            } else {\n                                cutOffTailIfNeeded(renderState, false);\n                            } // Next we're going to render the tail.\n                        } else {\n                            // Append the rendered row to the child list.\n                            if (!didSuspendAlready) {\n                                var _suspended = findFirstSuspended(renderedTail);\n                                if (_suspended !== null) {\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n                                    // get lost if this row ends up dropped during a second pass.\n                                    var _newThenables = _suspended.updateQueue;\n                                    if (_newThenables !== null) {\n                                        workInProgress.updateQueue = _newThenables;\n                                        workInProgress.flags |= Update;\n                                    }\n                                    cutOffTailIfNeeded(renderState, true); // This might have been modified.\n                                    if (renderState.tail === null && renderState.tailMode === \"hidden\" && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n                                    ) {\n                                        // We're done.\n                                        bubbleProperties(workInProgress);\n                                        return null;\n                                    }\n                                } else if (// time we have to render. So rendering one more row would likely\n                                // exceed it.\n                                now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n                                    // We have now passed our CPU deadline and we'll just give up further\n                                    // attempts to render the main content and only render fallbacks.\n                                    // The assumption is that this is usually faster.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            }\n                            if (renderState.isBackwards) {\n                                // The effect list of the backwards tail will have been added\n                                // to the end. This breaks the guarantee that life-cycles fire in\n                                // sibling order but that isn't a strong guarantee promised by React.\n                                // Especially since these might also just pop in during future commits.\n                                // Append to the beginning of the list.\n                                renderedTail.sibling = workInProgress.child;\n                                workInProgress.child = renderedTail;\n                            } else {\n                                var previousSibling = renderState.last;\n                                if (previousSibling !== null) {\n                                    previousSibling.sibling = renderedTail;\n                                } else {\n                                    workInProgress.child = renderedTail;\n                                }\n                                renderState.last = renderedTail;\n                            }\n                        }\n                        if (renderState.tail !== null) {\n                            // We still have tail rows to render.\n                            // Pop a row.\n                            var next = renderState.tail;\n                            renderState.rendering = next;\n                            renderState.tail = next.sibling;\n                            renderState.renderingStartTime = now$1();\n                            next.sibling = null; // Restore the context.\n                            // TODO: We can probably just avoid popping it instead and only\n                            // setting it the first time we go from not suspended to suspended.\n                            var suspenseContext = suspenseStackCursor.current;\n                            if (didSuspendAlready) {\n                                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n                            } else {\n                                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n                            }\n                            pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n                            // Don't bubble properties in this case.\n                            return next;\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popRenderLanes(workInProgress);\n                        var _nextState = workInProgress.memoizedState;\n                        var nextIsHidden = _nextState !== null;\n                        if (current !== null) {\n                            var _prevState2 = current.memoizedState;\n                            var prevIsHidden = _prevState2 !== null;\n                            if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {\n                                workInProgress.flags |= Visibility;\n                            }\n                        }\n                        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n                            bubbleProperties(workInProgress);\n                        } else {\n                            // Don't bubble properties for hidden children unless we're rendering\n                            // at offscreen priority.\n                            if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n                                bubbleProperties(workInProgress);\n                                if (supportsMutation) {\n                                    // Check if there was an insertion or update in the hidden subtree.\n                                    // If so, we need to hide those nodes in the commit phase, so\n                                    // schedule a visibility effect.\n                                    if (workInProgress.subtreeFlags & (Placement | Update)) {\n                                        workInProgress.flags |= Visibility;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        return null;\n                    }\n                case TracingMarkerComponent:\n                    {\n                        return null;\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutModulePatternComponent;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutFunctionRefs;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        {\n            didWarnAboutBadClass = {};\n            didWarnAboutModulePatternComponent = {};\n            didWarnAboutContextTypeOnFunctionComponent = {};\n            didWarnAboutGetDerivedStateOnFunctionComponent = {};\n            didWarnAboutFunctionRefs = {};\n            didWarnAboutReassigningProps = false;\n            didWarnAboutRevealOrder = {};\n            didWarnAboutTailOptions = {};\n        }\n        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n            if (current === null) {\n                // If this is a fresh new component that hasn't been rendered yet, we\n                // won't update its child set by applying minimal side-effects. Instead,\n                // we will add them all to the child before it gets rendered. That means\n                // we can optimize this reconciliation pass by not tracking side-effects.\n                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                // If the current child is the same as the work in progress, it means that\n                // we haven't yet started any work on these children. Therefore, we use\n                // the clone algorithm to create a copy of all the current children.\n                // If we had any progressed work already, that is invalid at this point so\n                // let's throw it out.\n                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n            }\n        }\n        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n            // This function is fork of reconcileChildren. It's used in cases where we\n            // want to reconcile without matching against the existing set. This has the\n            // effect of all current children being unmounted; even if the type and key\n            // are the same, the old child is unmounted and a new child is created.\n            //\n            // To do this, we're going to go through the reconcile algorithm twice. In\n            // the first pass, we schedule a deletion for all the current children by\n            // passing null.\n            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n            // pass null in place of where we usually pass the current child set. This has\n            // the effect of remounting all children regardless of whether their\n            // identities match.\n            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n        }\n        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens after the first render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            var render = Component.render;\n            var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n                hasId = checkDidRenderIdHook();\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n                        hasId = checkDidRenderIdHook();\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            if (current === null) {\n                var type = Component.type;\n                if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n                Component.defaultProps === undefined) {\n                    var resolvedType = type;\n                    {\n                        resolvedType = resolveFunctionForHotReloading(type);\n                    }\n                    // and with only the default shallow comparison, we upgrade it\n                    // to a SimpleMemoComponent to allow fast path updates.\n                    workInProgress.tag = SimpleMemoComponent;\n                    workInProgress.type = resolvedType;\n                    {\n                        validateFunctionComponentInDev(workInProgress, type);\n                    }\n                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n                }\n                {\n                    var innerPropTypes = type.propTypes;\n                    if (innerPropTypes) {\n                        // Inner memo component props aren't currently validated in createElement.\n                        // We could move it there, but we'd still need this for lazy code path.\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(type));\n                    }\n                }\n                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n                child.ref = workInProgress.ref;\n                child.return = workInProgress;\n                workInProgress.child = child;\n                return child;\n            }\n            {\n                var _type = Component.type;\n                var _innerPropTypes = _type.propTypes;\n                if (_innerPropTypes) {\n                    // Inner memo component props aren't currently validated in createElement.\n                    // We could move it there, but we'd still need this for lazy code path.\n                    checkPropTypes(_innerPropTypes, nextProps, \"prop\", getComponentNameFromType(_type));\n                }\n            }\n            var currentChild = current.child; // This is always exactly one child\n            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n            if (!hasScheduledUpdateOrContext) {\n                // This will be the props with resolved defaultProps,\n                // unlike current.memoizedProps which will be the unresolved ones.\n                var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n                var compare = Component.compare;\n                compare = compare !== null ? compare : shallowEqual;\n                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            var newChild = createWorkInProgress(currentChild, nextProps);\n            newChild.ref = workInProgress.ref;\n            newChild.return = workInProgress;\n            workInProgress.child = newChild;\n            return newChild;\n        }\n        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens when the inner render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var outerMemoType = workInProgress.elementType;\n                    if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n                        // We warn when you define propTypes on lazy()\n                        // so let's just skip over it to find memo() outer wrapper.\n                        // Inner props for memo are validated later.\n                        var lazyComponent = outerMemoType;\n                        var payload = lazyComponent._payload;\n                        var init = lazyComponent._init;\n                        try {\n                            outerMemoType = init(payload);\n                        } catch (x) {\n                            outerMemoType = null;\n                        } // Inner propTypes will be validated in the function component path.\n                        var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n                        if (outerPropTypes) {\n                            checkPropTypes(outerPropTypes, nextProps, \"prop\", getComponentNameFromType(outerMemoType));\n                        }\n                    }\n                }\n            }\n            if (current !== null) {\n                var prevProps = current.memoizedProps;\n                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {\n                    didReceiveUpdate = false;\n                    if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n                        // The pending lanes were cleared at the beginning of beginWork. We're\n                        // about to bail out, but there might be other lanes that weren't\n                        // included in the current render. Usually, the priority level of the\n                        // remaining updates is accumulated during the evaluation of the\n                        // component (i.e. when processing the update queue). But since since\n                        // we're bailing out early *without* evaluating the component, we need\n                        // to account for it here, too. Reset to the value of the current fiber.\n                        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n                        // because a MemoComponent fiber does not have hooks or an update queue;\n                        // rather, it wraps around an inner component, which may or may not\n                        // contains hooks.\n                        // TODO: Move the reset at in beginWork out of the common path so that\n                        // this is no longer necessary.\n                        workInProgress.lanes = current.lanes;\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    }\n                }\n            }\n            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n        }\n        function updateOffscreenComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            var prevState = current !== null ? current.memoizedState : null;\n            if (nextProps.mode === \"hidden\" || enableLegacyHidden) {\n                // Rendering a hidden tree.\n                if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                    // In legacy sync mode, don't defer the subtree. Render it now.\n                    var nextState = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = nextState;\n                    pushRenderLanes(workInProgress, renderLanes);\n                } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n                    var spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out\n                    // and resume this tree later.\n                    var nextBaseLanes;\n                    if (prevState !== null) {\n                        var prevBaseLanes = prevState.baseLanes;\n                        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n                    } else {\n                        nextBaseLanes = renderLanes;\n                    } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n                    var _nextState = {\n                        baseLanes: nextBaseLanes,\n                        cachePool: spawnedCachePool\n                    };\n                    workInProgress.memoizedState = _nextState;\n                    workInProgress.updateQueue = null;\n                    // to avoid a push/pop misalignment.\n                    pushRenderLanes(workInProgress, nextBaseLanes);\n                    return null;\n                } else {\n                    // This is the second render. The surrounding visible content has already\n                    // committed. Now we resume rendering the hidden tree.\n                    // Rendering at offscreen, so we can clear the base lanes.\n                    var _nextState2 = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.\n                    var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n                    pushRenderLanes(workInProgress, subtreeRenderLanes);\n                }\n            } else {\n                // Rendering a visible tree.\n                var _subtreeRenderLanes;\n                if (prevState !== null) {\n                    // We're going from hidden -> visible.\n                    _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n                    workInProgress.memoizedState = null;\n                } else {\n                    // We weren't previously hidden, and we still aren't, so there's nothing\n                    // special to do. Need to push to the stack regardless, though, to avoid\n                    // a push/pop misalignment.\n                    _subtreeRenderLanes = renderLanes;\n                }\n                pushRenderLanes(workInProgress, _subtreeRenderLanes);\n            }\n            {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n                return workInProgress.child;\n            }\n        }\n        function updateFragment(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMode(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateProfiler(current, workInProgress, renderLanes) {\n            {\n                workInProgress.flags |= Update;\n                {\n                    // Reset effect durations for the next eventual effect phase.\n                    // These are reset during render to allow the DevTools commit hook a chance to read them,\n                    var stateNode = workInProgress.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                }\n            }\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markRef$1(current, workInProgress) {\n            var ref = workInProgress.ref;\n            if (current === null && ref !== null || current !== null && current.ref !== ref) {\n                // Schedule a Ref effect\n                workInProgress.flags |= Ref;\n                {\n                    workInProgress.flags |= RefStatic;\n                }\n            }\n        }\n        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            var context;\n            {\n                var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n                context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                        hasId = checkDidRenderIdHook();\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                // This is used by DevTools to force a boundary to error.\n                switch(shouldError(workInProgress)){\n                    case false:\n                        {\n                            var _instance = workInProgress.stateNode;\n                            var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n                            // Is there a better way to do this?\n                            var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n                            var state = tempInstance.state;\n                            _instance.updater.enqueueSetState(_instance, state, null);\n                            break;\n                        }\n                    case true:\n                        {\n                            workInProgress.flags |= DidCapture;\n                            workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n                            var error$1 = new Error(\"Simulated error coming from DevTools\");\n                            var lane = pickArbitraryLane(renderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n                            var update = createClassErrorUpdate(workInProgress, createCapturedValue(error$1, workInProgress), lane);\n                            enqueueCapturedUpdate(workInProgress, update);\n                            break;\n                        }\n                }\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider(Component)) {\n                hasContext = true;\n                pushContextProvider(workInProgress);\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var instance = workInProgress.stateNode;\n            var shouldUpdate;\n            if (instance === null) {\n                if (current !== null) {\n                    // A class component without an instance only mounts if it suspended\n                    // inside a non-concurrent tree, in an inconsistent state. We want to\n                    // treat it like a new mount, even though an empty version of it already\n                    // committed. Disconnect the alternate pointers.\n                    current.alternate = null;\n                    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                    workInProgress.flags |= Placement;\n                } // In the initial pass we might need to construct the instance.\n                constructClassInstance(workInProgress, Component, nextProps);\n                mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n                shouldUpdate = true;\n            } else if (current === null) {\n                // In a resume, we'll already have an instance we can reuse.\n                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            } else {\n                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n            }\n            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n            {\n                var inst = workInProgress.stateNode;\n                if (shouldUpdate && inst.props !== nextProps) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            return nextUnitOfWork;\n        }\n        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n            // Refs should update even if shouldComponentUpdate returns false\n            markRef$1(current, workInProgress);\n            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n            if (!shouldUpdate && !didCaptureError) {\n                // Context providers should defer to sCU for rendering\n                if (hasContext) {\n                    invalidateContextProvider(workInProgress, Component, false);\n                }\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            var instance = workInProgress.stateNode; // Rerender\n            ReactCurrentOwner$1.current = workInProgress;\n            var nextChildren;\n            if (didCaptureError && typeof Component.getDerivedStateFromError !== \"function\") {\n                // If we captured an error, but getDerivedStateFromError is not defined,\n                // unmount all the children. componentDidCatch will schedule an update to\n                // re-render a fallback. This is temporary until we migrate everyone to\n                // the new API.\n                // TODO: Warn in a future release.\n                nextChildren = null;\n                {\n                    stopProfilerTimerIfRunning();\n                }\n            } else {\n                {\n                    markComponentRenderStarted(workInProgress);\n                }\n                {\n                    setIsRendering(true);\n                    nextChildren = instance.render();\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            instance.render();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    setIsRendering(false);\n                }\n                {\n                    markComponentRenderStopped();\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            if (current !== null && didCaptureError) {\n                // If we're recovering from an error, reconcile without reusing any of\n                // the existing children. Conceptually, the normal children and the children\n                // that are shown on error are two different sets, so we shouldn't reuse\n                // normal children even if their identities match.\n                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            } // Memoize state using the values we just used to render.\n            // TODO: Restructure so we never read values from the instance.\n            workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n            if (hasContext) {\n                invalidateContextProvider(workInProgress, Component, true);\n            }\n            return workInProgress.child;\n        }\n        function pushHostRootContext(workInProgress) {\n            var root = workInProgress.stateNode;\n            if (root.pendingContext) {\n                pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n            } else if (root.context) {\n                // Should always be set\n                pushTopLevelContextObject(workInProgress, root.context, false);\n            }\n            pushHostContainer(workInProgress, root.containerInfo);\n        }\n        function updateHostRoot(current, workInProgress, renderLanes) {\n            pushHostRootContext(workInProgress);\n            if (current === null) {\n                throw new Error(\"Should have a current fiber. This is a bug in React.\");\n            }\n            var nextProps = workInProgress.pendingProps;\n            var prevState = workInProgress.memoizedState;\n            var prevChildren = prevState.element;\n            cloneUpdateQueue(current, workInProgress);\n            processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n            var nextState = workInProgress.memoizedState;\n            var root = workInProgress.stateNode;\n            // being called \"element\".\n            var nextChildren = nextState.element;\n            if (supportsHydration && prevState.isDehydrated) {\n                // This is a hydration root whose shell has not yet hydrated. We should\n                // attempt to hydrate.\n                // Flip isDehydrated to false to indicate that when this render\n                // finishes, the root will no longer be dehydrated.\n                var overrideState = {\n                    element: nextChildren,\n                    isDehydrated: false,\n                    cache: nextState.cache,\n                    transitions: nextState.transitions\n                };\n                var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n                // have reducer functions so it doesn't need rebasing.\n                updateQueue.baseState = overrideState;\n                workInProgress.memoizedState = overrideState;\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during a previous attempt to hydrate the shell, so we\n                    // forced a client render.\n                    var recoverableError = new Error(\"There was an error while hydrating. Because the error happened outside \" + \"of a Suspense boundary, the entire root will switch to \" + \"client rendering.\");\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n                } else if (nextChildren !== prevChildren) {\n                    var _recoverableError = new Error(\"This root received an early update, before anything was able \" + \"hydrate. Switched the entire root to client rendering.\");\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);\n                } else {\n                    // The outermost shell has not hydrated yet. Start hydrating.\n                    enterHydrationState(workInProgress);\n                    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n                    workInProgress.child = child;\n                    var node = child;\n                    while(node){\n                        // Mark each child as hydrating. This is a fast path to know whether this\n                        // tree is part of a hydrating tree. This is used to determine if a child\n                        // node has fully mounted yet, and for scheduling event replaying.\n                        // Conceptually this is similar to Placement in that a new subtree is\n                        // inserted into the React tree here. It just happens to not need DOM\n                        // mutations because it already exists.\n                        node.flags = node.flags & ~Placement | Hydrating;\n                        node = node.sibling;\n                    }\n                }\n            } else {\n                // Root is not dehydrated. Either this is a client-only root, or it\n                // already hydrated.\n                resetHydrationState();\n                if (nextChildren === prevChildren) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n            // Revert to client rendering.\n            resetHydrationState();\n            queueHydrationError(recoverableError);\n            workInProgress.flags |= ForceClientRender;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostComponent$1(current, workInProgress, renderLanes) {\n            pushHostContext(workInProgress);\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            }\n            var type = workInProgress.type;\n            var nextProps = workInProgress.pendingProps;\n            var prevProps = current !== null ? current.memoizedProps : null;\n            var nextChildren = nextProps.children;\n            var isDirectTextChild = shouldSetTextContent(type, nextProps);\n            if (isDirectTextChild) {\n                // We special case a direct text child of a host node. This is a common\n                // case. We won't handle it as a reified child. We will instead handle\n                // this in the host environment that also has access to this prop. That\n                // avoids allocating another HostText fiber and traversing it.\n                nextChildren = null;\n            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n                // If we're switching from a direct text child to a normal child, or to\n                // empty, we need to schedule the text content to be reset.\n                workInProgress.flags |= ContentReset;\n            }\n            markRef$1(current, workInProgress);\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostText$1(current, workInProgress) {\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            } // Nothing to do here. This is terminal. We'll do the completion step\n            // immediately after.\n            return null;\n        }\n        function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n            if (_current !== null) {\n                // A lazy component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            }\n            var props = workInProgress.pendingProps;\n            var lazyComponent = elementType;\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload); // Store the unwrapped component in the type.\n            workInProgress.type = Component;\n            var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            var child;\n            switch(resolvedTag){\n                case FunctionComponent:\n                    {\n                        {\n                            validateFunctionComponentInDev(workInProgress, Component);\n                            workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n                        }\n                        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case ClassComponent:\n                    {\n                        {\n                            workInProgress.type = Component = resolveClassForHotReloading(Component);\n                        }\n                        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case ForwardRef:\n                    {\n                        {\n                            workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n                        }\n                        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case MemoComponent:\n                    {\n                        {\n                            if (workInProgress.type !== workInProgress.elementType) {\n                                var outerPropTypes = Component.propTypes;\n                                if (outerPropTypes) {\n                                    checkPropTypes(outerPropTypes, resolvedProps, \"prop\", getComponentNameFromType(Component));\n                                }\n                            }\n                        }\n                        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), renderLanes);\n                        return child;\n                    }\n            }\n            var hint = \"\";\n            {\n                if (Component !== null && typeof Component === \"object\" && Component.$$typeof === REACT_LAZY_TYPE) {\n                    hint = \" Did you wrap a component in React.lazy() more than once?\";\n                }\n            }\n            // because the fact that it's a separate type of work is an\n            // implementation detail.\n            throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n            if (_current !== null) {\n                // An incomplete component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            } // Promote the fiber to a class and try rendering again.\n            workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n            // Push context providers early to prevent context stack mismatches.\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider(Component)) {\n                hasContext = true;\n                pushContextProvider(workInProgress);\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            constructClassInstance(workInProgress, Component, nextProps);\n            mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n        }\n        function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n            if (_current !== null) {\n                // An indeterminate component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            }\n            var props = workInProgress.pendingProps;\n            var context;\n            {\n                var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n                context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var value;\n            var hasId;\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n                }\n                setIsRendering(true);\n                ReactCurrentOwner$1.current = workInProgress;\n                value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n                // During mounting we don't know the child context yet as the instance doesn't exist.\n                // We will invalidate the child context in finishClassComponent() right after rendering.\n                var hasContext = false;\n                if (isContextProvider(Component)) {\n                    hasContext = true;\n                    pushContextProvider(workInProgress);\n                } else {\n                    hasContext = false;\n                }\n                workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n                initializeUpdateQueue(workInProgress);\n                adoptClassInstance(workInProgress, value);\n                mountClassInstance(workInProgress, Component, props, renderLanes);\n                return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n            } else {\n                // Proceed under the assumption that this is a function component\n                workInProgress.tag = FunctionComponent;\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n                            hasId = checkDidRenderIdHook();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                }\n                if (getIsHydrating() && hasId) {\n                    pushMaterializedTreeId(workInProgress);\n                }\n                reconcileChildren(null, workInProgress, value, renderLanes);\n                {\n                    validateFunctionComponentInDev(workInProgress, Component);\n                }\n                return workInProgress.child;\n            }\n        }\n        function validateFunctionComponentInDev(workInProgress, Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (workInProgress.ref !== null) {\n                    var info = \"\";\n                    var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n                    if (ownerName) {\n                        info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                    }\n                    var warningKey = ownerName || \"\";\n                    var debugSource = workInProgress._debugSource;\n                    if (debugSource) {\n                        warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n                    }\n                    if (!didWarnAboutFunctionRefs[warningKey]) {\n                        didWarnAboutFunctionRefs[warningKey] = true;\n                        error(\"Function components cannot be given refs. \" + \"Attempts to access this ref will fail. \" + \"Did you mean to use React.forwardRef()?%s\", info);\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        var SUSPENDED_MARKER = {\n            dehydrated: null,\n            treeContext: null,\n            retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes) {\n            return {\n                baseLanes: renderLanes,\n                cachePool: getSuspendedCache()\n            };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n            var cachePool = null;\n            return {\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n                cachePool: cachePool\n            };\n        } // TODO: Probably should inline this back\n        function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n            // If we're already showing a fallback, there are cases where we need to\n            // remain on that fallback regardless of whether the content has resolved.\n            // For example, SuspenseList coordinates when nested content appears.\n            if (current !== null) {\n                var suspenseState = current.memoizedState;\n                if (suspenseState === null) {\n                    // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n                    // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n                    // Note: This is a factoring smell. Can't remain on a fallback if there's\n                    // no fallback to remain on.\n                    return false;\n                }\n            } // Not currently showing content. Consult the Suspense context.\n            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current, renderLanes) {\n            // TODO: Should not remove render lanes that were pinged during this render\n            return removeLanes(current.childLanes, renderLanes);\n        }\n        function updateSuspenseComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n            {\n                if (shouldSuspend(workInProgress)) {\n                    workInProgress.flags |= DidCapture;\n                }\n            }\n            var suspenseContext = suspenseStackCursor.current;\n            var showFallback = false;\n            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n            if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {\n                // Something in this boundary's subtree already suspended. Switch to\n                // rendering the fallback children.\n                showFallback = true;\n                workInProgress.flags &= ~DidCapture;\n            } else {\n                // Attempting the main content\n                if (current === null || current.memoizedState !== null) {\n                    // This is a new mount or this boundary is already showing a fallback state.\n                    // Mark this subtree context as having at least one invisible parent that could\n                    // handle the fallback state.\n                    // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n                    {\n                        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n                    }\n                }\n            }\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n            pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n            // boundary's children. This involves some custom reconciliation logic. Two\n            // main reasons this is so complicated.\n            //\n            // First, Legacy Mode has different semantics for backwards compatibility. The\n            // primary tree will commit in an inconsistent state, so when we do the\n            // second pass to render the fallback, we do some exceedingly, uh, clever\n            // hacks to make that not totally break. Like transferring effects and\n            // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n            // because we bailout on the primary tree completely and leave it in its old\n            // state, no effects. Same as what we do for Offscreen (except that\n            // Offscreen doesn't have the first render pass).\n            //\n            // Second is hydration. During hydration, the Suspense fiber has a slightly\n            // different layout, where the child points to a dehydrated fragment, which\n            // contains the DOM rendered by the server.\n            //\n            // Third, even if you set all that aside, Suspense is like error boundaries in\n            // that we first we try to render one tree, and if that fails, we render again\n            // and switch to a different tree. Like a try/catch block. So we have to track\n            // which branch we're currently rendering. Ideally we would model this using\n            // a stack.\n            if (current === null) {\n                // Initial mount\n                // If we're currently hydrating, try to hydrate this boundary.\n                tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n                {\n                    var suspenseState = workInProgress.memoizedState;\n                    if (suspenseState !== null) {\n                        var dehydrated = suspenseState.dehydrated;\n                        if (dehydrated !== null) {\n                            return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n                        }\n                    }\n                }\n                var nextPrimaryChildren = nextProps.children;\n                var nextFallbackChildren = nextProps.fallback;\n                if (showFallback) {\n                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var primaryChildFragment = workInProgress.child;\n                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackFragment;\n                } else {\n                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n                }\n            } else {\n                // This is an update.\n                // If the current fiber has a SuspenseState, that means it's already showing\n                // a fallback.\n                var prevState = current.memoizedState;\n                if (prevState !== null) {\n                    // The current tree is already showing a fallback\n                    // Special path for hydration\n                    {\n                        var _dehydrated = prevState.dehydrated;\n                        if (_dehydrated !== null) {\n                            if (!didSuspend) {\n                                return updateDehydratedSuspenseComponent(current, workInProgress, _dehydrated, prevState, renderLanes);\n                            } else if (workInProgress.flags & ForceClientRender) {\n                                // Something errored during hydration. Try again without hydrating.\n                                workInProgress.flags &= ~ForceClientRender;\n                                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error(\"There was an error while hydrating this Suspense boundary. \" + \"Switched to client rendering.\"));\n                            } else if (workInProgress.memoizedState !== null) {\n                                // Something suspended and we should still be in dehydrated mode.\n                                // Leave the existing child in place.\n                                workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n                                // but the normal suspense pass doesn't.\n                                workInProgress.flags |= DidCapture;\n                                return null;\n                            } else {\n                                // Suspended but we should no longer be in dehydrated mode.\n                                // Therefore we now have to render the fallback.\n                                var _nextPrimaryChildren = nextProps.children;\n                                var _nextFallbackChildren = nextProps.fallback;\n                                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n                                var _primaryChildFragment2 = workInProgress.child;\n                                _primaryChildFragment2.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                                workInProgress.memoizedState = SUSPENDED_MARKER;\n                                return fallbackChildFragment;\n                            }\n                        }\n                    }\n                    if (showFallback) {\n                        var _nextFallbackChildren2 = nextProps.fallback;\n                        var _nextPrimaryChildren2 = nextProps.children;\n                        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);\n                        var _primaryChildFragment3 = workInProgress.child;\n                        var prevOffscreenState = current.child.memoizedState;\n                        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n                        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n                        workInProgress.memoizedState = SUSPENDED_MARKER;\n                        return _fallbackChildFragment;\n                    } else {\n                        var _nextPrimaryChildren3 = nextProps.children;\n                        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);\n                        workInProgress.memoizedState = null;\n                        return _primaryChildFragment4;\n                    }\n                } else {\n                    // The current tree is not already showing a fallback.\n                    if (showFallback) {\n                        // Timed out.\n                        var _nextFallbackChildren3 = nextProps.fallback;\n                        var _nextPrimaryChildren4 = nextProps.children;\n                        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);\n                        var _primaryChildFragment5 = workInProgress.child;\n                        var _prevOffscreenState = current.child.memoizedState;\n                        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);\n                        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the\n                        // fallback children.\n                        workInProgress.memoizedState = SUSPENDED_MARKER;\n                        return _fallbackChildFragment2;\n                    } else {\n                        // Still haven't timed out. Continue rendering the children, like we\n                        // normally do.\n                        var _nextPrimaryChildren5 = nextProps.children;\n                        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);\n                        workInProgress.memoizedState = null;\n                        return _primaryChildFragment6;\n                    }\n                }\n            }\n        }\n        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: \"visible\",\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            primaryChildFragment.return = workInProgress;\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var progressedPrimaryFragment = workInProgress.child;\n            var primaryChildProps = {\n                mode: \"hidden\",\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            var fallbackChildFragment;\n            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n                // In legacy mode, we commit the primary tree as if it successfully\n                // completed, even though it's in an inconsistent state.\n                primaryChildFragment = progressedPrimaryFragment;\n                primaryChildFragment.childLanes = NoLanes;\n                primaryChildFragment.pendingProps = primaryChildProps;\n                if (workInProgress.mode & ProfileMode) {\n                    // Reset the durations from the first pass so they aren't included in the\n                    // final amounts. This seems counterintuitive, since we're intentionally\n                    // not measuring part of the render phase, but this makes it match what we\n                    // do in Concurrent Mode.\n                    primaryChildFragment.actualDuration = 0;\n                    primaryChildFragment.actualStartTime = -1;\n                    primaryChildFragment.selfBaseDuration = 0;\n                    primaryChildFragment.treeBaseDuration = 0;\n                }\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            } else {\n                primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            }\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n            // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n            // this wrapper function to constrain it.\n            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n            // The props argument to `createWorkInProgress` is `any` typed, so we use this\n            // wrapper function to constrain it.\n            return createWorkInProgress(current, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n                mode: \"visible\",\n                children: primaryChildren\n            });\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                primaryChildFragment.lanes = renderLanes;\n            }\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = null;\n            if (currentFallbackChildFragment !== null) {\n                // Delete the fallback child fragment\n                var deletions = workInProgress.deletions;\n                if (deletions === null) {\n                    workInProgress.deletions = [\n                        currentFallbackChildFragment\n                    ];\n                    workInProgress.flags |= ChildDeletion;\n                } else {\n                    deletions.push(currentFallbackChildFragment);\n                }\n            }\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildProps = {\n                mode: \"hidden\",\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            if (// completed, even though it's in an inconsistent state.\n            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n            // already cloned. In legacy mode, the only case where this isn't true is\n            // when DevTools forces us to display a fallback; we skip the first render\n            // pass entirely and go straight to rendering the fallback. (In Concurrent\n            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n            // only codepath.)\n            workInProgress.child !== currentPrimaryChildFragment) {\n                var progressedPrimaryFragment = workInProgress.child;\n                primaryChildFragment = progressedPrimaryFragment;\n                primaryChildFragment.childLanes = NoLanes;\n                primaryChildFragment.pendingProps = primaryChildProps;\n                if (workInProgress.mode & ProfileMode) {\n                    // Reset the durations from the first pass so they aren't included in the\n                    // final amounts. This seems counterintuitive, since we're intentionally\n                    // not measuring part of the render phase, but this makes it match what we\n                    // do in Concurrent Mode.\n                    primaryChildFragment.actualDuration = 0;\n                    primaryChildFragment.actualStartTime = -1;\n                    primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n                    primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n                }\n                // However, since we're going to remain on the fallback, we no longer want\n                // to delete it.\n                workInProgress.deletions = null;\n            } else {\n                primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n                // (We don't do this in legacy mode, because in legacy mode we don't re-use\n                // the current tree; see previous branch.)\n                primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n            }\n            var fallbackChildFragment;\n            if (currentFallbackChildFragment !== null) {\n                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n            } else {\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n                // mounted but this is a new fiber.\n                fallbackChildFragment.flags |= Placement;\n            }\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n            // Falling back to client rendering. Because this has performance\n            // implications, it's considered a recoverable error, even though the user\n            // likely won't observe anything wrong with the UI.\n            //\n            // The error is passed in as an argument to enforce that every caller provide\n            // a custom message, or explicitly opt out (currently the only path that opts\n            // out is legacy mode; every concurrent path provides an error).\n            if (recoverableError !== null) {\n                queueHydrationError(recoverableError);\n            } // This will add the old fiber to the deletion list\n            reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n            var nextProps = workInProgress.pendingProps;\n            var primaryChildren = nextProps.children;\n            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n            // mounted but this is a new fiber.\n            primaryChildFragment.flags |= Placement;\n            workInProgress.memoizedState = null;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var fiberMode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: \"visible\",\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n            // boundary) already mounted but this is a new fiber.\n            fallbackChildFragment.flags |= Placement;\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n                // We will have dropped the effect list which contains the\n                // deletion. We need to reconcile to delete the current child.\n                reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n            }\n            return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n            // During the first pass, we'll bail out and not drill into the children.\n            // Instead, we'll leave the content in place and try to hydrate it later.\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                {\n                    error(\"Cannot hydrate Suspense in legacy mode. Switch from \" + \"ReactDOM.hydrate(element, container) to \" + \"ReactDOMClient.hydrateRoot(container, <App />)\" + \".render(element) or remove the Suspense components from \" + \"the server rendered components.\");\n                }\n                workInProgress.lanes = laneToLanes(SyncLane);\n            } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This is a client-only boundary. Since we won't get any content from the server\n                // for this, we need to schedule that at a higher priority based on when it would\n                // have timed out. In theory we could render it in this pass but it would have the\n                // wrong priority associated with it and will prevent hydration of parent path.\n                // Instead, we'll leave work left on it to render it in a separate commit.\n                // TODO This time should be the time at which the server rendered response that is\n                // a parent to this boundary was displayed. However, since we currently don't have\n                // a protocol to transfer that time, we'll just estimate it by using the current\n                // time. This will mean that Suspense timeouts are slightly shifted to later than\n                // they should be.\n                // Schedule a normal pri update to render this content.\n                workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n            } else {\n                // We'll continue hydrating the rest at offscreen priority since we'll already\n                // be showing the right content coming from the server, it is no rush.\n                workInProgress.lanes = laneToLanes(OffscreenLane);\n            }\n            return null;\n        }\n        function updateDehydratedSuspenseComponent(current, workInProgress, suspenseInstance, suspenseState, renderLanes) {\n            // We should never be hydrating at this point because it is the first pass,\n            // but after we've already committed once.\n            warnIfHydrating();\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // required — every concurrent mode path that causes hydration to\n                // de-opt to client rendering should have an error message.\n                null);\n            }\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This boundary is in a permanent fallback state. In this case, we'll never\n                // get an update and we'll never be able to hydrate the final content. Let's just try the\n                // client side render instead.\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // here on the client. Or, in production, a hash/id that corresponds to\n                // the error.\n                new Error(\"The server could not finish this Suspense boundary, likely \" + \"due to an error during server rendering. Switched to \" + \"client rendering.\"));\n            }\n            // any context has changed, we need to treat is as if the input might have changed.\n            var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n            if (didReceiveUpdate || hasContextChanged) {\n                // This boundary has changed since the first render. This means that we are now unable to\n                // hydrate it. We might still be able to hydrate it using a higher priority lane.\n                var root = getWorkInProgressRoot();\n                if (root !== null) {\n                    var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n                    if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                        // Intentionally mutating since this render will get interrupted. This\n                        // is one of the very rare times where we mutate the current tree\n                        // during the render phase.\n                        suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n                        var eventTime = NoTimestamp;\n                        scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\n                    }\n                } // If we have scheduled higher pri work above, this will probably just abort the render\n                // since we now have higher priority work, but in case it doesn't, we need to prepare to\n                // render something, if we time out. Even if that requires us to delete everything and\n                // skip hydration.\n                // Delay having to do this as long as the suspense timeout allows us.\n                renderDidSuspendDelayIfPossible();\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error(\"This Suspense boundary received an update before it finished \" + \"hydrating. This caused the boundary to switch to client rendering. \" + \"The usual way to fix this is to wrap the original update \" + \"in startTransition.\"));\n            } else if (isSuspenseInstancePending(suspenseInstance)) {\n                // This component is still pending more data from the server, so we can't hydrate its\n                // content. We treat it as if this component suspended itself. It might seem as if\n                // we could just try to render it client-side instead. However, this will perform a\n                // lot of unnecessary work and is unlikely to complete since it often will suspend\n                // on missing data anyway. Additionally, the server might be able to render more\n                // than we can on the client yet. In that case we'd end up with more fallback states\n                // on the client than if we just leave it alone. If the server times out or errors\n                // these should update this boundary to the permanent Fallback state instead.\n                // Mark it as having captured (i.e. suspended).\n                workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n                workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n                var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n                registerSuspenseInstanceRetry(suspenseInstance, retry);\n                return null;\n            } else {\n                // This is the first attempt.\n                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n                var nextProps = workInProgress.pendingProps;\n                var primaryChildren = nextProps.children;\n                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n                // tree is part of a hydrating tree. This is used to determine if a child\n                // node has fully mounted yet, and for scheduling event replaying.\n                // Conceptually this is similar to Placement in that a new subtree is\n                // inserted into the React tree here. It just happens to not need DOM\n                // mutations because it already exists.\n                primaryChildFragment.flags |= Hydrating;\n                return primaryChildFragment;\n            }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n            }\n            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n            // Mark any Suspense boundaries with fallbacks as having work to do.\n            // If they were previously forced into fallbacks, they may now be able\n            // to unblock.\n            var node = firstChild;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                    }\n                } else if (node.tag === SuspenseListComponent) {\n                    // If the tail is hidden there might not be an Suspense boundaries\n                    // to schedule work on. In this case we have to schedule it on the\n                    // list itself.\n                    // We don't have to traverse to the children of the list since\n                    // the list will propagate the change when it rerenders.\n                    scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === workInProgress) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === workInProgress) {\n                        return;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function findLastContentRow(firstChild) {\n            // This is going to find the last row among these children that is already\n            // showing content on the screen, as opposed to being in fallback state or\n            // new. If a row has multiple Suspense boundaries, any of them being in the\n            // fallback state, counts as the whole row being in a fallback state.\n            // Note that the \"rows\" will be workInProgress, but any nested children\n            // will still be current since we haven't rendered them yet. The mounted\n            // order may not be the same as the new order. We use the new order.\n            var row = firstChild;\n            var lastContentRow = null;\n            while(row !== null){\n                var currentRow = row.alternate; // New rows can't be content rows.\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    lastContentRow = row;\n                }\n                row = row.sibling;\n            }\n            return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n            {\n                if (revealOrder !== undefined && revealOrder !== \"forwards\" && revealOrder !== \"backwards\" && revealOrder !== \"together\" && !didWarnAboutRevealOrder[revealOrder]) {\n                    didWarnAboutRevealOrder[revealOrder] = true;\n                    if (typeof revealOrder === \"string\") {\n                        switch(revealOrder.toLowerCase()){\n                            case \"together\":\n                            case \"forwards\":\n                            case \"backwards\":\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            case \"forward\":\n                            case \"backward\":\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            default:\n                                error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                                break;\n                        }\n                    } else {\n                        error(\"%s is not a supported value for revealOrder on <SuspenseList />. \" + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    }\n                }\n            }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n            {\n                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n                    if (tailMode !== \"collapsed\" && tailMode !== \"hidden\") {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n                    } else if (revealOrder !== \"forwards\" && revealOrder !== \"backwards\") {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n                    }\n                }\n            }\n        }\n        function validateSuspenseListNestedChild(childSlot, index) {\n            {\n                var isAnArray = isArray(childSlot);\n                var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === \"function\";\n                if (isAnArray || isIterable) {\n                    var type = isAnArray ? \"array\" : \"iterable\";\n                    error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in \" + \"an additional SuspenseList to configure its revealOrder: \" + \"<SuspenseList revealOrder=...> ... \" + \"<SuspenseList revealOrder=...>{%s}</SuspenseList> ... \" + \"</SuspenseList>\", type, index, type);\n                    return false;\n                }\n            }\n            return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n            {\n                if ((revealOrder === \"forwards\" || revealOrder === \"backwards\") && children !== undefined && children !== null && children !== false) {\n                    if (isArray(children)) {\n                        for(var i = 0; i < children.length; i++){\n                            if (!validateSuspenseListNestedChild(children[i], i)) {\n                                return;\n                            }\n                        }\n                    } else {\n                        var iteratorFn = getIteratorFn(children);\n                        if (typeof iteratorFn === \"function\") {\n                            var childrenIterator = iteratorFn.call(children);\n                            if (childrenIterator) {\n                                var step = childrenIterator.next();\n                                var _i = 0;\n                                for(; !step.done; step = childrenIterator.next()){\n                                    if (!validateSuspenseListNestedChild(step.value, _i)) {\n                                        return;\n                                    }\n                                    _i++;\n                                }\n                            }\n                        } else {\n                            error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + \"This is not useful since it needs multiple rows. \" + \"Did you mean to pass multiple children or an array?\", revealOrder);\n                        }\n                    }\n                }\n            }\n        }\n        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n            var renderState = workInProgress.memoizedState;\n            if (renderState === null) {\n                workInProgress.memoizedState = {\n                    isBackwards: isBackwards,\n                    rendering: null,\n                    renderingStartTime: 0,\n                    last: lastContentRow,\n                    tail: tail,\n                    tailMode: tailMode\n                };\n            } else {\n                // We can reuse the existing object from previous renders.\n                renderState.isBackwards = isBackwards;\n                renderState.rendering = null;\n                renderState.renderingStartTime = 0;\n                renderState.last = lastContentRow;\n                renderState.tail = tail;\n                renderState.tailMode = tailMode;\n            }\n        } // This can end up rendering this component multiple passes.\n        // The first pass splits the children fibers into two sets. A head and tail.\n        // We first render the head. If anything is in fallback state, we do another\n        // pass through beginWork to rerender all children (including the tail) with\n        // the force suspend context. If the first render didn't have anything in\n        // in fallback state. Then we render each row in the tail one-by-one.\n        // That happens in the completeWork phase without going back to beginWork.\n        function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var revealOrder = nextProps.revealOrder;\n            var tailMode = nextProps.tail;\n            var newChildren = nextProps.children;\n            validateRevealOrder(revealOrder);\n            validateTailOptions(tailMode, revealOrder);\n            validateSuspenseListChildren(newChildren, revealOrder);\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            var suspenseContext = suspenseStackCursor.current;\n            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n            if (shouldForceFallback) {\n                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n                workInProgress.flags |= DidCapture;\n            } else {\n                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n                if (didSuspendBefore) {\n                    // If we previously forced a fallback, we need to schedule work\n                    // on any nested boundaries to let them know to try to render\n                    // again. This is the same as context updating.\n                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n                }\n                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n            }\n            pushSuspenseContext(workInProgress, suspenseContext);\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                // In legacy mode, SuspenseList doesn't work so we just\n                // use make it a noop by treating it as the default revealOrder.\n                workInProgress.memoizedState = null;\n            } else {\n                switch(revealOrder){\n                    case \"forwards\":\n                        {\n                            var lastContentRow = findLastContentRow(workInProgress.child);\n                            var tail;\n                            if (lastContentRow === null) {\n                                // The whole list is part of the tail.\n                                // TODO: We could fast path by just rendering the tail now.\n                                tail = workInProgress.child;\n                                workInProgress.child = null;\n                            } else {\n                                // Disconnect the tail rows after the content row.\n                                // We're going to render them separately later.\n                                tail = lastContentRow.sibling;\n                                lastContentRow.sibling = null;\n                            }\n                            initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);\n                            break;\n                        }\n                    case \"backwards\":\n                        {\n                            // We're going to find the first row that has existing content.\n                            // At the same time we're going to reverse the list of everything\n                            // we pass in the meantime. That's going to be our tail in reverse\n                            // order.\n                            var _tail = null;\n                            var row = workInProgress.child;\n                            workInProgress.child = null;\n                            while(row !== null){\n                                var currentRow = row.alternate; // New rows can't be content rows.\n                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                                    // This is the beginning of the main content.\n                                    workInProgress.child = row;\n                                    break;\n                                }\n                                var nextRow = row.sibling;\n                                row.sibling = _tail;\n                                _tail = row;\n                                row = nextRow;\n                            } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n                            initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);\n                            break;\n                        }\n                    case \"together\":\n                        {\n                            initSuspenseListRenderState(workInProgress, false, null, null, undefined);\n                            break;\n                        }\n                    default:\n                        {\n                            // The default reveal order is the same as not having\n                            // a boundary.\n                            workInProgress.memoizedState = null;\n                        }\n                }\n            }\n            return workInProgress.child;\n        }\n        function updatePortalComponent(current, workInProgress, renderLanes) {\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            var nextChildren = workInProgress.pendingProps;\n            if (current === null) {\n                // Portals are special because we don't append the children during mount\n                // but at commit. Therefore we need to track insertions which the normal\n                // flow doesn't do during mount. This doesn't happen at the root because\n                // the root always starts with a \"current\" with a null child.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current, workInProgress, renderLanes) {\n            var providerType = workInProgress.type;\n            var context = providerType._context;\n            var newProps = workInProgress.pendingProps;\n            var oldProps = workInProgress.memoizedProps;\n            var newValue = newProps.value;\n            {\n                if (!(\"value\" in newProps)) {\n                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                        error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\");\n                    }\n                }\n                var providerPropTypes = workInProgress.type.propTypes;\n                if (providerPropTypes) {\n                    checkPropTypes(providerPropTypes, newProps, \"prop\", \"Context.Provider\");\n                }\n            }\n            pushProvider(workInProgress, context, newValue);\n            {\n                if (oldProps !== null) {\n                    var oldValue = oldProps.value;\n                    if (objectIs(oldValue, newValue)) {\n                        // No change. Bailout early if children are the same.\n                        if (oldProps.children === newProps.children && !hasContextChanged()) {\n                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                        }\n                    } else {\n                        // The context value changed. Search for matching consumers and schedule\n                        // them to update.\n                        propagateContextChange(workInProgress, context, renderLanes);\n                    }\n                }\n            }\n            var newChildren = newProps.children;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingContextAsConsumer = false;\n        function updateContextConsumer(current, workInProgress, renderLanes) {\n            var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var newProps = workInProgress.pendingProps;\n            var render = newProps.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var newValue = readContext(context);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var newChildren;\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                newChildren = render(newValue);\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n            didReceiveUpdate = true;\n        }\n        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n            if (current !== null) {\n                // Reuse previous dependencies\n                workInProgress.dependencies = current.dependencies;\n            }\n            {\n                // Don't update \"base\" render times for bailouts.\n                stopProfilerTimerIfRunning();\n            }\n            markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n                // The children don't have any work either. We can skip them.\n                // TODO: Once we add back resuming, we should check if the children are\n                // a work-in-progress set. If so, we need to transfer their effects.\n                {\n                    return null;\n                }\n            } // This fiber doesn't have work, but its subtree does. Clone the child\n            // fibers and continue.\n            cloneChildFibers(current, workInProgress);\n            return workInProgress.child;\n        }\n        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n            {\n                var returnFiber = oldWorkInProgress.return;\n                if (returnFiber === null) {\n                    // eslint-disable-next-line react-internal/prod-error-codes\n                    throw new Error(\"Cannot swap the root fiber.\");\n                } // Disconnect from the old current.\n                // It will get deleted.\n                current.alternate = null;\n                oldWorkInProgress.alternate = null; // Connect to the new tree.\n                newWorkInProgress.index = oldWorkInProgress.index;\n                newWorkInProgress.sibling = oldWorkInProgress.sibling;\n                newWorkInProgress.return = oldWorkInProgress.return;\n                newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n                if (oldWorkInProgress === returnFiber.child) {\n                    returnFiber.child = newWorkInProgress;\n                } else {\n                    var prevSibling = returnFiber.child;\n                    if (prevSibling === null) {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"Expected parent to have a child.\");\n                    }\n                    while(prevSibling.sibling !== oldWorkInProgress){\n                        prevSibling = prevSibling.sibling;\n                        if (prevSibling === null) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"Expected to find the previous sibling.\");\n                        }\n                    }\n                    prevSibling.sibling = newWorkInProgress;\n                } // Delete the old fiber and place the new one.\n                // Since the old fiber is disconnected, we have to schedule it manually.\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        current\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(current);\n                }\n                newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n                return newWorkInProgress;\n            }\n        }\n        function checkScheduledUpdateOrContext(current, renderLanes) {\n            // Before performing an early bailout, we must check if there are pending\n            // updates or context.\n            var updateLanes = current.lanes;\n            if (includesSomeLane(updateLanes, renderLanes)) {\n                return true;\n            } // No pending update, but because context is propagated lazily, we need\n            return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n            // This fiber does not have any pending work. Bailout without entering\n            // the begin phase. There's still some bookkeeping we that needs to be done\n            // in this optimized path, mostly pushing stuff onto the stack.\n            switch(workInProgress.tag){\n                case HostRoot:\n                    pushHostRootContext(workInProgress);\n                    var root = workInProgress.stateNode;\n                    resetHydrationState();\n                    break;\n                case HostComponent:\n                    pushHostContext(workInProgress);\n                    break;\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            pushContextProvider(workInProgress);\n                        }\n                        break;\n                    }\n                case HostPortal:\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    break;\n                case ContextProvider:\n                    {\n                        var newValue = workInProgress.memoizedProps.value;\n                        var context = workInProgress.type._context;\n                        pushProvider(workInProgress, context, newValue);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        // Profiler should only call onRender when one of its descendants actually rendered.\n                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (hasChildWork) {\n                            workInProgress.flags |= Update;\n                        }\n                        {\n                            // Reset effect durations for the next eventual effect phase.\n                            // These are reset during render to allow the DevTools commit hook a chance to read them,\n                            var stateNode = workInProgress.stateNode;\n                            stateNode.effectDuration = 0;\n                            stateNode.passiveEffectDuration = 0;\n                        }\n                    }\n                    break;\n                case SuspenseComponent:\n                    {\n                        var state = workInProgress.memoizedState;\n                        if (state !== null) {\n                            {\n                                if (state.dehydrated !== null) {\n                                    pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n                                    // been unsuspended it has committed as a resolved Suspense component.\n                                    // If it needs to be retried, it should have work scheduled on it.\n                                    workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n                                    // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n                                    return null;\n                                }\n                            }\n                            // whether to retry the primary children, or to skip over it and\n                            // go straight to the fallback. Check the priority of the primary\n                            // child fragment.\n                            var primaryChildFragment = workInProgress.child;\n                            var primaryChildLanes = primaryChildFragment.childLanes;\n                            if (includesSomeLane(renderLanes, primaryChildLanes)) {\n                                // The primary children have pending work. Use the normal path\n                                // to attempt to render the primary children again.\n                                return updateSuspenseComponent(current, workInProgress, renderLanes);\n                            } else {\n                                // The primary child fragment does not have pending work marked\n                                // on it\n                                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n                                // priority. Bailout.\n                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                                if (child !== null) {\n                                    // The fallback children have pending work. Skip over the\n                                    // primary children and work on the fallback.\n                                    return child.sibling;\n                                } else {\n                                    // Note: We can return `null` here because we already checked\n                                    // whether there were nested context consumers, via the call to\n                                    // `bailoutOnAlreadyFinishedWork` above.\n                                    return null;\n                                }\n                            }\n                        } else {\n                            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                        }\n                        break;\n                    }\n                case SuspenseListComponent:\n                    {\n                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (didSuspendBefore) {\n                            if (_hasChildWork) {\n                                // If something was in fallback state last time, and we have all the\n                                // same children then we're still in progressive loading state.\n                                // Something might get unblocked by state updates or retries in the\n                                // tree which will affect the tail. So we need to use the normal\n                                // path to compute the correct tail.\n                                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                            } // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            workInProgress.flags |= DidCapture;\n                        } // If nothing suspended before and we're rendering the same children,\n                        // then the tail doesn't matter. Anything new that suspends will work\n                        // in the \"together\" mode, so we can continue from the state we had.\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState !== null) {\n                            // Reset to the \"together\" mode in case we've started a different\n                            // update in the past but didn't complete it.\n                            renderState.rendering = null;\n                            renderState.tail = null;\n                            renderState.lastEffect = null;\n                        }\n                        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n                        if (_hasChildWork) {\n                            break;\n                        } else {\n                            // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            return null;\n                        }\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        // Need to check if the tree still needs to be deferred. This is\n                        // almost identical to the logic used in the normal update path,\n                        // so we'll just enter that. The only difference is we'll bail out\n                        // at the next level instead of this one, because the child props\n                        // have not changed. Which is fine.\n                        // TODO: Probably should refactor `beginWork` to split the bailout\n                        // path from the normal path. I'm tempted to do a labeled break here\n                        // but I won't :)\n                        workInProgress.lanes = NoLanes;\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n            }\n            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        function beginWork(current, workInProgress, renderLanes) {\n            {\n                if (workInProgress._debugNeedsRemount && current !== null) {\n                    // This will restart the begin phase with a new fiber.\n                    return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n                }\n            }\n            if (current !== null) {\n                var oldProps = current.memoizedProps;\n                var newProps = workInProgress.pendingProps;\n                if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) {\n                    // If props or context changed, mark the fiber as having performed work.\n                    // This may be unset if the props are determined to be equal later (memo).\n                    didReceiveUpdate = true;\n                } else {\n                    // Neither props nor legacy context changes. Check if there's a pending\n                    // update or context change.\n                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n                    if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n                    // may not be work scheduled on `current`, so we check for this flag.\n                    (workInProgress.flags & DidCapture) === NoFlags) {\n                        // No pending updates or context. Bail out now.\n                        didReceiveUpdate = false;\n                        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n                    }\n                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    } else {\n                        // An update was scheduled on this fiber, but there are no new props\n                        // nor legacy context. Set this to false. If an update queue or context\n                        // consumer produces a changed value, it will set this to true. Otherwise,\n                        // the component will assume the children have not changed and bail out.\n                        didReceiveUpdate = false;\n                    }\n                }\n            } else {\n                didReceiveUpdate = false;\n                if (getIsHydrating() && isForkedChild(workInProgress)) {\n                    // Check if this child belongs to a list of muliple children in\n                    // its parent.\n                    //\n                    // In a true multi-threaded implementation, we would render children on\n                    // parallel threads. This would represent the beginning of a new render\n                    // thread for this subtree.\n                    //\n                    // We only use this for id generation during hydration, which is why the\n                    // logic is located in this special branch.\n                    var slotIndex = workInProgress.index;\n                    var numberOfForks = getForksAtLevel();\n                    pushTreeId(workInProgress, numberOfForks, slotIndex);\n                }\n            } // Before entering the begin phase, clear pending update priority.\n            // TODO: This assumes that we're about to evaluate the component and process\n            // the update queue. However, there's an exception: SimpleMemoComponent\n            // sometimes bails out later in the begin phase. This indicates that we should\n            // move this assignment out of the common path and into each branch.\n            workInProgress.lanes = NoLanes;\n            switch(workInProgress.tag){\n                case IndeterminateComponent:\n                    {\n                        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n                    }\n                case LazyComponent:\n                    {\n                        var elementType = workInProgress.elementType;\n                        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n                    }\n                case FunctionComponent:\n                    {\n                        var Component = workInProgress.type;\n                        var unresolvedProps = workInProgress.pendingProps;\n                        var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n                        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n                    }\n                case ClassComponent:\n                    {\n                        var _Component = workInProgress.type;\n                        var _unresolvedProps = workInProgress.pendingProps;\n                        var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n                        return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);\n                    }\n                case HostRoot:\n                    return updateHostRoot(current, workInProgress, renderLanes);\n                case HostComponent:\n                    return updateHostComponent$1(current, workInProgress, renderLanes);\n                case HostText:\n                    return updateHostText$1(current, workInProgress);\n                case SuspenseComponent:\n                    return updateSuspenseComponent(current, workInProgress, renderLanes);\n                case HostPortal:\n                    return updatePortalComponent(current, workInProgress, renderLanes);\n                case ForwardRef:\n                    {\n                        var type = workInProgress.type;\n                        var _unresolvedProps2 = workInProgress.pendingProps;\n                        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n                        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);\n                    }\n                case Fragment:\n                    return updateFragment(current, workInProgress, renderLanes);\n                case Mode:\n                    return updateMode(current, workInProgress, renderLanes);\n                case Profiler:\n                    return updateProfiler(current, workInProgress, renderLanes);\n                case ContextProvider:\n                    return updateContextProvider(current, workInProgress, renderLanes);\n                case ContextConsumer:\n                    return updateContextConsumer(current, workInProgress, renderLanes);\n                case MemoComponent:\n                    {\n                        var _type2 = workInProgress.type;\n                        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n                        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n                        {\n                            if (workInProgress.type !== workInProgress.elementType) {\n                                var outerPropTypes = _type2.propTypes;\n                                if (outerPropTypes) {\n                                    checkPropTypes(outerPropTypes, _resolvedProps3, \"prop\", getComponentNameFromType(_type2));\n                                }\n                            }\n                        }\n                        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n                        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);\n                    }\n                case SimpleMemoComponent:\n                    {\n                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n                    }\n                case IncompleteClassComponent:\n                    {\n                        var _Component2 = workInProgress.type;\n                        var _unresolvedProps4 = workInProgress.pendingProps;\n                        var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n                        return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);\n                    }\n                case SuspenseListComponent:\n                    {\n                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n        }\n        function unwindWork(current, workInProgress, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            popContext(workInProgress);\n                        }\n                        var flags = workInProgress.flags;\n                        if (flags & ShouldCapture) {\n                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        popHostContainer(workInProgress);\n                        popTopLevelContextObject(workInProgress);\n                        resetWorkInProgressVersions();\n                        var _flags = workInProgress.flags;\n                        if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n                            // There was an error during render that wasn't captured by a suspense\n                            // boundary. Do a second pass on the root to unmount the children.\n                            workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n                            return workInProgress;\n                        } // We unwound to the root without completing it. Exit.\n                        return null;\n                    }\n                case HostComponent:\n                    {\n                        // TODO: popHydrationState\n                        popHostContext(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        {\n                            var suspenseState = workInProgress.memoizedState;\n                            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                                if (workInProgress.alternate === null) {\n                                    throw new Error(\"Threw in newly mounted dehydrated component. This is likely a bug in \" + \"React. Please file an issue.\");\n                                }\n                                resetHydrationState();\n                            }\n                        }\n                        var _flags2 = workInProgress.flags;\n                        if (_flags2 & ShouldCapture) {\n                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n                        // caught by a nested boundary. If not, it should bubble through.\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    return null;\n                case ContextProvider:\n                    var context = workInProgress.type._context;\n                    popProvider(context, workInProgress);\n                    return null;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popRenderLanes(workInProgress);\n                    return null;\n                case CacheComponent:\n                    return null;\n                default:\n                    return null;\n            }\n        }\n        function unwindInterruptedWork(current, interruptedWork, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(interruptedWork);\n            switch(interruptedWork.tag){\n                case ClassComponent:\n                    {\n                        var childContextTypes = interruptedWork.type.childContextTypes;\n                        if (childContextTypes !== null && childContextTypes !== undefined) {\n                            popContext(interruptedWork);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        popHostContainer(interruptedWork);\n                        popTopLevelContextObject(interruptedWork);\n                        resetWorkInProgressVersions();\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(interruptedWork);\n                        break;\n                    }\n                case HostPortal:\n                    popHostContainer(interruptedWork);\n                    break;\n                case SuspenseComponent:\n                    popSuspenseContext(interruptedWork);\n                    break;\n                case SuspenseListComponent:\n                    popSuspenseContext(interruptedWork);\n                    break;\n                case ContextProvider:\n                    var context = interruptedWork.type._context;\n                    popProvider(context, interruptedWork);\n                    break;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popRenderLanes(interruptedWork);\n                    break;\n            }\n        }\n        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n            var funcArgs = Array.prototype.slice.call(arguments, 3);\n            try {\n                func.apply(context, funcArgs);\n            } catch (error) {\n                this.onError(error);\n            }\n        }\n        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n        {\n            // In DEV mode, we swap out invokeGuardedCallback for a special version\n            // that plays more nicely with the browser's DevTools. The idea is to preserve\n            // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n            // functions in invokeGuardedCallback, and the production version of\n            // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n            // like caught exceptions, and the DevTools won't pause unless the developer\n            // takes the extra step of enabling pause on caught exceptions. This is\n            // unintuitive, though, because even though React has caught the error, from\n            // the developer's perspective, the error is uncaught.\n            //\n            // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n            // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n            // DOM node, and call the user-provided callback from inside an event handler\n            // for that fake event. If the callback throws, the error is \"captured\" using\n            // a global event handler. But because the error happens in a different\n            // event loop context, it does not interrupt the normal program flow.\n            // Effectively, this gives us try-catch behavior without actually using\n            // try-catch. Neat!\n            // Check that the browser supports the APIs we need to implement our special\n            // DEV version of invokeGuardedCallback\n            if (false) { var fakeNode; }\n        }\n        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n        var hasError = false;\n        var caughtError = null; // Used by event system to capture/rethrow the first error.\n        var reporter = {\n            onError: function(error) {\n                hasError = true;\n                caughtError = error;\n            }\n        };\n        /**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */ function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n            hasError = false;\n            caughtError = null;\n            invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n        }\n        function hasCaughtError() {\n            return hasError;\n        }\n        function clearCaughtError() {\n            if (hasError) {\n                var error = caughtError;\n                hasError = false;\n                caughtError = null;\n                return error;\n            } else {\n                throw new Error(\"clearCaughtError was called but no error was captured. This error \" + \"is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n        }\n        // Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n        // Only used when enableSuspenseLayoutEffectSemantics is enabled.\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false;\n        var PossiblyWeakSet = typeof WeakSet === \"function\" ? WeakSet : Set;\n        var nextEffect = null; // Used for Profiling builds to track updaters.\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function reportUncaughtErrorInDEV(error) {\n            // Wrapping each small part of the commit phase into a guarded\n            // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n            // But we rely on it to surface errors to DEV tools like overlays\n            // (https://github.com/facebook/react/issues/21712).\n            // As a compromise, rethrow only caught errors in a guard.\n            {\n                invokeGuardedCallback(null, function() {\n                    throw error;\n                });\n                clearCaughtError();\n            }\n        }\n        var callComponentWillUnmountWithTimer = function(current, instance) {\n            instance.props = current.memoizedProps;\n            instance.state = current.memoizedState;\n            if (current.mode & ProfileMode) {\n                try {\n                    startLayoutEffectTimer();\n                    instance.componentWillUnmount();\n                } finally{\n                    recordLayoutEffectDuration(current);\n                }\n            } else {\n                instance.componentWillUnmount();\n            }\n        }; // Capture errors so they don't interrupt mounting.\n        function safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n            try {\n                commitHookEffectListMount(Layout, current);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt unmounting.\n        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n            try {\n                callComponentWillUnmountWithTimer(current, instance);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyAttachRef(current, nearestMountedAncestor) {\n            try {\n                commitAttachRef(current);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        function safelyDetachRef(current, nearestMountedAncestor) {\n            var ref = current.ref;\n            if (ref !== null) {\n                if (typeof ref === \"function\") {\n                    var retVal;\n                    try {\n                        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                retVal = ref(null);\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            retVal = ref(null);\n                        }\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    }\n                    {\n                        if (typeof retVal === \"function\") {\n                            error(\"Unexpected return value from a callback ref in %s. \" + \"A callback ref should not return a function.\", getComponentNameFromFiber(current));\n                        }\n                    }\n                } else {\n                    ref.current = null;\n                }\n            }\n        }\n        function safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        var focusedInstanceHandle = null;\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root, firstChild) {\n            focusedInstanceHandle = prepareForCommit(root.containerInfo);\n            nextEffect = firstChild;\n            commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n            var shouldFire = shouldFireAfterActiveInstanceBlur;\n            shouldFireAfterActiveInstanceBlur = false;\n            focusedInstanceHandle = null;\n            return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitBeforeMutationEffects_complete();\n                }\n            }\n        }\n        function commitBeforeMutationEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentFiber(fiber);\n                try {\n                    commitBeforeMutationEffectsOnFiber(fiber);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags;\n            if ((flags & Snapshot) !== NoFlags) {\n                setCurrentFiber(finishedWork);\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            if (current !== null) {\n                                var prevProps = current.memoizedProps;\n                                var prevState = current.memoizedState;\n                                var instance = finishedWork.stateNode; // We could update instance props and state here,\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                {\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error(\"Expected %s props to match memoized props before \" + \"getSnapshotBeforeUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error(\"Expected %s state to match memoized state before \" + \"getSnapshotBeforeUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                    }\n                                }\n                                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n                                {\n                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                                        didWarnSet.add(finishedWork.type);\n                                        error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" + \"must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n                                    }\n                                }\n                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                            }\n                            break;\n                        }\n                    case HostRoot:\n                        {\n                            if (supportsMutation) {\n                                var root = finishedWork.stateNode;\n                                clearContainer(root.containerInfo);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                    case HostText:\n                    case HostPortal:\n                    case IncompleteClassComponent:\n                        break;\n                    default:\n                        {\n                            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n                        }\n                }\n                resetCurrentFiber();\n            }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        // Unmount\n                        var destroy = effect.destroy;\n                        effect.destroy = undefined;\n                        if (destroy !== undefined) {\n                            {\n                                if ((flags & Passive$1) !== NoFlags$1) {\n                                    markComponentPassiveEffectUnmountStarted(finishedWork);\n                                } else if ((flags & Layout) !== NoFlags$1) {\n                                    markComponentLayoutEffectUnmountStarted(finishedWork);\n                                }\n                            }\n                            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                            {\n                                if ((flags & Passive$1) !== NoFlags$1) {\n                                    markComponentPassiveEffectUnmountStopped();\n                                } else if ((flags & Layout) !== NoFlags$1) {\n                                    markComponentLayoutEffectUnmountStopped();\n                                }\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        {\n                            if ((flags & Passive$1) !== NoFlags$1) {\n                                markComponentPassiveEffectMountStarted(finishedWork);\n                            } else if ((flags & Layout) !== NoFlags$1) {\n                                markComponentLayoutEffectMountStarted(finishedWork);\n                            }\n                        }\n                        var create = effect.create;\n                        effect.destroy = create();\n                        {\n                            if ((flags & Passive$1) !== NoFlags$1) {\n                                markComponentPassiveEffectMountStopped();\n                            } else if ((flags & Layout) !== NoFlags$1) {\n                                markComponentLayoutEffectMountStopped();\n                            }\n                        }\n                        {\n                            var destroy = effect.destroy;\n                            if (destroy !== undefined && typeof destroy !== \"function\") {\n                                var hookName = void 0;\n                                if ((effect.tag & Layout) !== NoFlags) {\n                                    hookName = \"useLayoutEffect\";\n                                } else if ((effect.tag & Insertion) !== NoFlags) {\n                                    hookName = \"useInsertionEffect\";\n                                } else {\n                                    hookName = \"useEffect\";\n                                }\n                                var addendum = void 0;\n                                if (destroy === null) {\n                                    addendum = \" You returned null. If your effect does not require clean \" + \"up, return undefined (or nothing).\";\n                                } else if (typeof destroy.then === \"function\") {\n                                    addendum = \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. \" + \"Instead, write the async function inside your effect \" + \"and call it immediately:\\n\\n\" + hookName + \"(() => {\\n\" + \"  async function fetchData() {\\n\" + \"    // You can await here\\n\" + \"    const response = await MyAPI.getData(someId);\\n\" + \"    // ...\\n\" + \"  }\\n\" + \"  fetchData();\\n\" + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + \"Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching\";\n                                } else {\n                                    addendum = \" You returned: \" + destroy;\n                                }\n                                error(\"%s must not return anything besides a function, \" + \"which is used for clean-up.%s\", hookName, addendum);\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n            {\n                // Only Profilers with work in their subtree will have an Update effect scheduled.\n                if ((finishedWork.flags & Update) !== NoFlags) {\n                    switch(finishedWork.tag){\n                        case Profiler:\n                            {\n                                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n                                // It does not get reset until the start of the next commit phase.\n                                var commitTime = getCommitTime();\n                                var phase = finishedWork.alternate === null ? \"mount\" : \"update\";\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = \"nested-update\";\n                                    }\n                                }\n                                if (typeof onPostCommit === \"function\") {\n                                    onPostCommit(id, phase, passiveEffectDuration, commitTime);\n                                } // Bubble times to the next nearest ancestor Profiler.\n                                // After we process that Profiler, we'll bubble further up.\n                                var parentFiber = finishedWork.return;\n                                outer: while(parentFiber !== null){\n                                    switch(parentFiber.tag){\n                                        case HostRoot:\n                                            var root = parentFiber.stateNode;\n                                            root.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                        case Profiler:\n                                            var parentStateNode = parentFiber.stateNode;\n                                            parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                    }\n                                    parentFiber = parentFiber.return;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n            if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            if (!offscreenSubtreeWasHidden) {\n                                // At this point layout effects have already been destroyed (during mutation phase).\n                                // This is done to prevent sibling component effects from interfering with each other,\n                                // e.g. a destroy function in one component should never override a ref set\n                                // by a create function in another component during the same commit.\n                                if (finishedWork.mode & ProfileMode) {\n                                    try {\n                                        startLayoutEffectTimer();\n                                        commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                                    } finally{\n                                        recordLayoutEffectDuration(finishedWork);\n                                    }\n                                } else {\n                                    commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                                }\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = finishedWork.stateNode;\n                            if (finishedWork.flags & Update) {\n                                if (!offscreenSubtreeWasHidden) {\n                                    if (current === null) {\n                                        // We could update instance props and state here,\n                                        // but instead we rely on them being set during last render.\n                                        // TODO: revisit this when we implement resuming.\n                                        {\n                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                                if (instance.props !== finishedWork.memoizedProps) {\n                                                    error(\"Expected %s props to match memoized props before \" + \"componentDidMount. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                                if (instance.state !== finishedWork.memoizedState) {\n                                                    error(\"Expected %s state to match memoized state before \" + \"componentDidMount. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                            }\n                                        }\n                                        if (finishedWork.mode & ProfileMode) {\n                                            try {\n                                                startLayoutEffectTimer();\n                                                instance.componentDidMount();\n                                            } finally{\n                                                recordLayoutEffectDuration(finishedWork);\n                                            }\n                                        } else {\n                                            instance.componentDidMount();\n                                        }\n                                    } else {\n                                        var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n                                        var prevState = current.memoizedState; // We could update instance props and state here,\n                                        // but instead we rely on them being set during last render.\n                                        // TODO: revisit this when we implement resuming.\n                                        {\n                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                                if (instance.props !== finishedWork.memoizedProps) {\n                                                    error(\"Expected %s props to match memoized props before \" + \"componentDidUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                                if (instance.state !== finishedWork.memoizedState) {\n                                                    error(\"Expected %s state to match memoized state before \" + \"componentDidUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                            }\n                                        }\n                                        if (finishedWork.mode & ProfileMode) {\n                                            try {\n                                                startLayoutEffectTimer();\n                                                instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                                            } finally{\n                                                recordLayoutEffectDuration(finishedWork);\n                                            }\n                                        } else {\n                                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                                        }\n                                    }\n                                }\n                            } // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                {\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error(\"Expected %s props to match memoized props before \" + \"processing the update queue. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error(\"Expected %s state to match memoized state before \" + \"processing the update queue. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                    }\n                                }\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                commitUpdateQueue(finishedWork, updateQueue, instance);\n                            }\n                            break;\n                        }\n                    case HostRoot:\n                        {\n                            // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var _updateQueue = finishedWork.updateQueue;\n                            if (_updateQueue !== null) {\n                                var _instance = null;\n                                if (finishedWork.child !== null) {\n                                    switch(finishedWork.child.tag){\n                                        case HostComponent:\n                                            _instance = getPublicInstance(finishedWork.child.stateNode);\n                                            break;\n                                        case ClassComponent:\n                                            _instance = finishedWork.child.stateNode;\n                                            break;\n                                    }\n                                }\n                                commitUpdateQueue(finishedWork, _updateQueue, _instance);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n                            // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                            // These effects should only be committed when components are first mounted,\n                            // aka when there is no current/alternate.\n                            if (current === null && finishedWork.flags & Update) {\n                                var type = finishedWork.type;\n                                var props = finishedWork.memoizedProps;\n                                commitMount(_instance2, type, props, finishedWork);\n                            }\n                            break;\n                        }\n                    case HostText:\n                        {\n                            break;\n                        }\n                    case HostPortal:\n                        {\n                            break;\n                        }\n                    case Profiler:\n                        {\n                            {\n                                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                                var effectDuration = finishedWork.stateNode.effectDuration;\n                                var commitTime = getCommitTime();\n                                var phase = current === null ? \"mount\" : \"update\";\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = \"nested-update\";\n                                    }\n                                }\n                                if (typeof onRender === \"function\") {\n                                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n                                }\n                                {\n                                    if (typeof onCommit === \"function\") {\n                                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n                                    } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n                                    // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n                                    // because the effect is also where times bubble to parent Profilers.\n                                    enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n                                    // Do not reset these values until the next render so DevTools has a chance to read them first.\n                                    var parentFiber = finishedWork.return;\n                                    outer: while(parentFiber !== null){\n                                        switch(parentFiber.tag){\n                                            case HostRoot:\n                                                var root = parentFiber.stateNode;\n                                                root.effectDuration += effectDuration;\n                                                break outer;\n                                            case Profiler:\n                                                var parentStateNode = parentFiber.stateNode;\n                                                parentStateNode.effectDuration += effectDuration;\n                                                break outer;\n                                        }\n                                        parentFiber = parentFiber.return;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case SuspenseComponent:\n                        {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                            break;\n                        }\n                    case SuspenseListComponent:\n                    case IncompleteClassComponent:\n                    case ScopeComponent:\n                    case OffscreenComponent:\n                    case LegacyHiddenComponent:\n                        {\n                            break;\n                        }\n                    default:\n                        throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n                }\n            }\n            if (!offscreenSubtreeWasHidden) {\n                {\n                    if (finishedWork.flags & Ref) {\n                        commitAttachRef(finishedWork);\n                    }\n                }\n            }\n        }\n        function reappearLayoutEffectsOnFiber(node) {\n            // Turn on layout effects in a tree that previously disappeared.\n            // TODO (Offscreen) Check: flags & LayoutStatic\n            switch(node.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (node.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                safelyCallCommitHookLayoutEffectListMount(node, node.return);\n                            } finally{\n                                recordLayoutEffectDuration(node);\n                            }\n                        } else {\n                            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n                        }\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        var instance = node.stateNode;\n                        if (typeof instance.componentDidMount === \"function\") {\n                            safelyCallComponentDidMount(node, node.return, instance);\n                        }\n                        safelyAttachRef(node, node.return);\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        safelyAttachRef(node, node.return);\n                        break;\n                    }\n            }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n            // Only hide or unhide the top-most host nodes.\n            var hostSubtreeRoot = null;\n            if (supportsMutation) {\n                // We only have the top Fiber that was inserted but we need to recurse down its\n                // children to find all the terminal nodes.\n                var node = finishedWork;\n                while(true){\n                    if (node.tag === HostComponent) {\n                        if (hostSubtreeRoot === null) {\n                            hostSubtreeRoot = node;\n                            var instance = node.stateNode;\n                            if (isHidden) {\n                                hideInstance(instance);\n                            } else {\n                                unhideInstance(node.stateNode, node.memoizedProps);\n                            }\n                        }\n                    } else if (node.tag === HostText) {\n                        if (hostSubtreeRoot === null) {\n                            var _instance3 = node.stateNode;\n                            if (isHidden) {\n                                hideTextInstance(_instance3);\n                            } else {\n                                unhideTextInstance(_instance3, node.memoizedProps);\n                            }\n                        }\n                    } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === finishedWork) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === finishedWork) {\n                            return;\n                        }\n                        if (hostSubtreeRoot === node) {\n                            hostSubtreeRoot = null;\n                        }\n                        node = node.return;\n                    }\n                    if (hostSubtreeRoot === node) {\n                        hostSubtreeRoot = null;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function commitAttachRef(finishedWork) {\n            var ref = finishedWork.ref;\n            if (ref !== null) {\n                var instance = finishedWork.stateNode;\n                var instanceToUse;\n                switch(finishedWork.tag){\n                    case HostComponent:\n                        instanceToUse = getPublicInstance(instance);\n                        break;\n                    default:\n                        instanceToUse = instance;\n                } // Moved outside to ensure DCE works with this flag\n                if (typeof ref === \"function\") {\n                    var retVal;\n                    if (finishedWork.mode & ProfileMode) {\n                        try {\n                            startLayoutEffectTimer();\n                            retVal = ref(instanceToUse);\n                        } finally{\n                            recordLayoutEffectDuration(finishedWork);\n                        }\n                    } else {\n                        retVal = ref(instanceToUse);\n                    }\n                    {\n                        if (typeof retVal === \"function\") {\n                            error(\"Unexpected return value from a callback ref in %s. \" + \"A callback ref should not return a function.\", getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                } else {\n                    {\n                        if (!ref.hasOwnProperty(\"current\")) {\n                            error(\"Unexpected ref object provided for %s. \" + \"Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                    ref.current = instanceToUse;\n                }\n            }\n        }\n        function commitDetachRef(current) {\n            var currentRef = current.ref;\n            if (currentRef !== null) {\n                if (typeof currentRef === \"function\") {\n                    if (current.mode & ProfileMode) {\n                        try {\n                            startLayoutEffectTimer();\n                            currentRef(null);\n                        } finally{\n                            recordLayoutEffectDuration(current);\n                        }\n                    } else {\n                        currentRef(null);\n                    }\n                } else {\n                    currentRef.current = null;\n                }\n            }\n        } // User-originating errors (lifecycles and refs) should not interrupt\n        // deletion, so don't let them throw. Host-originating errors should\n        // interrupt deletion, so it's okay\n        function commitUnmount(finishedRoot, current, nearestMountedAncestor) {\n            onCommitUnmount(current);\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        var updateQueue = current.updateQueue;\n                        if (updateQueue !== null) {\n                            var lastEffect = updateQueue.lastEffect;\n                            if (lastEffect !== null) {\n                                var firstEffect = lastEffect.next;\n                                var effect = firstEffect;\n                                do {\n                                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;\n                                    if (destroy !== undefined) {\n                                        if ((tag & Insertion) !== NoFlags$1) {\n                                            safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                        } else if ((tag & Layout) !== NoFlags$1) {\n                                            {\n                                                markComponentLayoutEffectUnmountStarted(current);\n                                            }\n                                            if (current.mode & ProfileMode) {\n                                                startLayoutEffectTimer();\n                                                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                                recordLayoutEffectDuration(current);\n                                            } else {\n                                                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                            }\n                                            {\n                                                markComponentLayoutEffectUnmountStopped();\n                                            }\n                                        }\n                                    }\n                                    effect = effect.next;\n                                }while (effect !== firstEffect);\n                            }\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        safelyDetachRef(current, nearestMountedAncestor);\n                        var instance = current.stateNode;\n                        if (typeof instance.componentWillUnmount === \"function\") {\n                            safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance);\n                        }\n                        return;\n                    }\n                case HostComponent:\n                    {\n                        safelyDetachRef(current, nearestMountedAncestor);\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        // TODO: this is recursive.\n                        // We are also not using this parent because\n                        // the portal will get pushed immediately.\n                        if (supportsMutation) {\n                            unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n                        } else if (supportsPersistence) {\n                            emptyPortalContainer(current);\n                        }\n                        return;\n                    }\n                case DehydratedFragment:\n                    {\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        return;\n                    }\n            }\n        }\n        function commitNestedUnmounts(finishedRoot, root, nearestMountedAncestor) {\n            // While we're inside a removed host node we don't want to call\n            // removeChild on the inner nodes because they're removed by the top\n            // call anyway. We also want to call componentWillUnmount on all\n            // composites before this host node is removed from the tree. Therefore\n            // we do an inner loop while we're still inside the host node.\n            var node = root;\n            while(true){\n                commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because they may contain more composite or host nodes.\n                // Skip portals because commitUnmount() currently visits them recursively.\n                if (node.child !== null && // If we don't use mutation we drill down into portals here instead.\n                (!supportsMutation || node.tag !== HostPortal)) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === root) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === root) {\n                        return;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function detachFiberMutation(fiber) {\n            // Cut off the return pointer to disconnect it from the tree.\n            // This enables us to detect and warn against state updates on an unmounted component.\n            // It also prevents events from bubbling from within disconnected components.\n            //\n            // Ideally, we should also clear the child pointer of the parent alternate to let this\n            // get GC:ed but we don't know which for sure which parent is the current\n            // one so we'll settle for GC:ing the subtree of this child.\n            // This child itself will be GC:ed when the parent updates the next time.\n            //\n            // Note that we can't clear child or sibling pointers yet.\n            // They're needed for passive effects and for findDOMNode.\n            // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n            //\n            // Don't reset the alternate yet, either. We need that so we can detach the\n            // alternate's fields in the passive phase. Clearing the return pointer is\n            // sufficient for findDOMNode semantics.\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.return = null;\n            }\n            fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                fiber.alternate = null;\n                detachFiberAfterEffects(alternate);\n            } // Note: Defensively using negation instead of < in case\n            // `deletedTreeCleanUpLevel` is undefined.\n            {\n                // Clear cyclical Fiber fields. This level alone is designed to roughly\n                // approximate the planned Fiber refactor. In that world, `setState` will be\n                // bound to a special \"instance\" object instead of a Fiber. The Instance\n                // object will not have any of these fields. It will only be connected to\n                // the fiber tree via a single link at the root. So if this level alone is\n                // sufficient to fix memory issues, that bodes well for our plans.\n                fiber.child = null;\n                fiber.deletions = null;\n                fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n                // tree, which has its own pointers to children, parents, and siblings.\n                // The other host nodes also point back to fibers, so we should detach that\n                // one, too.\n                if (fiber.tag === HostComponent) {\n                    var hostInstance = fiber.stateNode;\n                    if (hostInstance !== null) {\n                        detachDeletedInstance(hostInstance);\n                    }\n                }\n                fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n                // already disconnect the `return` pointer at the root of the deleted\n                // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n                // cyclical — it's only cyclical when combined with `child`, `sibling`, and\n                // `alternate`. But we'll clear it in the next level anyway, just in case.\n                {\n                    fiber._debugOwner = null;\n                }\n                {\n                    // Theoretically, nothing in here should be necessary, because we already\n                    // disconnected the fiber from the tree. So even if something leaks this\n                    // particular fiber, it won't leak anything else\n                    //\n                    // The purpose of this branch is to be super aggressive so we can measure\n                    // if there's any difference in memory impact. If there is, that could\n                    // indicate a React leak we don't know about.\n                    fiber.return = null;\n                    fiber.dependencies = null;\n                    fiber.memoizedProps = null;\n                    fiber.memoizedState = null;\n                    fiber.pendingProps = null;\n                    fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n                    fiber.updateQueue = null;\n                }\n            }\n        }\n        function emptyPortalContainer(current) {\n            if (!supportsPersistence) {\n                return;\n            }\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet(containerInfo);\n            replaceContainerChildren(containerInfo, emptyChildSet);\n        }\n        function commitContainer(finishedWork) {\n            if (!supportsPersistence) {\n                return;\n            }\n            switch(finishedWork.tag){\n                case ClassComponent:\n                case HostComponent:\n                case HostText:\n                    {\n                        return;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var portalOrRoot = finishedWork.stateNode;\n                        var containerInfo = portalOrRoot.containerInfo, pendingChildren = portalOrRoot.pendingChildren;\n                        replaceContainerChildren(containerInfo, pendingChildren);\n                        return;\n                    }\n            }\n            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n        }\n        function getHostParentFiber(fiber) {\n            var parent = fiber.return;\n            while(parent !== null){\n                if (isHostParent(parent)) {\n                    return parent;\n                }\n                parent = parent.return;\n            }\n            throw new Error(\"Expected to find a host parent. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n        }\n        function isHostParent(fiber) {\n            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n            // We're going to search forward into the tree until we find a sibling host\n            // node. Unfortunately, if multiple insertions are done in a row we have to\n            // search past them. This leads to exponential search for the next sibling.\n            // TODO: Find a more efficient way to do this.\n            var node = fiber;\n            siblings: while(true){\n                // If we didn't find anything, let's try the next sibling.\n                while(node.sibling === null){\n                    if (node.return === null || isHostParent(node.return)) {\n                        // If we pop out of the root or hit the parent the fiber we are the\n                        // last sibling.\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n                while(node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment){\n                    // If it is not host node and, we might have a host node inside it.\n                    // Try to search down until we find one.\n                    if (node.flags & Placement) {\n                        continue siblings;\n                    } // If we don't have a child, try the siblings instead.\n                    // We also skip portals because they are not part of this host tree.\n                    if (node.child === null || node.tag === HostPortal) {\n                        continue siblings;\n                    } else {\n                        node.child.return = node;\n                        node = node.child;\n                    }\n                } // Check if this host node is stable or about to be placed.\n                if (!(node.flags & Placement)) {\n                    // Found it!\n                    return node.stateNode;\n                }\n            }\n        }\n        function commitPlacement(finishedWork) {\n            if (!supportsMutation) {\n                return;\n            } // Recursively insert all host nodes into the parent.\n            var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n            switch(parentFiber.tag){\n                case HostComponent:\n                    {\n                        var parent = parentFiber.stateNode;\n                        if (parentFiber.flags & ContentReset) {\n                            // Reset the text content of the parent before doing any insertions\n                            resetTextContent(parent); // Clear ContentReset from the effect tag\n                            parentFiber.flags &= ~ContentReset;\n                        }\n                        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                        // children to find all the terminal nodes.\n                        insertOrAppendPlacementNode(finishedWork, before, parent);\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var _parent = parentFiber.stateNode.containerInfo;\n                        var _before = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n                        break;\n                    }\n                // eslint-disable-next-line-no-fallthrough\n                default:\n                    throw new Error(\"Invalid host parent fiber. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n            }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertInContainerBefore(parent, stateNode, before);\n                } else {\n                    appendChildToContainer(parent, stateNode);\n                }\n            } else if (tag === HostPortal) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertBefore(parent, stateNode, before);\n                } else {\n                    appendChild(parent, stateNode);\n                }\n            } else if (tag === HostPortal) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNode(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNode(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function unmountHostComponents(finishedRoot, current, nearestMountedAncestor) {\n            // We only have the top Fiber that was deleted but we need to recurse down its\n            // children to find all the terminal nodes.\n            var node = current; // Each iteration, currentParent is populated with node's host parent if not\n            // currentParentIsValid.\n            var currentParentIsValid = false; // Note: these two variables *must* always be updated together.\n            var currentParent;\n            var currentParentIsContainer;\n            while(true){\n                if (!currentParentIsValid) {\n                    var parent = node.return;\n                    findParent: while(true){\n                        if (parent === null) {\n                            throw new Error(\"Expected to find a host parent. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n                        }\n                        var parentStateNode = parent.stateNode;\n                        switch(parent.tag){\n                            case HostComponent:\n                                currentParent = parentStateNode;\n                                currentParentIsContainer = false;\n                                break findParent;\n                            case HostRoot:\n                                currentParent = parentStateNode.containerInfo;\n                                currentParentIsContainer = true;\n                                break findParent;\n                            case HostPortal:\n                                currentParent = parentStateNode.containerInfo;\n                                currentParentIsContainer = true;\n                                break findParent;\n                        }\n                        parent = parent.return;\n                    }\n                    currentParentIsValid = true;\n                }\n                if (node.tag === HostComponent || node.tag === HostText) {\n                    commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor); // After all the children have unmounted, it is now safe to remove the\n                    // node from the tree.\n                    if (currentParentIsContainer) {\n                        removeChildFromContainer(currentParent, node.stateNode);\n                    } else {\n                        removeChild(currentParent, node.stateNode);\n                    } // Don't visit children because we already visited them.\n                } else if (node.tag === DehydratedFragment) {\n                    if (currentParentIsContainer) {\n                        clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);\n                    } else {\n                        clearSuspenseBoundary(currentParent, node.stateNode);\n                    }\n                } else if (node.tag === HostPortal) {\n                    if (node.child !== null) {\n                        // When we go into a portal, it becomes the parent to remove from.\n                        // We will reassign it back when we pop the portal on the way up.\n                        currentParent = node.stateNode.containerInfo;\n                        currentParentIsContainer = true; // Visit children because portals might contain host components.\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                } else {\n                    commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because we may find more host components below.\n                    if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                }\n                if (node === current) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === current) {\n                        return;\n                    }\n                    node = node.return;\n                    if (node.tag === HostPortal) {\n                        // When we go out of the portal, we need to restore the parent.\n                        // Since we don't keep a stack of them, we will search for it.\n                        currentParentIsValid = false;\n                    }\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function commitDeletion(finishedRoot, current, nearestMountedAncestor) {\n            if (supportsMutation) {\n                // Recursively delete all host nodes from the parent.\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n            } else {\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                commitNestedUnmounts(finishedRoot, current, nearestMountedAncestor);\n            }\n            detachFiberMutation(current);\n        }\n        function commitWork(current, finishedWork) {\n            if (!supportsMutation) {\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                            commitHookEffectListMount(Insertion | HasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n                            // destroy functions for all fibers are called before any create functions.\n                            // This prevents sibling component effects from interfering with each other,\n                            // e.g. a destroy function in one component should never override a ref set\n                            // by a create function in another component during the same commit.\n                            // TODO: Check if we're inside an Offscreen subtree that disappeared\n                            // during this commit. If so, we would have already unmounted its\n                            // layout hooks. (However, since we null out the `destroy` function\n                            // right before calling it, the behavior is already correct, so this\n                            // would mostly be for modeling purposes.)\n                            if (finishedWork.mode & ProfileMode) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } finally{\n                                    recordLayoutEffectDuration(finishedWork);\n                                }\n                            } else {\n                                commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                            }\n                            return;\n                        }\n                    case Profiler:\n                        {\n                            return;\n                        }\n                    case SuspenseComponent:\n                        {\n                            commitSuspenseCallback(finishedWork);\n                            attachSuspenseRetryListeners(finishedWork);\n                            return;\n                        }\n                    case SuspenseListComponent:\n                        {\n                            attachSuspenseRetryListeners(finishedWork);\n                            return;\n                        }\n                    case HostRoot:\n                        {\n                            if (supportsHydration) {\n                                if (current !== null) {\n                                    var prevRootState = current.memoizedState;\n                                    if (prevRootState.isDehydrated) {\n                                        var root = finishedWork.stateNode;\n                                        commitHydratedContainer(root.containerInfo);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case OffscreenComponent:\n                    case LegacyHiddenComponent:\n                        {\n                            return;\n                        }\n                }\n                commitContainer(finishedWork);\n                return;\n            }\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                        commitHookEffectListMount(Insertion | HasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n                        // destroy functions for all fibers are called before any create functions.\n                        // This prevents sibling component effects from interfering with each other,\n                        // e.g. a destroy function in one component should never override a ref set\n                        // by a create function in another component during the same commit.\n                        if (finishedWork.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                            } finally{\n                                recordLayoutEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        return;\n                    }\n                case HostComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        if (instance != null) {\n                            // Commit the work prepared earlier.\n                            var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                            // as the newProps. The updatePayload will contain the real change in\n                            // this case.\n                            var oldProps = current !== null ? current.memoizedProps : newProps;\n                            var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n                            var updatePayload = finishedWork.updateQueue;\n                            finishedWork.updateQueue = null;\n                            if (updatePayload !== null) {\n                                commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                            }\n                        }\n                        return;\n                    }\n                case HostText:\n                    {\n                        if (finishedWork.stateNode === null) {\n                            throw new Error(\"This should have a text node initialized. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                        }\n                        var textInstance = finishedWork.stateNode;\n                        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                        // as the newProps. The updatePayload will contain the real change in\n                        // this case.\n                        var oldText = current !== null ? current.memoizedProps : newText;\n                        commitTextUpdate(textInstance, oldText, newText);\n                        return;\n                    }\n                case HostRoot:\n                    {\n                        if (supportsHydration) {\n                            if (current !== null) {\n                                var _prevRootState = current.memoizedState;\n                                if (_prevRootState.isDehydrated) {\n                                    var _root = finishedWork.stateNode;\n                                    commitHydratedContainer(_root.containerInfo);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case Profiler:\n                    {\n                        return;\n                    }\n                case SuspenseComponent:\n                    {\n                        commitSuspenseCallback(finishedWork);\n                        attachSuspenseRetryListeners(finishedWork);\n                        return;\n                    }\n                case SuspenseListComponent:\n                    {\n                        attachSuspenseRetryListeners(finishedWork);\n                        return;\n                    }\n                case IncompleteClassComponent:\n                    {\n                        return;\n                    }\n            }\n            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n        }\n        function commitSuspenseCallback(finishedWork) {\n            // TODO: Move this to passive phase\n            var newState = finishedWork.memoizedState;\n        }\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n            if (!supportsHydration) {\n                return;\n            }\n            var newState = finishedWork.memoizedState;\n            if (newState === null) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        var suspenseInstance = prevState.dehydrated;\n                        if (suspenseInstance !== null) {\n                            commitHydratedSuspenseInstance(suspenseInstance);\n                        }\n                    }\n                }\n            }\n        }\n        function attachSuspenseRetryListeners(finishedWork) {\n            // If this boundary just timed out, then it will have a set of wakeables.\n            // For each wakeable, attach a listener so that when it resolves, React\n            // attempts to re-render the boundary in the primary (pre-timeout) state.\n            var wakeables = finishedWork.updateQueue;\n            if (wakeables !== null) {\n                finishedWork.updateQueue = null;\n                var retryCache = finishedWork.stateNode;\n                if (retryCache === null) {\n                    retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n                }\n                wakeables.forEach(function(wakeable) {\n                    // Memoize using the boundary fiber to prevent redundant listeners.\n                    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n                    if (!retryCache.has(wakeable)) {\n                        retryCache.add(wakeable);\n                        {\n                            if (isDevToolsPresent) {\n                                if (inProgressLanes !== null && inProgressRoot !== null) {\n                                    // If we have pending work still, associate the original updaters with it.\n                                    restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                                } else {\n                                    throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                                }\n                            }\n                        }\n                        wakeable.then(retry, retry);\n                    }\n                });\n            }\n        } // This function detects when a Suspense boundary goes from visible to hidden.\n        function commitResetTextContent(current) {\n            if (!supportsMutation) {\n                return;\n            }\n            resetTextContent(current.stateNode);\n        }\n        function commitMutationEffects(root, firstChild, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            nextEffect = firstChild;\n            commitMutationEffects_begin(root, committedLanes);\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function commitMutationEffects_begin(root, lanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // TODO: Should wrap this in flags check, too, as optimization\n                var deletions = fiber.deletions;\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i];\n                        try {\n                            commitDeletion(root, childToDelete, fiber);\n                        } catch (error) {\n                            reportUncaughtErrorInDEV(error);\n                            captureCommitPhaseError(childToDelete, fiber, error);\n                        }\n                    }\n                }\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitMutationEffects_complete(root, lanes);\n                }\n            }\n        }\n        function commitMutationEffects_complete(root, lanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentFiber(fiber);\n                try {\n                    commitMutationEffectsOnFiber(fiber, root, lanes);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n            // TODO: The factoring of this phase could probably be improved. Consider\n            // switching on the type of work before checking the flags. That's what\n            // we do in all the other phases. I think this one is only different\n            // because of the shared reconciliation logic below.\n            var flags = finishedWork.flags;\n            if (flags & ContentReset) {\n                commitResetTextContent(finishedWork);\n            }\n            if (flags & Ref) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    commitDetachRef(current);\n                }\n            }\n            if (flags & Visibility) {\n                switch(finishedWork.tag){\n                    case SuspenseComponent:\n                        {\n                            var newState = finishedWork.memoizedState;\n                            var isHidden = newState !== null;\n                            if (isHidden) {\n                                var _current = finishedWork.alternate;\n                                var wasHidden = _current !== null && _current.memoizedState !== null;\n                                if (!wasHidden) {\n                                    // TODO: Move to passive phase\n                                    markCommitTimeOfFallback();\n                                }\n                            }\n                            break;\n                        }\n                    case OffscreenComponent:\n                        {\n                            var _newState = finishedWork.memoizedState;\n                            var _isHidden = _newState !== null;\n                            var _current2 = finishedWork.alternate;\n                            var _wasHidden = _current2 !== null && _current2.memoizedState !== null;\n                            var offscreenBoundary = finishedWork;\n                            if (supportsMutation) {\n                                // TODO: This needs to run whenever there's an insertion or update\n                                // inside a hidden Offscreen tree.\n                                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n                            }\n                            {\n                                if (_isHidden) {\n                                    if (!_wasHidden) {\n                                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                                            nextEffect = offscreenBoundary;\n                                            var offscreenChild = offscreenBoundary.child;\n                                            while(offscreenChild !== null){\n                                                nextEffect = offscreenChild;\n                                                disappearLayoutEffects_begin(offscreenChild);\n                                                offscreenChild = offscreenChild.sibling;\n                                            }\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                }\n            } // The following switch statement is only concerned about placement,\n            // updates, and deletions. To avoid needing to add a case for every possible\n            // bitmap value, we remove the secondary effects from the effect tag and\n            // switch on that value.\n            var primaryFlags = flags & (Placement | Update | Hydrating);\n            switch(primaryFlags){\n                case Placement:\n                    {\n                        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n                        // inserted, before any life-cycles like componentDidMount gets called.\n                        // TODO: findDOMNode doesn't rely on this any more but isMounted does\n                        // and isMounted is deprecated anyway so we should be able to kill this.\n                        finishedWork.flags &= ~Placement;\n                        break;\n                    }\n                case PlacementAndUpdate:\n                    {\n                        // Placement\n                        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n                        // inserted, before any life-cycles like componentDidMount gets called.\n                        finishedWork.flags &= ~Placement; // Update\n                        var _current3 = finishedWork.alternate;\n                        commitWork(_current3, finishedWork);\n                        break;\n                    }\n                case Hydrating:\n                    {\n                        finishedWork.flags &= ~Hydrating;\n                        break;\n                    }\n                case HydratingAndUpdate:\n                    {\n                        finishedWork.flags &= ~Hydrating; // Update\n                        var _current4 = finishedWork.alternate;\n                        commitWork(_current4, finishedWork);\n                        break;\n                    }\n                case Update:\n                    {\n                        var _current5 = finishedWork.alternate;\n                        commitWork(_current5, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitLayoutEffects(finishedWork, root, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            nextEffect = finishedWork;\n            commitLayoutEffects_begin(finishedWork, root, committedLanes);\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n            // Suspense layout effects semantics don't change for legacy roots.\n            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if (fiber.tag === OffscreenComponent && isModernRoot) {\n                    // Keep track of the current Offscreen stack's state.\n                    var isHidden = fiber.memoizedState !== null;\n                    var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n                    if (newOffscreenSubtreeIsHidden) {\n                        // The Offscreen tree is hidden. Skip over its layout effects.\n                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                        continue;\n                    } else {\n                        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n                        var current = fiber.alternate;\n                        var wasHidden = current !== null && current.memoizedState !== null;\n                        var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n                        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                            // This is the root of a reappearing boundary. Turn its layout effects\n                            // back on.\n                            nextEffect = fiber;\n                            reappearLayoutEffects_begin(fiber);\n                        }\n                        var child = firstChild;\n                        while(child !== null){\n                            nextEffect = child;\n                            commitLayoutEffects_begin(child, root, committedLanes);\n                            child = child.sibling;\n                        } // Restore Offscreen state and resume in our-progress traversal.\n                        nextEffect = fiber;\n                        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                        continue;\n                    }\n                }\n                if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n                    ensureCorrectReturnPointer(firstChild, fiber);\n                    nextEffect = firstChild;\n                } else {\n                    commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                }\n            }\n        }\n        function commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & LayoutMask) !== NoFlags) {\n                    var current = fiber.alternate;\n                    setCurrentFiber(fiber);\n                    try {\n                        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(fiber, fiber.return, error);\n                    }\n                    resetCurrentFiber();\n                }\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function disappearLayoutEffects_begin(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if (fiber.mode & ProfileMode) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                                } finally{\n                                    recordLayoutEffectDuration(fiber);\n                                }\n                            } else {\n                                commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            // TODO (Offscreen) Check: flags & RefStatic\n                            safelyDetachRef(fiber, fiber.return);\n                            var instance = fiber.stateNode;\n                            if (typeof instance.componentWillUnmount === \"function\") {\n                                safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            safelyDetachRef(fiber, fiber.return);\n                            break;\n                        }\n                    case OffscreenComponent:\n                        {\n                            // Check if this is a\n                            var isHidden = fiber.memoizedState !== null;\n                            if (isHidden) {\n                                // Nested Offscreen tree is already hidden. Don't disappear\n                                // its effects.\n                                disappearLayoutEffects_complete(subtreeRoot);\n                                continue;\n                            }\n                            break;\n                        }\n                } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n                if (firstChild !== null) {\n                    firstChild.return = fiber;\n                    nextEffect = firstChild;\n                } else {\n                    disappearLayoutEffects_complete(subtreeRoot);\n                }\n            }\n        }\n        function disappearLayoutEffects_complete(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function reappearLayoutEffects_begin(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if (fiber.tag === OffscreenComponent) {\n                    var isHidden = fiber.memoizedState !== null;\n                    if (isHidden) {\n                        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n                        reappearLayoutEffects_complete(subtreeRoot);\n                        continue;\n                    }\n                } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n                if (firstChild !== null) {\n                    // This node may have been reused from a previous render, so we can't\n                    // assume its return pointer is correct.\n                    firstChild.return = fiber;\n                    nextEffect = firstChild;\n                } else {\n                    reappearLayoutEffects_complete(subtreeRoot);\n                }\n            }\n        }\n        function reappearLayoutEffects_complete(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n                setCurrentFiber(fiber);\n                try {\n                    reappearLayoutEffectsOnFiber(fiber);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    // This node may have been reused from a previous render, so we can't\n                    // assume its return pointer is correct.\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveMountEffects(root, finishedWork) {\n            nextEffect = finishedWork;\n            commitPassiveMountEffects_begin(finishedWork, root);\n        }\n        function commitPassiveMountEffects_begin(subtreeRoot, root) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n                    ensureCorrectReturnPointer(firstChild, fiber);\n                    nextEffect = firstChild;\n                } else {\n                    commitPassiveMountEffects_complete(subtreeRoot, root);\n                }\n            }\n        }\n        function commitPassiveMountEffects_complete(subtreeRoot, root) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & Passive) !== NoFlags) {\n                    setCurrentFiber(fiber);\n                    try {\n                        commitPassiveMountOnFiber(root, fiber);\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(fiber, fiber.return, error);\n                    }\n                    resetCurrentFiber();\n                }\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (finishedWork.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            try {\n                                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n                            } finally{\n                                recordPassiveEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n                        }\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffects(firstChild) {\n            nextEffect = firstChild;\n            commitPassiveUnmountEffects_begin();\n        }\n        function commitPassiveUnmountEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var child = fiber.child;\n                if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n                    var deletions = fiber.deletions;\n                    if (deletions !== null) {\n                        for(var i = 0; i < deletions.length; i++){\n                            var fiberToDelete = deletions[i];\n                            nextEffect = fiberToDelete;\n                            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n                        }\n                        {\n                            // A fiber was deleted from this parent fiber, but it's still part of\n                            // the previous (alternate) parent fiber's list of children. Because\n                            // children are a linked list, an earlier sibling that's still alive\n                            // will be connected to the deleted fiber via its `alternate`:\n                            //\n                            //   live fiber\n                            //   --alternate--> previous live fiber\n                            //   --sibling--> deleted fiber\n                            //\n                            // We can't disconnect `alternate` on nodes that haven't been deleted\n                            // yet, but we can disconnect the `sibling` and `child` pointers.\n                            var previousFiber = fiber.alternate;\n                            if (previousFiber !== null) {\n                                var detachedChild = previousFiber.child;\n                                if (detachedChild !== null) {\n                                    previousFiber.child = null;\n                                    do {\n                                        var detachedSibling = detachedChild.sibling;\n                                        detachedChild.sibling = null;\n                                        detachedChild = detachedSibling;\n                                    }while (detachedChild !== null);\n                                }\n                            }\n                        }\n                        nextEffect = fiber;\n                    }\n                }\n                if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffects_complete();\n                }\n            }\n        }\n        function commitPassiveUnmountEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & Passive) !== NoFlags) {\n                    setCurrentFiber(fiber);\n                    commitPassiveUnmountOnFiber(fiber);\n                    resetCurrentFiber();\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (finishedWork.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n                            recordPassiveEffectDuration(finishedWork);\n                        } else {\n                            commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // Deletion effects fire in parent -> child order\n                // TODO: Check if fiber has a PassiveStatic flag\n                setCurrentFiber(fiber);\n                commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n                resetCurrentFiber();\n                var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n                // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n                if (child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n                }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var sibling = fiber.sibling;\n                var returnFiber = fiber.return;\n                {\n                    // Recursively traverse the entire deleted tree and clean up fiber fields.\n                    // This is more aggressive than ideal, and the long term goal is to only\n                    // have to detach the deleted tree at the root.\n                    detachFiberAfterEffects(fiber);\n                    if (fiber === deletedSubtreeRoot) {\n                        nextEffect = null;\n                        return;\n                    }\n                }\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, returnFiber);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (current.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n                            recordPassiveEffectDuration(current);\n                        } else {\n                            commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n                        }\n                        break;\n                    }\n            }\n        }\n        var didWarnWrongReturnPointer = false;\n        function ensureCorrectReturnPointer(fiber, expectedReturnFiber) {\n            {\n                if (!didWarnWrongReturnPointer && fiber.return !== expectedReturnFiber) {\n                    didWarnWrongReturnPointer = true;\n                    error(\"Internal React error: Return pointer is inconsistent \" + \"with parent.\");\n                }\n            }\n            // anything, by checking the warning logs for the above invariant\n            fiber.return = expectedReturnFiber;\n        } // TODO: Reuse reappearLayoutEffects traversal here?\n        function invokeLayoutEffectMountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListMount(Layout | HasEffect, fiber);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = fiber.stateNode;\n                            try {\n                                instance.componentDidMount();\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokePassiveEffectMountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokeLayoutEffectUnmountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = fiber.stateNode;\n                            if (typeof instance.componentWillUnmount === \"function\") {\n                                safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokePassiveEffectUnmountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                        }\n                }\n            }\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === \"function\" && Symbol.for) {\n            var symbolFor = Symbol.for;\n            COMPONENT_TYPE = symbolFor(\"selector.component\");\n            HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n            ROLE_TYPE = symbolFor(\"selector.role\");\n            TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n            TEXT_TYPE = symbolFor(\"selector.text\");\n        }\n        function createComponentSelector(component) {\n            return {\n                $$typeof: COMPONENT_TYPE,\n                value: component\n            };\n        }\n        function createHasPseudoClassSelector(selectors) {\n            return {\n                $$typeof: HAS_PSEUDO_CLASS_TYPE,\n                value: selectors\n            };\n        }\n        function createRoleSelector(role) {\n            return {\n                $$typeof: ROLE_TYPE,\n                value: role\n            };\n        }\n        function createTextSelector(text) {\n            return {\n                $$typeof: TEXT_TYPE,\n                value: text\n            };\n        }\n        function createTestNameSelector(id) {\n            return {\n                $$typeof: TEST_NAME_TYPE,\n                value: id\n            };\n        }\n        function findFiberRootForHostRoot(hostRoot) {\n            var maybeFiber = getInstanceFromNode(hostRoot);\n            if (maybeFiber != null) {\n                if (typeof maybeFiber.memoizedProps[\"data-testname\"] !== \"string\") {\n                    throw new Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n                }\n                return maybeFiber;\n            } else {\n                var fiberRoot = findFiberRoot(hostRoot);\n                if (fiberRoot === null) {\n                    throw new Error(\"Could not find React container within specified host subtree.\");\n                } // The Flow type for FiberRoot is a little funky.\n                // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n                return fiberRoot.stateNode.current;\n            }\n        }\n        function matchSelector(fiber, selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    if (fiber.type === selector.value) {\n                        return true;\n                    }\n                    break;\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return hasMatchingPaths(fiber, selector.value);\n                case ROLE_TYPE:\n                    if (fiber.tag === HostComponent) {\n                        var node = fiber.stateNode;\n                        if (matchAccessibilityRole(node, selector.value)) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEXT_TYPE:\n                    if (fiber.tag === HostComponent || fiber.tag === HostText) {\n                        var textContent = getTextContent(fiber);\n                        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEST_NAME_TYPE:\n                    if (fiber.tag === HostComponent) {\n                        var dataTestID = fiber.memoizedProps[\"data-testname\"];\n                        if (typeof dataTestID === \"string\" && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n                            return true;\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error(\"Invalid selector type specified.\");\n            }\n            return false;\n        }\n        function selectorToString(selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    var displayName = getComponentNameFromType(selector.value) || \"Unknown\";\n                    return \"<\" + displayName + \">\";\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n                case ROLE_TYPE:\n                    return '[role=\"' + selector.value + '\"]';\n                case TEXT_TYPE:\n                    return '\"' + selector.value + '\"';\n                case TEST_NAME_TYPE:\n                    return '[data-testname=\"' + selector.value + '\"]';\n                default:\n                    throw new Error(\"Invalid selector type specified.\");\n            }\n        }\n        function findPaths(root, selectors) {\n            var matchingFibers = [];\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    matchingFibers.push(fiber);\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return matchingFibers;\n        } // Same as findPaths but with eager bailout on first match\n        function hasMatchingPaths(root, selectors) {\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    return true;\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return false;\n        }\n        function findAllNodes(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var instanceRoots = [];\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var node = stack[index++];\n                if (node.tag === HostComponent) {\n                    if (isHiddenSubtree(node)) {\n                        continue;\n                    }\n                    instanceRoots.push(node.stateNode);\n                } else {\n                    var child = node.child;\n                    while(child !== null){\n                        stack.push(child);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return instanceRoots;\n        }\n        function getFindAllNodesFailureDescription(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var maxSelectorIndex = 0;\n            var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else if (matchSelector(fiber, selector)) {\n                    matchedNames.push(selectorToString(selector));\n                    selectorIndex++;\n                    if (selectorIndex > maxSelectorIndex) {\n                        maxSelectorIndex = selectorIndex;\n                    }\n                }\n                if (selectorIndex < selectors.length) {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            if (maxSelectorIndex < selectors.length) {\n                var unmatchedNames = [];\n                for(var i = maxSelectorIndex; i < selectors.length; i++){\n                    unmatchedNames.push(selectorToString(selectors[i]));\n                }\n                return \"findAllNodes was able to match part of the selector:\\n\" + (\"  \" + matchedNames.join(\" > \") + \"\\n\\n\") + \"No matching component was found for:\\n\" + (\"  \" + unmatchedNames.join(\" > \"));\n            }\n            return null;\n        }\n        function findBoundingRects(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var boundingRects = [];\n            for(var i = 0; i < instanceRoots.length; i++){\n                boundingRects.push(getBoundingRect(instanceRoots[i]));\n            }\n            for(var _i = boundingRects.length - 1; _i > 0; _i--){\n                var targetRect = boundingRects[_i];\n                var targetLeft = targetRect.x;\n                var targetRight = targetLeft + targetRect.width;\n                var targetTop = targetRect.y;\n                var targetBottom = targetTop + targetRect.height;\n                for(var j = _i - 1; j >= 0; j--){\n                    if (_i !== j) {\n                        var otherRect = boundingRects[j];\n                        var otherLeft = otherRect.x;\n                        var otherRight = otherLeft + otherRect.width;\n                        var otherTop = otherRect.y;\n                        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n                        // but we can handle the most common cases:\n                        // 1. completely overlapping rects\n                        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n                        //\n                        // Even given the above constraints,\n                        // we still won't end up with the fewest possible rects without doing multiple passes,\n                        // but it's good enough for this purpose.\n                        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                            // Complete overlapping rects; remove the inner one.\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n                            // Adjacent vertical rects; merge them.\n                            if (otherTop > targetTop) {\n                                otherRect.height += otherTop - targetTop;\n                                otherRect.y = targetTop;\n                            }\n                            if (otherBottom < targetBottom) {\n                                otherRect.height = targetBottom - otherTop;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n                            // Adjacent horizontal rects; merge them.\n                            if (otherLeft > targetLeft) {\n                                otherRect.width += otherLeft - targetLeft;\n                                otherRect.x = targetLeft;\n                            }\n                            if (otherRight < targetRight) {\n                                otherRect.width = targetRight - otherLeft;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            return boundingRects;\n        }\n        function focusWithin(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                if (isHiddenSubtree(fiber)) {\n                    continue;\n                }\n                if (fiber.tag === HostComponent) {\n                    var node = fiber.stateNode;\n                    if (setFocusIfFocusable(node)) {\n                        return true;\n                    }\n                }\n                var child = fiber.child;\n                while(child !== null){\n                    stack.push(child);\n                    child = child.sibling;\n                }\n            }\n            return false;\n        }\n        var commitHooks = [];\n        function onCommitRoot$1() {\n            if (supportsTestSelectors) {\n                commitHooks.forEach(function(commitHook) {\n                    return commitHook();\n                });\n            }\n        }\n        function observeVisibleRects(hostRoot, selectors, callback, options) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n            var commitHook = function() {\n                var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n                instanceRoots.forEach(function(target) {\n                    if (nextInstanceRoots.indexOf(target) < 0) {\n                        unobserve(target);\n                    }\n                });\n                nextInstanceRoots.forEach(function(target) {\n                    if (instanceRoots.indexOf(target) < 0) {\n                        observe(target);\n                    }\n                });\n            };\n            commitHooks.push(commitHook);\n            return {\n                disconnect: function() {\n                    // Stop listening for React mutations:\n                    var index = commitHooks.indexOf(commitHook);\n                    if (index >= 0) {\n                        commitHooks.splice(index, 1);\n                    } // Disconnect the host observer:\n                    disconnect();\n                }\n            };\n        }\n        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\n        function isLegacyActEnvironment(fiber) {\n            {\n                // Legacy mode. We preserve the behavior of React 17's act. It assumes an\n                // act environment whenever `jest` is defined, but you can still turn off\n                // spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n                // to false.\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : undefined; // $FlowExpectedError - Flow doesn't know about jest\n                var jestIsDefined = typeof jest !== \"undefined\";\n                return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;\n            }\n        }\n        function isConcurrentActEnvironment() {\n            {\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : undefined;\n                if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n                    // TODO: Include link to relevant documentation page.\n                    error(\"The current testing environment is not configured to support \" + \"act(...)\");\n                }\n                return isReactActEnvironmentGlobal;\n            }\n        }\n        var ceil = Math.ceil;\n        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\n        var NoContext = /*             */ 0;\n        var BatchedContext = /*               */ 1;\n        var RenderContext = /*                */ 2;\n        var CommitContext = /*                */ 4;\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6; // Describes where we are in the React execution stack\n        var executionContext = NoContext; // The root we're working on\n        var workInProgressRoot = null; // The fiber we're working on\n        var workInProgress = null; // The lanes we're rendering\n        var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n        // This is a superset of the lanes we started working on at the root. The only\n        // case where it's different from `workInProgressRootRenderLanes` is when we\n        // enter a subtree that is hidden and needs to be unhidden: Suspense and\n        // Offscreen component.\n        //\n        // Most things in the work loop should deal with workInProgressRootRenderLanes.\n        // Most things in begin/complete phases should deal with subtreeRenderLanes.\n        var subtreeRenderLanes = NoLanes;\n        var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n        var workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n        var workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n        // slightly different than `renderLanes` because `renderLanes` can change as you\n        // enter and exit an Offscreen tree. This value is the combination of all render\n        // lanes for the entire render phase.\n        var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\n        // includes unprocessed updates, not work in bailed out children.\n        var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n        var workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n        var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n        // We will log them once the tree commits.\n        var workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n        // model where we don't commit new loading states in too quick succession.\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n        // more and prefer CPU suspense heuristics instead.\n        var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n        // suspense heuristics and opt out of rendering more content.\n        var RENDER_TIMEOUT_MS = 500;\n        function resetRenderTimer() {\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n            return workInProgressRootRenderTargetTime;\n        }\n        var hasUncaughtError = false;\n        var firstUncaughtError = null;\n        var legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0; // If two updates are scheduled within the same event, we should treat their\n        // event times as simultaneous, even if the actual clock time has advanced\n        // between the first and second call.\n        var currentEventTime = NoTimestamp;\n        var currentEventTransitionLane = NoLanes;\n        function getWorkInProgressRoot() {\n            return workInProgressRoot;\n        }\n        function requestEventTime() {\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                // We're inside React, so it's fine to read the actual time.\n                return now$1();\n            } // We're not inside React, so we may be in the middle of a browser event.\n            if (currentEventTime !== NoTimestamp) {\n                // Use the same start time for all updates until we enter React again.\n                return currentEventTime;\n            } // This is the first update since React yielded. Compute a new start time.\n            currentEventTime = now$1();\n            return currentEventTime;\n        }\n        function requestUpdateLane(fiber) {\n            // Special cases\n            var mode = fiber.mode;\n            if ((mode & ConcurrentMode) === NoMode) {\n                return SyncLane;\n            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n                // This is a render phase update. These are not officially supported. The\n                // old behavior is to give this the same \"thread\" (lanes) as\n                // whatever is currently rendering. So if you call `setState` on a component\n                // that happens later in the same render, it will flush. Ideally, we want to\n                // remove the special case and treat them as if they came from an\n                // interleaved event. Regardless, this pattern is not officially supported.\n                // This behavior is only a fallback. The flag only exists until we can roll\n                // out the setState warning, since existing code might accidentally rely on\n                // the current behavior.\n                return pickArbitraryLane(workInProgressRootRenderLanes);\n            }\n            var isTransition = requestCurrentTransition() !== NoTransition;\n            if (isTransition) {\n                if (ReactCurrentBatchConfig$2.transition !== null) {\n                    var transition = ReactCurrentBatchConfig$2.transition;\n                    if (!transition._updatedFibers) {\n                        transition._updatedFibers = new Set();\n                    }\n                    transition._updatedFibers.add(fiber);\n                } // The algorithm for assigning an update to a lane should be stable for all\n                // updates at the same priority within the same event. To do this, the\n                // inputs to the algorithm must be the same.\n                //\n                // The trick we use is to cache the first of each of these inputs within an\n                // event. Then reset the cached values once we can be sure the event is\n                // over. Our heuristic for that is whenever we enter a concurrent work loop.\n                if (currentEventTransitionLane === NoLane) {\n                    // All transitions within the same event are assigned the same lane.\n                    currentEventTransitionLane = claimNextTransitionLane();\n                }\n                return currentEventTransitionLane;\n            } // Updates originating inside certain React methods, like flushSync, have\n            // their priority set by tracking it with a context variable.\n            //\n            // The opaque type returned by the host config is internally a lane, so we can\n            // use that directly.\n            // TODO: Move this type conversion to the event priority module.\n            var updateLane = getCurrentUpdatePriority();\n            if (updateLane !== NoLane) {\n                return updateLane;\n            } // This update originated outside React. Ask the host environment for an\n            // appropriate priority, based on the type of event.\n            //\n            // The opaque type returned by the host config is internally a lane, so we can\n            // use that directly.\n            // TODO: Move this type conversion to the event priority module.\n            var eventLane = getCurrentEventPriority();\n            return eventLane;\n        }\n        function requestRetryLane(fiber) {\n            // This is a fork of `requestUpdateLane` designed specifically for Suspense\n            // \"retries\" — a special update that attempts to flip a Suspense boundary\n            // from its placeholder state to its primary/resolved state.\n            // Special cases\n            var mode = fiber.mode;\n            if ((mode & ConcurrentMode) === NoMode) {\n                return SyncLane;\n            }\n            return claimNextRetryLane();\n        }\n        function scheduleUpdateOnFiber(fiber, lane, eventTime) {\n            checkForNestedUpdates();\n            var root = markUpdateLaneFromFiberToRoot(fiber, lane);\n            if (root === null) {\n                return null;\n            } // Mark that the root has a pending update.\n            markRootUpdated(root, lane, eventTime);\n            if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n                // This update was dispatched during the render phase. This is a mistake\n                // if the update originates from user space (with the exception of local\n                // hook updates, which are handled differently and don't reach this\n                // function), but there are some internal React features that use this as\n                // an implementation detail, like selective hydration.\n                warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n            } else {\n                // This is a normal update, scheduled from outside the render phase. For\n                // example, during an input event.\n                {\n                    if (isDevToolsPresent) {\n                        addFiberToLanesMap(root, fiber, lane);\n                    }\n                }\n                warnIfUpdatesNotWrappedWithActDEV(fiber);\n                if (root === workInProgressRoot) {\n                    // TODO: Consolidate with `isInterleavedUpdate` check\n                    // Received an update to a tree that's in the middle of rendering. Mark\n                    // that there was an interleaved update work on this root. Unless the\n                    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n                    // phase update. In that case, we don't treat render phase updates as if\n                    // they were interleaved, for backwards compat reasons.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n                    }\n                    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                        // The root already suspended with a delay, which means this render\n                        // definitely won't finish. Since we have a new update, let's mark it as\n                        // suspended now, right before marking the incoming update. This has the\n                        // effect of interrupting the current render and switching to the update.\n                        // TODO: Make sure this doesn't override pings that happen while we've\n                        // already started rendering.\n                        markRootSuspended$1(root, workInProgressRootRenderLanes);\n                    }\n                }\n                ensureRootIsScheduled(root, eventTime);\n                if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n                !ReactCurrentActQueue$1.isBatchingLegacy) {\n                    // Flush the synchronous work now, unless we're already working or inside\n                    // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                    // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                    // without immediately flushing it. We only do this for user-initiated\n                    // updates, to preserve historical behavior of legacy mode.\n                    resetRenderTimer();\n                    flushSyncCallbacksOnlyInLegacyMode();\n                }\n            }\n            return root;\n        }\n        function scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n            // This is a special fork of scheduleUpdateOnFiber that is only used to\n            // schedule the initial hydration of a root that has just been created. Most\n            // of the stuff in scheduleUpdateOnFiber can be skipped.\n            //\n            // The main reason for this separate path, though, is to distinguish the\n            // initial children from subsequent updates. In fully client-rendered roots\n            // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n            // updates, but hydration roots are special because the initial render must\n            // match what was rendered on the server.\n            var current = root.current;\n            current.lanes = lane;\n            markRootUpdated(root, lane, eventTime);\n            ensureRootIsScheduled(root, eventTime);\n        } // This is split into a separate function so we can mark a fiber with pending\n        // work without treating it as a typical update that originates from an event;\n        // e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n        // on a fiber.\n        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n            // Update the source fiber's lanes\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n            var alternate = sourceFiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            }\n            {\n                if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n            }\n            var node = sourceFiber;\n            var parent = sourceFiber.return;\n            while(parent !== null){\n                parent.childLanes = mergeLanes(parent.childLanes, lane);\n                alternate = parent.alternate;\n                if (alternate !== null) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n                } else {\n                    {\n                        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n                            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                        }\n                    }\n                }\n                node = parent;\n                parent = parent.return;\n            }\n            if (node.tag === HostRoot) {\n                var root = node.stateNode;\n                return root;\n            } else {\n                return null;\n            }\n        }\n        function isInterleavedUpdate(fiber, lane) {\n            return(// Requires some refactoring. Not a big deal though since it's rare for\n            // concurrent apps to have more than a single root.\n            workInProgressRoot !== null && (fiber.mode & ConcurrentMode) !== NoMode && // then don't treat this as an interleaved update. This pattern is\n            // accompanied by a warning but we haven't fully deprecated it yet. We can\n            // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n            (executionContext & RenderContext) === NoContext);\n        } // Use this function to schedule a task for a root. There's only one task per\n        // root; if a task was already scheduled, we'll check to make sure the priority\n        // of the existing task is the same as the priority of the next level that the\n        // root has work on. This function is called on every update, and right before\n        // exiting a task.\n        function ensureRootIsScheduled(root, currentTime) {\n            var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n            // expired so we know to work on those next.\n            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (nextLanes === NoLanes) {\n                // Special case: There's nothing to work on.\n                if (existingCallbackNode !== null) {\n                    cancelCallback$1(existingCallbackNode);\n                }\n                root.callbackNode = null;\n                root.callbackPriority = NoLane;\n                return;\n            } // We use the highest priority lane to represent the priority of the callback.\n            var newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n            var existingCallbackPriority = root.callbackPriority;\n            if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n            // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n            // on the `act` queue.\n            !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n                {\n                    // If we're going to re-use an existing task, it needs to exist.\n                    // Assume that discrete update microtasks are non-cancellable and null.\n                    // TODO: Temporary until we confirm this warning is not fired.\n                    if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n                        error(\"Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.\");\n                    }\n                }\n                return;\n            }\n            if (existingCallbackNode != null) {\n                // Cancel the existing callback. We'll schedule a new one below.\n                cancelCallback$1(existingCallbackNode);\n            } // Schedule a new callback.\n            var newCallbackNode;\n            if (newCallbackPriority === SyncLane) {\n                // Special case: Sync React callbacks are scheduled on a special\n                // internal queue\n                if (root.tag === LegacyRoot) {\n                    if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n                        ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n                    }\n                    scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n                } else {\n                    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n                }\n                if (supportsMicrotasks) {\n                    // Flush the queue in a microtask.\n                    if (ReactCurrentActQueue$1.current !== null) {\n                        // Inside `act`, use our internal `act` queue so that these get flushed\n                        // at the end of the current scope even when using the sync version\n                        // of `act`.\n                        ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n                    } else {\n                        scheduleMicrotask(function() {\n                            // In Safari, appending an iframe forces microtasks to run.\n                            // https://github.com/facebook/react/issues/22459\n                            // We don't support running callbacks in the middle of render\n                            // or commit so we need to check against that.\n                            if (executionContext === NoContext) {\n                                // It's only safe to do this conditionally because we always\n                                // check for pending work before we exit the task.\n                                flushSyncCallbacks();\n                            }\n                        });\n                    }\n                } else {\n                    // Flush the queue in an Immediate task.\n                    scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);\n                }\n                newCallbackNode = null;\n            } else {\n                var schedulerPriorityLevel;\n                switch(lanesToEventPriority(nextLanes)){\n                    case DiscreteEventPriority:\n                        schedulerPriorityLevel = ImmediatePriority;\n                        break;\n                    case ContinuousEventPriority:\n                        schedulerPriorityLevel = UserBlockingPriority;\n                        break;\n                    case DefaultEventPriority:\n                        schedulerPriorityLevel = NormalPriority;\n                        break;\n                    case IdleEventPriority:\n                        schedulerPriorityLevel = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriorityLevel = NormalPriority;\n                        break;\n                }\n                newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n            }\n            root.callbackPriority = newCallbackPriority;\n            root.callbackNode = newCallbackNode;\n        } // This is the entry point for every concurrent task, i.e. anything that\n        // goes through Scheduler.\n        function performConcurrentWorkOnRoot(root, didTimeout) {\n            {\n                resetNestedUpdateFlag();\n            }\n            // event time. The next update will compute a new event time.\n            currentEventTime = NoTimestamp;\n            currentEventTransitionLane = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            } // Flush any pending passive effects before deciding which lanes to work on,\n            // in case they schedule additional work.\n            var originalCallbackNode = root.callbackNode;\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // Something in the passive effect phase may have canceled the current task.\n                // Check if the task node for this root was changed.\n                if (root.callbackNode !== originalCallbackNode) {\n                    // The current task was canceled. Exit. We don't need to call\n                    // `ensureRootIsScheduled` because the check above implies either that\n                    // there's a new task, or that there's no remaining work on this root.\n                    return null;\n                }\n            } // Determine the next lanes to work on, using the fields stored\n            // on the root.\n            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (lanes === NoLanes) {\n                // Defensive coding. This is never expected to happen.\n                return null;\n            } // We disable time-slicing in some cases: if the work has been CPU-bound\n            // for too long (\"expired\" work, to prevent starvation), or we're in\n            // sync-updates-by-default mode.\n            // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n            // bug we're still investigating. Once the bug in Scheduler is fixed,\n            // we can remove this, since we track expiration ourselves.\n            var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;\n            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n            if (exitStatus !== RootInProgress) {\n                if (exitStatus === RootErrored) {\n                    // If something threw an error, try rendering one more time. We'll\n                    // render synchronously to block concurrent data mutations, and we'll\n                    // includes all pending updates are included. If it still fails after\n                    // the second attempt, we'll give up and commit the resulting tree.\n                    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                    if (errorRetryLanes !== NoLanes) {\n                        lanes = errorRetryLanes;\n                        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    var fatalError = workInProgressRootFatalError;\n                    prepareFreshStack(root, NoLanes);\n                    markRootSuspended$1(root, lanes);\n                    ensureRootIsScheduled(root, now$1());\n                    throw fatalError;\n                }\n                if (exitStatus === RootDidNotComplete) {\n                    // The render unwound without completing the tree. This happens in special\n                    // cases where need to exit the current render without producing a\n                    // consistent tree or committing.\n                    //\n                    // This should only happen during a concurrent render, not a discrete or\n                    // synchronous update. We should have already checked for this when we\n                    // unwound the stack.\n                    markRootSuspended$1(root, lanes);\n                } else {\n                    // The render completed.\n                    // Check if this render may have yielded to a concurrent event, and if so,\n                    // confirm that any newly rendered stores are consistent.\n                    // TODO: It's possible that even a concurrent render may never have yielded\n                    // to the main thread, if it was fast enough, or if it expired. We could\n                    // skip the consistency check in that case, too.\n                    var renderWasConcurrent = !includesBlockingLane(root, lanes);\n                    var finishedWork = root.current.alternate;\n                    if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                        // A store was mutated in an interleaved event. Render again,\n                        // synchronously, to block further mutations.\n                        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n                        if (exitStatus === RootErrored) {\n                            var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                            if (_errorRetryLanes !== NoLanes) {\n                                lanes = _errorRetryLanes;\n                                exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n                            // concurrent events.\n                            }\n                        }\n                        if (exitStatus === RootFatalErrored) {\n                            var _fatalError = workInProgressRootFatalError;\n                            prepareFreshStack(root, NoLanes);\n                            markRootSuspended$1(root, lanes);\n                            ensureRootIsScheduled(root, now$1());\n                            throw _fatalError;\n                        }\n                    } // We now have a consistent tree. The next step is either to commit it,\n                    // or, if something suspended, wait to commit it after a timeout.\n                    root.finishedWork = finishedWork;\n                    root.finishedLanes = lanes;\n                    finishConcurrentRender(root, exitStatus, lanes);\n                }\n            }\n            ensureRootIsScheduled(root, now$1());\n            if (root.callbackNode === originalCallbackNode) {\n                // The task node scheduled for this root is the same one that's\n                // currently executed. Need to return a continuation.\n                return performConcurrentWorkOnRoot.bind(null, root);\n            }\n            return null;\n        }\n        function recoverFromConcurrentError(root, errorRetryLanes) {\n            // If an error occurred during hydration, discard server response and fall\n            // back to client side render.\n            // Before rendering again, save the errors from the previous attempt.\n            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n            if (isRootDehydrated(root)) {\n                // The shell failed to hydrate. Set a flag to force a client rendering\n                // during the next attempt. To do this, we call prepareFreshStack now\n                // to create the root work-in-progress fiber. This is a bit weird in terms\n                // of factoring, because it relies on renderRootSync not calling\n                // prepareFreshStack again in the call below, which happens because the\n                // root and lanes haven't changed.\n                //\n                // TODO: I think what we should do is set ForceClientRender inside\n                // throwException, like we do for nested Suspense boundaries. The reason\n                // it's here instead is so we can switch to the synchronous work loop, too.\n                // Something to consider for a future refactor.\n                var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n                rootWorkInProgress.flags |= ForceClientRender;\n                {\n                    errorHydratingContainer(root.containerInfo);\n                }\n            }\n            var exitStatus = renderRootSync(root, errorRetryLanes);\n            if (exitStatus !== RootErrored) {\n                // Successfully finished rendering on retry\n                // The errors from the failed first attempt have been recovered. Add\n                // them to the collection of recoverable errors. We'll log them in the\n                // commit phase.\n                var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n                workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n                // from the first attempt, to preserve the causal sequence.\n                if (errorsFromSecondAttempt !== null) {\n                    queueRecoverableErrors(errorsFromSecondAttempt);\n                }\n            }\n            return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n            if (workInProgressRootRecoverableErrors === null) {\n                workInProgressRootRecoverableErrors = errors;\n            } else {\n                workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n            }\n        }\n        function finishConcurrentRender(root, exitStatus, lanes) {\n            switch(exitStatus){\n                case RootInProgress:\n                case RootFatalErrored:\n                    {\n                        throw new Error(\"Root did not complete. This is a bug in React.\");\n                    }\n                // Flow knows about invariant, so it complains if I add a break\n                // statement, but eslint doesn't know about invariant, so it complains\n                // if I do. eslint-disable-next-line no-fallthrough\n                case RootErrored:\n                    {\n                        // We should have already attempted to retry this tree. If we reached\n                        // this point, it errored again. Commit it.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootSuspended:\n                    {\n                        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we\n                        // should immediately commit it or wait a bit.\n                        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n                        !shouldForceFlushFallbacksInDEV()) {\n                            // This render only included retries, no updates. Throttle committing\n                            // retries so that we don't show too many loading states too quickly.\n                            var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(); // Don't bother with a very short suspense time.\n                            if (msUntilTimeout > 10) {\n                                var nextLanes = getNextLanes(root, NoLanes);\n                                if (nextLanes !== NoLanes) {\n                                    break;\n                                }\n                                var suspendedLanes = root.suspendedLanes;\n                                if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n                                    // We should prefer to render the fallback of at the last\n                                    // suspended level. Ping the last suspended level to try\n                                    // rendering it again.\n                                    // FIXME: What if the suspended lanes are Idle? Should not restart.\n                                    var eventTime = requestEventTime();\n                                    markRootPinged(root, suspendedLanes);\n                                    break;\n                                } // The render is suspended, it hasn't timed out, and there's no\n                                // lower priority work to do. Instead of committing the fallback\n                                // immediately, wait for more data to arrive.\n                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), msUntilTimeout);\n                                break;\n                            }\n                        } // The work expired. Commit immediately.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootSuspendedWithDelay:\n                    {\n                        markRootSuspended$1(root, lanes);\n                        if (includesOnlyTransitions(lanes)) {\n                            break;\n                        }\n                        if (!shouldForceFlushFallbacksInDEV()) {\n                            // This is not a transition, but we did trigger an avoided state.\n                            // Schedule a placeholder to display after a short delay, using the Just\n                            // Noticeable Difference.\n                            // TODO: Is the JND optimization worth the added complexity? If this is\n                            // the only reason we track the event time, then probably not.\n                            // Consider removing.\n                            var mostRecentEventTime = getMostRecentEventTime(root, lanes);\n                            var eventTimeMs = mostRecentEventTime;\n                            var timeElapsedMs = now$1() - eventTimeMs;\n                            var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n                            if (_msUntilTimeout > 10) {\n                                // Instead of committing the fallback immediately, wait for more data\n                                // to arrive.\n                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), _msUntilTimeout);\n                                break;\n                            }\n                        } // Commit the placeholder.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootCompleted:\n                    {\n                        // The work completed. Ready to commit.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown root exit status.\");\n                    }\n            }\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n            // Search the rendered tree for external store reads, and check whether the\n            // stores were mutated in a concurrent event. Intentionally using an iterative\n            // loop instead of recursion so we can exit early.\n            var node = finishedWork;\n            while(true){\n                if (node.flags & StoreConsistency) {\n                    var updateQueue = node.updateQueue;\n                    if (updateQueue !== null) {\n                        var checks = updateQueue.stores;\n                        if (checks !== null) {\n                            for(var i = 0; i < checks.length; i++){\n                                var check = checks[i];\n                                var getSnapshot = check.getSnapshot;\n                                var renderedValue = check.value;\n                                try {\n                                    if (!objectIs(getSnapshot(), renderedValue)) {\n                                        // Found an inconsistent store.\n                                        return false;\n                                    }\n                                } catch (error) {\n                                    // If `getSnapshot` throws, return `false`. This will schedule\n                                    // a re-render, and the error will be rethrown during render.\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                }\n                var child = node.child;\n                if (node.subtreeFlags & StoreConsistency && child !== null) {\n                    child.return = node;\n                    node = child;\n                    continue;\n                }\n                if (node === finishedWork) {\n                    return true;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === finishedWork) {\n                        return true;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            } // Flow doesn't know this is unreachable, but eslint does\n            // eslint-disable-next-line no-unreachable\n            return true;\n        }\n        function markRootSuspended$1(root, suspendedLanes) {\n            // When suspending, we should always exclude lanes that were pinged or (more\n            // rarely, since we try to avoid it) updated during the render phase.\n            // TODO: Lol maybe there's a better way to factor this besides this\n            // obnoxiously named function :)\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n            markRootSuspended(root, suspendedLanes);\n        } // This is the entry point for synchronous tasks that don't go\n        // through Scheduler\n        function performSyncWorkOnRoot(root) {\n            {\n                syncNestedUpdateFlag();\n            }\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            }\n            flushPassiveEffects();\n            var lanes = getNextLanes(root, NoLanes);\n            if (!includesSomeLane(lanes, SyncLane)) {\n                // There's no remaining sync work left.\n                ensureRootIsScheduled(root, now$1());\n                return null;\n            }\n            var exitStatus = renderRootSync(root, lanes);\n            if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n                // If something threw an error, try rendering one more time. We'll render\n                // synchronously to block concurrent data mutations, and we'll includes\n                // all pending updates are included. If it still fails after the second\n                // attempt, we'll give up and commit the resulting tree.\n                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                if (errorRetryLanes !== NoLanes) {\n                    lanes = errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n                }\n            }\n            if (exitStatus === RootFatalErrored) {\n                var fatalError = workInProgressRootFatalError;\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended$1(root, lanes);\n                ensureRootIsScheduled(root, now$1());\n                throw fatalError;\n            }\n            if (exitStatus === RootDidNotComplete) {\n                throw new Error(\"Root did not complete. This is a bug in React.\");\n            } // We now have a consistent tree. Because this is a sync render, we\n            // will commit it even if something suspended.\n            var finishedWork = root.current.alternate;\n            root.finishedWork = finishedWork;\n            root.finishedLanes = lanes;\n            commitRoot(root, workInProgressRootRecoverableErrors); // Before exiting, make sure there's a callback scheduled for the next\n            // pending level.\n            ensureRootIsScheduled(root, now$1());\n            return null;\n        }\n        function flushRoot(root, lanes) {\n            if (lanes !== NoLanes) {\n                markRootEntangled(root, mergeLanes(lanes, SyncLane));\n                ensureRootIsScheduled(root, now$1());\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    resetRenderTimer();\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function deferredUpdates(fn) {\n            var previousPriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DefaultEventPriority);\n                return fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n            }\n        }\n        function batchedUpdates(fn, a) {\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            try {\n                return fn(a);\n            } finally{\n                executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n                // most batchedUpdates-like method.\n                if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n                !ReactCurrentActQueue$1.isBatchingLegacy) {\n                    resetRenderTimer();\n                    flushSyncCallbacksOnlyInLegacyMode();\n                }\n            }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n            var previousPriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                return fn(a, b, c, d);\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                if (executionContext === NoContext) {\n                    resetRenderTimer();\n                }\n            }\n        } // Overload the definition to the two valid signatures.\n        // Warning, this opts-out of checking the function body.\n        // eslint-disable-next-line no-redeclare\n        function flushSync(fn) {\n            // In legacy mode, we flush pending passive effects at the beginning of the\n            // next event, not at the end of the previous one.\n            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushPassiveEffects();\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                if (fn) {\n                    return fn();\n                } else {\n                    return undefined;\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n                // Note that this will happen even if batchedUpdates is higher up\n                // the stack.\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function isAlreadyRendering() {\n            // Used by the renderer to print a warning if certain APIs are called from\n            // the wrong context.\n            return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        function flushControlled(fn) {\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                executionContext = prevExecutionContext;\n                if (executionContext === NoContext) {\n                    // Flush the immediate callbacks that were scheduled during this batch\n                    resetRenderTimer();\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function pushRenderLanes(fiber, lanes) {\n            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n        }\n        function popRenderLanes(fiber) {\n            subtreeRenderLanes = subtreeRenderLanesCursor.current;\n            pop(subtreeRenderLanesCursor, fiber);\n        }\n        function prepareFreshStack(root, lanes) {\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            var timeoutHandle = root.timeoutHandle;\n            if (timeoutHandle !== noTimeout) {\n                // The root previous suspended and scheduled a timeout to commit a fallback\n                // state. Now that we have additional work, cancel the timeout.\n                root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n                cancelTimeout(timeoutHandle);\n            }\n            if (workInProgress !== null) {\n                var interruptedWork = workInProgress.return;\n                while(interruptedWork !== null){\n                    var current = interruptedWork.alternate;\n                    unwindInterruptedWork(current, interruptedWork);\n                    interruptedWork = interruptedWork.return;\n                }\n            }\n            workInProgressRoot = root;\n            var rootWorkInProgress = createWorkInProgress(root.current, null);\n            workInProgress = rootWorkInProgress;\n            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n            workInProgressRootExitStatus = RootInProgress;\n            workInProgressRootFatalError = null;\n            workInProgressRootSkippedLanes = NoLanes;\n            workInProgressRootInterleavedUpdatedLanes = NoLanes;\n            workInProgressRootPingedLanes = NoLanes;\n            workInProgressRootConcurrentErrors = null;\n            workInProgressRootRecoverableErrors = null;\n            enqueueInterleavedUpdates();\n            {\n                ReactStrictModeWarnings.discardPendingWarnings();\n            }\n            return rootWorkInProgress;\n        }\n        function handleError(root, thrownValue) {\n            do {\n                var erroredWork = workInProgress;\n                try {\n                    // Reset module-level state that was set during the render phase.\n                    resetContextDependencies();\n                    resetHooksAfterThrow();\n                    resetCurrentFiber(); // TODO: I found and added this missing line while investigating a\n                    // separate issue. Write a regression test using string refs.\n                    ReactCurrentOwner$2.current = null;\n                    if (erroredWork === null || erroredWork.return === null) {\n                        // Expected to be working on a non-root fiber. This is a fatal error\n                        // because there's no ancestor that can handle it; the root is\n                        // supposed to capture all errors that weren't caught by an error\n                        // boundary.\n                        workInProgressRootExitStatus = RootFatalErrored;\n                        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n                        // sibling, or the parent if there are no siblings. But since the root\n                        // has no siblings nor a parent, we set it to null. Usually this is\n                        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n                        // intentionally not calling those, we need set it here.\n                        // TODO: Consider calling `unwindWork` to pop the contexts.\n                        workInProgress = null;\n                        return;\n                    }\n                    if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n                        // Record the time spent rendering before an error was thrown. This\n                        // avoids inaccurate Profiler durations in the case of a\n                        // suspended render.\n                        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n                    }\n                    if (enableSchedulingProfiler) {\n                        markComponentRenderStopped();\n                        if (thrownValue !== null && typeof thrownValue === \"object\" && typeof thrownValue.then === \"function\") {\n                            var wakeable = thrownValue;\n                            markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                        } else {\n                            markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                        }\n                    }\n                    throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n                    completeUnitOfWork(erroredWork);\n                } catch (yetAnotherThrownValue) {\n                    // Something in the return path also threw.\n                    thrownValue = yetAnotherThrownValue;\n                    if (workInProgress === erroredWork && erroredWork !== null) {\n                        // If this boundary has already errored, then we had trouble processing\n                        // the error. Bubble it to the next boundary.\n                        erroredWork = erroredWork.return;\n                        workInProgress = erroredWork;\n                    } else {\n                        erroredWork = workInProgress;\n                    }\n                    continue;\n                } // Return to the normal work loop.\n                return;\n            }while (true);\n        }\n        function pushDispatcher() {\n            var prevDispatcher = ReactCurrentDispatcher$2.current;\n            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n            if (prevDispatcher === null) {\n                // The React isomorphic package does not include a default dispatcher.\n                // Instead the first renderer will lazily attach one, in order to give\n                // nicer error messages.\n                return ContextOnlyDispatcher;\n            } else {\n                return prevDispatcher;\n            }\n        }\n        function popDispatcher(prevDispatcher) {\n            ReactCurrentDispatcher$2.current = prevDispatcher;\n        }\n        function markCommitTimeOfFallback() {\n            globalMostRecentFallbackTime = now$1();\n        }\n        function markSkippedUpdateLanes(lane) {\n            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootSuspended;\n            }\n        }\n        function renderDidSuspendDelayIfPossible() {\n            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n                workInProgressRootExitStatus = RootSuspendedWithDelay;\n            } // Check if there are updates that we skipped tree that might have unblocked\n            // this render.\n            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n                // Mark the current render as suspended so that we switch to working on\n                // the updates that were skipped. Usually we only suspend at the end of\n                // the render phase.\n                // TODO: We should probably always mark the root as suspended immediately\n                // (inside this function), since by suspending at the end of the render\n                // phase introduces a potential mistake where we suspend lanes that were\n                // pinged or updated while we were rendering.\n                markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n            }\n        }\n        function renderDidError(error) {\n            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n                workInProgressRootExitStatus = RootErrored;\n            }\n            if (workInProgressRootConcurrentErrors === null) {\n                workInProgressRootConcurrentErrors = [\n                    error\n                ];\n            } else {\n                workInProgressRootConcurrentErrors.push(error);\n            }\n        } // Called during render to determine if anything has suspended.\n        // Returns false if we're not sure.\n        function renderHasNotSuspendedYet() {\n            // If something errored or completed, we can't really be sure,\n            // so those are false.\n            return workInProgressRootExitStatus === RootInProgress;\n        }\n        function renderRootSync(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            do {\n                try {\n                    workLoopSync();\n                    break;\n                } catch (thrownValue) {\n                    handleError(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            executionContext = prevExecutionContext;\n            popDispatcher(prevDispatcher);\n            if (workInProgress !== null) {\n                // This is a sync render, so we should have finished the whole tree.\n                throw new Error(\"Cannot commit an incomplete root. This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n            }\n            {\n                markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes;\n            return workInProgressRootExitStatus;\n        } // The work loop is an extremely hot path. Tell Closure not to inline it.\n        /** @noinline */ function workLoopSync() {\n            // Already timed out, so perform work without checking if we need to yield.\n            while(workInProgress !== null){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function renderRootConcurrent(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                resetRenderTimer();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            do {\n                try {\n                    workLoopConcurrent();\n                    break;\n                } catch (thrownValue) {\n                    handleError(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            popDispatcher(prevDispatcher);\n            executionContext = prevExecutionContext;\n            if (workInProgress !== null) {\n                // Still work remaining.\n                {\n                    markRenderYielded();\n                }\n                return RootInProgress;\n            } else {\n                // Completed the tree.\n                {\n                    markRenderStopped();\n                }\n                workInProgressRoot = null;\n                workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n                return workInProgressRootExitStatus;\n            }\n        }\n        /** @noinline */ function workLoopConcurrent() {\n            // Perform work until Scheduler asks us to yield\n            while(workInProgress !== null && !shouldYield()){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function performUnitOfWork(unitOfWork) {\n            // The current, flushed, state of this fiber is the alternate. Ideally\n            // nothing should rely on this, but relying on it here means that we don't\n            // need an additional field on the work in progress.\n            var current = unitOfWork.alternate;\n            setCurrentFiber(unitOfWork);\n            var next;\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n                startProfilerTimer(unitOfWork);\n                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } else {\n                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n            }\n            resetCurrentFiber();\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n            ReactCurrentOwner$2.current = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n            // Attempt to complete the current unit of work, then move to the next\n            // sibling. If there are no more siblings, return to the parent fiber.\n            var completedWork = unitOfWork;\n            do {\n                // The current, flushed, state of this fiber is the alternate. Ideally\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = completedWork.alternate;\n                var returnFiber = completedWork.return; // Check if the work completed or if something threw.\n                if ((completedWork.flags & Incomplete) === NoFlags) {\n                    setCurrentFiber(completedWork);\n                    var next = void 0;\n                    if ((completedWork.mode & ProfileMode) === NoMode) {\n                        next = completeWork(current, completedWork, subtreeRenderLanes);\n                    } else {\n                        startProfilerTimer(completedWork);\n                        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                    }\n                    resetCurrentFiber();\n                    if (next !== null) {\n                        // Completing this fiber spawned new work. Work on that next.\n                        workInProgress = next;\n                        return;\n                    }\n                } else {\n                    // This fiber did not complete because something threw. Pop values off\n                    // the stack without entering the complete phase. If this is a boundary,\n                    // capture values if possible.\n                    var _next = unwindWork(current, completedWork); // Because this fiber did not complete, don't reset its lanes.\n                    if (_next !== null) {\n                        // If completing this work spawned new work, do that next. We'll come\n                        // back here again.\n                        // Since we're restarting, remove anything that is not a host effect\n                        // from the effect tag.\n                        _next.flags &= HostEffectMask;\n                        workInProgress = _next;\n                        return;\n                    }\n                    if ((completedWork.mode & ProfileMode) !== NoMode) {\n                        // Record the render duration for the fiber that errored.\n                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n                        var actualDuration = completedWork.actualDuration;\n                        var child = completedWork.child;\n                        while(child !== null){\n                            actualDuration += child.actualDuration;\n                            child = child.sibling;\n                        }\n                        completedWork.actualDuration = actualDuration;\n                    }\n                    if (returnFiber !== null) {\n                        // Mark the parent fiber as incomplete and clear its subtree flags.\n                        returnFiber.flags |= Incomplete;\n                        returnFiber.subtreeFlags = NoFlags;\n                        returnFiber.deletions = null;\n                    } else {\n                        // We've unwound all the way to the root.\n                        workInProgressRootExitStatus = RootDidNotComplete;\n                        workInProgress = null;\n                        return;\n                    }\n                }\n                var siblingFiber = completedWork.sibling;\n                if (siblingFiber !== null) {\n                    // If there is more work to do in this returnFiber, do that next.\n                    workInProgress = siblingFiber;\n                    return;\n                } // Otherwise, return to the parent\n                completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = completedWork;\n            }while (completedWork !== null); // We've reached the root.\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootCompleted;\n            }\n        }\n        function commitRoot(root, recoverableErrors) {\n            // TODO: This no longer makes any sense. We already wrap the mutation and\n            // layout phases. Should be able to remove.\n            var previousUpdateLanePriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                commitRootImpl(root, recoverableErrors, previousUpdateLanePriority);\n            } finally{\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                setCurrentUpdatePriority(previousUpdateLanePriority);\n            }\n            return null;\n        }\n        function commitRootImpl(root, recoverableErrors, renderPriorityLevel) {\n            do {\n                // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n                // means `flushPassiveEffects` will sometimes result in additional\n                // passive effects. So we need to keep flushing in a loop until there are\n                // no more pending effects.\n                // TODO: Might be better if `flushPassiveEffects` did not automatically\n                // flush synchronous work at the end, to avoid factoring hazards like this.\n                flushPassiveEffects();\n            }while (rootWithPendingPassiveEffects !== null);\n            flushRenderPhaseStrictModeWarningsInDEV();\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            }\n            var finishedWork = root.finishedWork;\n            var lanes = root.finishedLanes;\n            {\n                markCommitStarted(lanes);\n            }\n            if (finishedWork === null) {\n                {\n                    markCommitStopped();\n                }\n                return null;\n            } else {\n                {\n                    if (lanes === NoLanes) {\n                        error(\"root.finishedLanes should not be empty during a commit. This is a \" + \"bug in React.\");\n                    }\n                }\n            }\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            if (finishedWork === root.current) {\n                throw new Error(\"Cannot commit the same tree as before. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n            } // commitRoot never returns a continuation; it always finishes synchronously.\n            // So we can clear these now to allow a new callback to be scheduled.\n            root.callbackNode = null;\n            root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n            // pending time is whatever is left on the root fiber.\n            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n            markRootFinished(root, remainingLanes);\n            if (root === workInProgressRoot) {\n                // We can reset these now that they are finished.\n                workInProgressRoot = null;\n                workInProgress = null;\n                workInProgressRootRenderLanes = NoLanes;\n            } // If there are pending passive effects, schedule a callback to process them.\n            // Do this as early as possible, so it is queued before anything else that\n            // might get scheduled in the commit phase. (See #16714.)\n            // TODO: Delete all other places that schedule the passive effect callback\n            // They're redundant.\n            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback$1(NormalPriority, function() {\n                        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n                        // *after* passive effects fire to avoid freeing a cache pool that may\n                        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n                        return null;\n                    });\n                }\n            } // Check if there are any effects in the whole tree.\n            // TODO: This is left over from the effect list implementation, where we had\n            // to check for the existence of `firstEffect` to satisfy Flow. I think the\n            // only other reason this optimization exists is because it affects profiling.\n            // Reconsider whether this is necessary.\n            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n            if (subtreeHasEffects || rootHasEffect) {\n                var prevTransition = ReactCurrentBatchConfig$2.transition;\n                ReactCurrentBatchConfig$2.transition = null;\n                var previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext; // Reset this to null before calling lifecycles\n                ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n                // of the effect list for each phase: all mutation effects come before all\n                // layout effects, and so on.\n                // The first phase a \"before mutation\" phase. We use this phase to read the\n                // state of the host tree right before we mutate it. This is where\n                // getSnapshotBeforeUpdate is called.\n                var shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n                {\n                    // Mark the current commit time to be shared by all Profilers in this\n                    // batch. This enables them to be grouped later.\n                    recordCommitTime();\n                }\n                commitMutationEffects(root, finishedWork, lanes);\n                resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n                // the mutation phase, so that the previous tree is still current during\n                // componentWillUnmount, but before the layout phase, so that the finished\n                // work is current during componentDidMount/Update.\n                root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n                {\n                    markLayoutEffectsStarted(lanes);\n                }\n                commitLayoutEffects(finishedWork, root, lanes);\n                {\n                    markLayoutEffectsStopped();\n                }\n                // opportunity to paint.\n                requestPaint();\n                executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n            } else {\n                // No effects.\n                root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n                // no effects.\n                // TODO: Maybe there's a better way to report this.\n                {\n                    recordCommitTime();\n                }\n            }\n            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n            if (rootDoesHavePassiveEffects) {\n                // This commit has passive effects. Stash a reference to them. But don't\n                // schedule a callback until after flushing layout work.\n                rootDoesHavePassiveEffects = false;\n                rootWithPendingPassiveEffects = root;\n                pendingPassiveEffectsLanes = lanes;\n            } // Read this again, since an effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n            // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n            // is to detect whether something might have called setState inside\n            // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n            // inside `componentDidCatch` is itself flawed — that's why we recommend\n            // `getDerivedStateFromError` instead. However, it could be improved by\n            // checking if remainingLanes includes Sync work, instead of whether there's\n            // any work remaining at all (which would also include stuff like Suspense\n            // retries or transitions). It's been like this for a while, though, so fixing\n            // it probably isn't that urgent.\n            if (remainingLanes === NoLanes) {\n                // If there's no remaining work, we can clear the set of already failed\n                // error boundaries.\n                legacyErrorBoundariesThatAlreadyFailed = null;\n            }\n            {\n                if (!rootDidHavePassiveEffects) {\n                    commitDoubleInvokeEffectsInDEV(root.current, false);\n                }\n            }\n            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n            {\n                if (isDevToolsPresent) {\n                    root.memoizedUpdaters.clear();\n                }\n            }\n            {\n                onCommitRoot$1();\n            }\n            // additional work on this root is scheduled.\n            ensureRootIsScheduled(root, now$1());\n            if (recoverableErrors !== null) {\n                // There were errors during this render, but recovered from them without\n                // needing to surface it to the UI. We log them here.\n                var onRecoverableError = root.onRecoverableError;\n                for(var i = 0; i < recoverableErrors.length; i++){\n                    var recoverableError = recoverableErrors[i];\n                    onRecoverableError(recoverableError);\n                }\n            }\n            if (hasUncaughtError) {\n                hasUncaughtError = false;\n                var error$1 = firstUncaughtError;\n                firstUncaughtError = null;\n                throw error$1;\n            } // If the passive effects are the result of a discrete render, flush them\n            // synchronously at the end of the current task so that the result is\n            // immediately observable. Otherwise, we assume that they are not\n            // order-dependent and do not need to be observed by external systems, so we\n            // can wait until after paint.\n            // TODO: We can optimize this by not scheduling the callback earlier. Since we\n            // currently schedule the callback in multiple places, will wait until those\n            // are consolidated.\n            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n                flushPassiveEffects();\n            } // Read this again, since a passive effect might have updated it\n            remainingLanes = root.pendingLanes;\n            if (includesSomeLane(remainingLanes, SyncLane)) {\n                {\n                    markNestedUpdateScheduled();\n                }\n                // finishing. If there are too many, it indicates an infinite update loop.\n                if (root === rootWithNestedUpdates) {\n                    nestedUpdateCount++;\n                } else {\n                    nestedUpdateCount = 0;\n                    rootWithNestedUpdates = root;\n                }\n            } else {\n                nestedUpdateCount = 0;\n            } // If layout work was scheduled, flush it now.\n            flushSyncCallbacks();\n            {\n                markCommitStopped();\n            }\n            return null;\n        }\n        function flushPassiveEffects() {\n            // Returns whether passive effects were flushed.\n            // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n            // probably just combine the two functions. I believe they were only separate\n            // in the first place because we used to wrap it with\n            // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n            // priority within React itself, so we can mutate the variable directly.\n            if (rootWithPendingPassiveEffects !== null) {\n                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n                var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n                var prevTransition = ReactCurrentBatchConfig$2.transition;\n                var previousPriority = getCurrentUpdatePriority();\n                try {\n                    ReactCurrentBatchConfig$2.transition = null;\n                    setCurrentUpdatePriority(priority);\n                    return flushPassiveEffectsImpl();\n                } finally{\n                    setCurrentUpdatePriority(previousPriority);\n                    ReactCurrentBatchConfig$2.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n                }\n            }\n            return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n            {\n                pendingPassiveProfilerEffects.push(fiber);\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback$1(NormalPriority, function() {\n                        flushPassiveEffects();\n                        return null;\n                    });\n                }\n            }\n        }\n        function flushPassiveEffectsImpl() {\n            if (rootWithPendingPassiveEffects === null) {\n                return false;\n            }\n            var root = rootWithPendingPassiveEffects;\n            var lanes = pendingPassiveEffectsLanes;\n            rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n            // Figure out why and fix it. It's not causing any known issues (probably\n            // because it's only used for profiling), but it's a refactor hazard.\n            pendingPassiveEffectsLanes = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Cannot flush passive effects while already rendering.\");\n            }\n            {\n                markPassiveEffectsStarted(lanes);\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            commitPassiveUnmountEffects(root.current);\n            commitPassiveMountEffects(root, root.current); // TODO: Move to commitPassiveMountEffects\n            {\n                var profilerEffects = pendingPassiveProfilerEffects;\n                pendingPassiveProfilerEffects = [];\n                for(var i = 0; i < profilerEffects.length; i++){\n                    var _fiber = profilerEffects[i];\n                    commitPassiveEffectDurations(root, _fiber);\n                }\n            }\n            {\n                markPassiveEffectsStopped();\n            }\n            {\n                commitDoubleInvokeEffectsInDEV(root.current, true);\n            }\n            executionContext = prevExecutionContext;\n            flushSyncCallbacks(); // If additional passive effects were scheduled, increment a counter. If this\n            // exceeds the limit, we'll fire a warning.\n            nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1; // TODO: Move to commitPassiveMountEffects\n            onPostCommitRoot(root);\n            {\n                var stateNode = root.current.stateNode;\n                stateNode.effectDuration = 0;\n                stateNode.passiveEffectDuration = 0;\n            }\n            return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n            if (legacyErrorBoundariesThatAlreadyFailed === null) {\n                legacyErrorBoundariesThatAlreadyFailed = new Set([\n                    instance\n                ]);\n            } else {\n                legacyErrorBoundariesThatAlreadyFailed.add(instance);\n            }\n        }\n        function prepareToThrowUncaughtError(error) {\n            if (!hasUncaughtError) {\n                hasUncaughtError = true;\n                firstUncaughtError = error;\n            }\n        }\n        var onUncaughtError = prepareToThrowUncaughtError;\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n            var errorInfo = createCapturedValue(error, sourceFiber);\n            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n            enqueueUpdate(rootFiber, update);\n            var eventTime = requestEventTime();\n            var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);\n            if (root !== null) {\n                markRootUpdated(root, SyncLane, eventTime);\n                ensureRootIsScheduled(root, eventTime);\n            }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n            if (sourceFiber.tag === HostRoot) {\n                // Error was thrown at the root. There is no parent, so the root\n                // itself should capture it.\n                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n                return;\n            }\n            var fiber = null;\n            {\n                fiber = nearestMountedAncestor;\n            }\n            while(fiber !== null){\n                if (fiber.tag === HostRoot) {\n                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n                    return;\n                } else if (fiber.tag === ClassComponent) {\n                    var ctor = fiber.type;\n                    var instance = fiber.stateNode;\n                    if (typeof ctor.getDerivedStateFromError === \"function\" || typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                        var errorInfo = createCapturedValue(error$1, sourceFiber);\n                        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n                        enqueueUpdate(fiber, update);\n                        var eventTime = requestEventTime();\n                        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);\n                        if (root !== null) {\n                            markRootUpdated(root, SyncLane, eventTime);\n                            ensureRootIsScheduled(root, eventTime);\n                        }\n                        return;\n                    }\n                }\n                fiber = fiber.return;\n            }\n            {\n                // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n                // will fire for errors that are thrown by destroy functions inside deleted\n                // trees. What it should instead do is propagate the error to the parent of\n                // the deleted tree. In the meantime, do not add this warning to the\n                // allowlist; this is only for our internal use.\n                error(\"Internal React error: Attempted to capture a commit phase error \" + \"inside a detached tree. This indicates a bug in React. Likely \" + \"causes include deleting the same fiber more than once, committing an \" + \"already-finished tree, or an inconsistent return pointer.\\n\\n\" + \"Error message:\\n\\n%s\", error$1);\n            }\n        }\n        function pingSuspendedRoot(root, wakeable, pingedLanes) {\n            var pingCache = root.pingCache;\n            if (pingCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                pingCache.delete(wakeable);\n            }\n            var eventTime = requestEventTime();\n            markRootPinged(root, pingedLanes);\n            warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n                // Received a ping at the same priority level at which we're currently\n                // rendering. We might want to restart this render. This should mirror\n                // the logic of whether or not a root suspends once it completes.\n                // TODO: If we're rendering sync either due to Sync, Batched or expired,\n                // we should probably never restart.\n                // If we're suspended with delay, or if it's a retry, we'll always suspend\n                // so we can always restart.\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n                    // Restart from the root.\n                    prepareFreshStack(root, NoLanes);\n                } else {\n                    // Even though we can't restart right now, we might get an\n                    // opportunity later. So we mark this render as having a ping.\n                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n                }\n            }\n            ensureRootIsScheduled(root, eventTime);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n            // The boundary fiber (a Suspense component or SuspenseList component)\n            // previously was rendered in its fallback state. One of the promises that\n            // suspended it has resolved, which means at least part of the tree was\n            // likely unblocked. Try rendering again, at a new lanes.\n            if (retryLane === NoLane) {\n                // TODO: Assign this to `suspenseState.retryLane`? to avoid\n                // unnecessary entanglement?\n                retryLane = requestRetryLane(boundaryFiber);\n            } // TODO: Special case idle priority?\n            var eventTime = requestEventTime();\n            var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\n            if (root !== null) {\n                markRootUpdated(root, retryLane, eventTime);\n                ensureRootIsScheduled(root, eventTime);\n            }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n            var suspenseState = boundaryFiber.memoizedState;\n            var retryLane = NoLane;\n            if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n            var retryLane = NoLane; // Default\n            var retryCache;\n            {\n                switch(boundaryFiber.tag){\n                    case SuspenseComponent:\n                        retryCache = boundaryFiber.stateNode;\n                        var suspenseState = boundaryFiber.memoizedState;\n                        if (suspenseState !== null) {\n                            retryLane = suspenseState.retryLane;\n                        }\n                        break;\n                    case SuspenseListComponent:\n                        retryCache = boundaryFiber.stateNode;\n                        break;\n                    default:\n                        throw new Error(\"Pinged unknown suspense boundary type. \" + \"This is probably a bug in React.\");\n                }\n            }\n            if (retryCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                retryCache.delete(wakeable);\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        } // Computes the next Just Noticeable Difference (JND) boundary.\n        // The theory is that a person can't tell the difference between small differences in time.\n        // Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n        // difference in the experience. However, waiting for longer might mean that we can avoid\n        // showing an intermediate loading state. The longer we have already waited, the harder it\n        // is to tell small differences in time. Therefore, the longer we've already waited,\n        // the longer we can wait additionally. At some point we have to give up though.\n        // We pick a train model where the next boundary commits at a consistent schedule.\n        // These particular numbers are vague estimates. We expect to adjust them based on research.\n        function jnd(timeElapsed) {\n            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n        }\n        function checkForNestedUpdates() {\n            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n                nestedUpdateCount = 0;\n                rootWithNestedUpdates = null;\n                throw new Error(\"Maximum update depth exceeded. This can happen when a component \" + \"repeatedly calls setState inside componentWillUpdate or \" + \"componentDidUpdate. React limits the number of nested updates to \" + \"prevent infinite loops.\");\n            }\n            {\n                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n                    nestedPassiveUpdateCount = 0;\n                    error(\"Maximum update depth exceeded. This can happen when a component \" + \"calls setState inside useEffect, but useEffect either doesn't \" + \"have a dependency array, or one of the dependencies changes on \" + \"every render.\");\n                }\n            }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n            {\n                ReactStrictModeWarnings.flushLegacyContextWarning();\n                {\n                    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n                }\n            }\n        }\n        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n            {\n                // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n                // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n                // Maybe not a big deal since this is DEV only behavior.\n                setCurrentFiber(fiber);\n                invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n                if (hasPassiveEffects) {\n                    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n                }\n                invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n                if (hasPassiveEffects) {\n                    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n                }\n                resetCurrentFiber();\n            }\n        }\n        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                var current = firstChild;\n                var subtreeRoot = null;\n                while(current !== null){\n                    var primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n                    if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n                        current = current.child;\n                    } else {\n                        if ((current.flags & fiberFlags) !== NoFlags) {\n                            invokeEffectFn(current);\n                        }\n                        if (current.sibling !== null) {\n                            current = current.sibling;\n                        } else {\n                            current = subtreeRoot = current.return;\n                        }\n                    }\n                }\n            }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n            {\n                if ((executionContext & RenderContext) !== NoContext) {\n                    // We let the other warning about render phase updates deal with this one.\n                    return;\n                }\n                if (!(fiber.mode & ConcurrentMode)) {\n                    return;\n                }\n                var tag = fiber.tag;\n                if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n                    // Only warn for user-defined components, not internal ones like Suspense.\n                    return;\n                } // We show the whole stack but dedupe on the top component's name because\n                // the problematic code almost always lies inside that component.\n                var componentName = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                        return;\n                    }\n                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n                } else {\n                    didWarnStateUpdateForNotYetMountedComponent = new Set([\n                        componentName\n                    ]);\n                }\n                var previousFiber = current;\n                try {\n                    setCurrentFiber(fiber);\n                    error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + \"This indicates that you have a side-effect in your render function that \" + \"asynchronously later calls tries to update the component. Move this work to \" + \"useEffect instead.\");\n                } finally{\n                    if (previousFiber) {\n                        setCurrentFiber(fiber);\n                    } else {\n                        resetCurrentFiber();\n                    }\n                }\n            }\n        }\n        var beginWork$1;\n        {\n            var dummyFiber = null;\n            beginWork$1 = function(current, unitOfWork, lanes) {\n                // If a component throws an error, we replay it again in a synchronously\n                // dispatched event, so that the debugger will treat it as an uncaught\n                // error See ReactErrorUtils for more information.\n                // Before entering the begin phase, copy the work-in-progress onto a dummy\n                // fiber. If beginWork throws, we'll use this to reset the state.\n                var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n                try {\n                    return beginWork(current, unitOfWork, lanes);\n                } catch (originalError) {\n                    if (originalError !== null && typeof originalError === \"object\" && typeof originalError.then === \"function\") {\n                        // Don't replay promises. Treat everything else like an error.\n                        throw originalError;\n                    } // Keep this code in sync with handleError; any changes here must have\n                    // corresponding changes there.\n                    resetContextDependencies();\n                    resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n                    // same fiber again.\n                    // Unwind the failed stack frame\n                    unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.\n                    assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n                    if (unitOfWork.mode & ProfileMode) {\n                        // Reset the profiler timer.\n                        startProfilerTimer(unitOfWork);\n                    } // Run beginWork again.\n                    invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);\n                    if (hasCaughtError()) {\n                        var replayError = clearCaughtError();\n                        if (typeof replayError === \"object\" && replayError !== null && replayError._suppressLogging && typeof originalError === \"object\" && originalError !== null && !originalError._suppressLogging) {\n                            // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n                            originalError._suppressLogging = true;\n                        }\n                    } // We always throw the original error in case the second render pass is not idempotent.\n                    // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n                    throw originalError;\n                }\n            };\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n            didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n            {\n                if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n                    switch(fiber.tag){\n                        case FunctionComponent:\n                        case ForwardRef:\n                        case SimpleMemoComponent:\n                            {\n                                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\"; // Dedupe by the rendering component because it's the one that needs to be fixed.\n                                var dedupeKey = renderingComponentName;\n                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                                    var setStateComponentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                                    error(\"Cannot update a component (`%s`) while rendering a \" + \"different component (`%s`). To locate the bad setState() call inside `%s`, \" + \"follow the stack trace as described in https://reactjs.org/link/setstate-in-render\", setStateComponentName, renderingComponentName, renderingComponentName);\n                                }\n                                break;\n                            }\n                        case ClassComponent:\n                            {\n                                if (!didWarnAboutUpdateInRender) {\n                                    error(\"Cannot update during an existing state transition (such as \" + \"within `render`). Render methods should be a pure \" + \"function of props and state.\");\n                                    didWarnAboutUpdateInRender = true;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function restorePendingUpdaters(root, lanes) {\n            {\n                if (isDevToolsPresent) {\n                    var memoizedUpdaters = root.memoizedUpdaters;\n                    memoizedUpdaters.forEach(function(schedulingFiber) {\n                        addFiberToLanesMap(root, schedulingFiber, lanes);\n                    }); // This function intentionally does not clear memoized updaters.\n                // Those may still be relevant to the current commit\n                // and a future one (e.g. Suspense).\n                }\n            }\n        }\n        var fakeActCallbackNode = {};\n        function scheduleCallback$1(priorityLevel, callback) {\n            {\n                // If we're currently inside an `act` scope, bypass Scheduler and push to\n                // the `act` queue instead.\n                var actQueue = ReactCurrentActQueue$1.current;\n                if (actQueue !== null) {\n                    actQueue.push(callback);\n                    return fakeActCallbackNode;\n                } else {\n                    return scheduleCallback(priorityLevel, callback);\n                }\n            }\n        }\n        function cancelCallback$1(callbackNode) {\n            if (callbackNode === fakeActCallbackNode) {\n                return;\n            } // In production, always call Scheduler. This function will be stripped out.\n            return cancelCallback(callbackNode);\n        }\n        function shouldForceFlushFallbacksInDEV() {\n            // Never force flush in production. This function should get stripped out.\n            return ReactCurrentActQueue$1.current !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n            {\n                if (fiber.mode & ConcurrentMode) {\n                    if (!isConcurrentActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                } else {\n                    // Legacy mode has additional cases where we suppress a warning.\n                    if (!isLegacyActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                    if (executionContext !== NoContext) {\n                        // Legacy mode doesn't warn if the update is batched, i.e.\n                        // batchedUpdates or flushSync.\n                        return;\n                    }\n                    if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n                        // For backwards compatibility with pre-hooks code, legacy mode only\n                        // warns for updates that originate from a hook.\n                        return;\n                    }\n                }\n                if (ReactCurrentActQueue$1.current === null) {\n                    var previousFiber = current;\n                    try {\n                        setCurrentFiber(fiber);\n                        error(\"An update to %s inside a test was not wrapped in act(...).\\n\\n\" + \"When testing, code that causes React state updates should be \" + \"wrapped into act(...):\\n\\n\" + \"act(() => {\\n\" + \"  /* fire events that update state */\\n\" + \"});\\n\" + \"/* assert on the output */\\n\\n\" + \"This ensures that you're testing the behavior the user would see \" + \"in the browser.\" + \" Learn more at https://reactjs.org/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n                    } finally{\n                        if (previousFiber) {\n                            setCurrentFiber(fiber);\n                        } else {\n                            resetCurrentFiber();\n                        }\n                    }\n                }\n            }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n            {\n                if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n                    error(\"A suspended resource finished loading inside a test, but the event \" + \"was not wrapped in act(...).\\n\\n\" + \"When testing, code that resolves suspended data should be wrapped \" + \"into act(...):\\n\\n\" + \"act(() => {\\n\" + \"  /* finish loading suspended data */\\n\" + \"});\\n\" + \"/* assert on the output */\\n\\n\" + \"This ensures that you're testing the behavior the user would see \" + \"in the browser.\" + \" Learn more at https://reactjs.org/link/wrap-tests-with-act\");\n                }\n            }\n        }\n        /* eslint-disable react-internal/prod-error-codes */ var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n            {\n                resolveFamily = handler;\n            }\n        };\n        function resolveFunctionForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function resolveClassForHotReloading(type) {\n            // No implementation differences.\n            return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    // Check if we're dealing with a real forwardRef. Don't want to crash early.\n                    if (type !== null && type !== undefined && typeof type.render === \"function\") {\n                        // ForwardRef is special because its resolved .type is an object,\n                        // but it's possible that we only have its inner render function in the map.\n                        // If that inner render function is different, we'll build a new forwardRef type.\n                        var currentRender = resolveFunctionForHotReloading(type.render);\n                        if (type.render !== currentRender) {\n                            var syntheticType = {\n                                $$typeof: REACT_FORWARD_REF_TYPE,\n                                render: currentRender\n                            };\n                            if (type.displayName !== undefined) {\n                                syntheticType.displayName = type.displayName;\n                            }\n                            return syntheticType;\n                        }\n                    }\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return false;\n                }\n                var prevType = fiber.elementType;\n                var nextType = element.type; // If we got here, we know types aren't === equal.\n                var needsCompareFamilies = false;\n                var $$typeofNextType = typeof nextType === \"object\" && nextType !== null ? nextType.$$typeof : null;\n                switch(fiber.tag){\n                    case ClassComponent:\n                        {\n                            if (typeof nextType === \"function\") {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case FunctionComponent:\n                        {\n                            if (typeof nextType === \"function\") {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                // We don't know the inner type yet.\n                                // We're going to assume that the lazy inner type is stable,\n                                // and so it is sufficient to avoid reconciling it away.\n                                // We're not going to unwrap or actually use the new lazy type.\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case ForwardRef:\n                        {\n                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if ($$typeofNextType === REACT_MEMO_TYPE) {\n                                // TODO: if it was but can no longer be simple,\n                                // we shouldn't set this.\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    default:\n                        return false;\n                } // Check if both types have a family and it's the same one.\n                if (needsCompareFamilies) {\n                    // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n                    // This means both of them need to be registered to preserve state.\n                    // If we unwrapped and compared the inner types for wrappers instead,\n                    // then we would risk falsely saying two separate memo(Foo)\n                    // calls are equivalent because they wrap the same Foo function.\n                    var prevFamily = resolveFamily(prevType);\n                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                if (typeof WeakSet !== \"function\") {\n                    return;\n                }\n                if (failedBoundaries === null) {\n                    failedBoundaries = new WeakSet();\n                }\n                failedBoundaries.add(fiber);\n            }\n        }\n        var scheduleRefresh = function(root, update) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n                flushPassiveEffects();\n                flushSync(function() {\n                    scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n                });\n            }\n        };\n        var scheduleRoot = function(root, element) {\n            {\n                if (root.context !== emptyContextObject) {\n                    // Super edge case: root has a legacy _renderSubtree context\n                    // but we don't know the parentComponent so we can't pass it.\n                    // Just ignore. We'll delete this with _renderSubtree code path later.\n                    return;\n                }\n                flushPassiveEffects();\n                flushSync(function() {\n                    updateContainer(element, root, null, null);\n                });\n            }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n            {\n                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                if (resolveFamily === null) {\n                    throw new Error(\"Expected resolveFamily to be set during hot reload.\");\n                }\n                var needsRender = false;\n                var needsRemount = false;\n                if (candidateType !== null) {\n                    var family = resolveFamily(candidateType);\n                    if (family !== undefined) {\n                        if (staleFamilies.has(family)) {\n                            needsRemount = true;\n                        } else if (updatedFamilies.has(family)) {\n                            if (tag === ClassComponent) {\n                                needsRemount = true;\n                            } else {\n                                needsRender = true;\n                            }\n                        }\n                    }\n                }\n                if (failedBoundaries !== null) {\n                    if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n                        needsRemount = true;\n                    }\n                }\n                if (needsRemount) {\n                    fiber._debugNeedsRemount = true;\n                }\n                if (needsRemount || needsRender) {\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n                if (child !== null && !needsRemount) {\n                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n                }\n                if (sibling !== null) {\n                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n                }\n            }\n        }\n        var findHostInstancesForRefresh = function(root, families) {\n            {\n                var hostInstances = new Set();\n                var types = new Set(families.map(function(family) {\n                    return family.current;\n                }));\n                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n                return hostInstances;\n            }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n            {\n                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                var didMatch = false;\n                if (candidateType !== null) {\n                    if (types.has(candidateType)) {\n                        didMatch = true;\n                    }\n                }\n                if (didMatch) {\n                    // We have a match. This only drills down to the closest host components.\n                    // There's no need to search deeper because for the purpose of giving\n                    // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n                    findHostInstancesForFiberShallowly(fiber, hostInstances);\n                } else {\n                    // If there's no match, maybe there will be one further down in the child tree.\n                    if (child !== null) {\n                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n                    }\n                }\n                if (sibling !== null) {\n                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n                }\n            }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n                if (foundHostInstances) {\n                    return;\n                } // If we didn't find any host children, fallback to closest host parent.\n                var node = fiber;\n                while(true){\n                    switch(node.tag){\n                        case HostComponent:\n                            hostInstances.add(node.stateNode);\n                            return;\n                        case HostPortal:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                        case HostRoot:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                    }\n                    if (node.return === null) {\n                        throw new Error(\"Expected to reach root first.\");\n                    }\n                    node = node.return;\n                }\n            }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var node = fiber;\n                var foundHostInstances = false;\n                while(true){\n                    if (node.tag === HostComponent) {\n                        // We got a match.\n                        foundHostInstances = true;\n                        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === fiber) {\n                        return foundHostInstances;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === fiber) {\n                            return foundHostInstances;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n            return false;\n        }\n        var hasBadMapPolyfill;\n        {\n            hasBadMapPolyfill = false;\n            try {\n                var nonExtensibleObject = Object.preventExtensions({});\n                /* eslint-disable no-new */ new Map([\n                    [\n                        nonExtensibleObject,\n                        null\n                    ]\n                ]);\n                new Set([\n                    nonExtensibleObject\n                ]);\n            /* eslint-enable no-new */ } catch (e) {\n                // TODO: Consider warning about bad polyfills\n                hasBadMapPolyfill = true;\n            }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n            // Instance\n            this.tag = tag;\n            this.key = key;\n            this.elementType = null;\n            this.type = null;\n            this.stateNode = null; // Fiber\n            this.return = null;\n            this.child = null;\n            this.sibling = null;\n            this.index = 0;\n            this.ref = null;\n            this.pendingProps = pendingProps;\n            this.memoizedProps = null;\n            this.updateQueue = null;\n            this.memoizedState = null;\n            this.dependencies = null;\n            this.mode = mode; // Effects\n            this.flags = NoFlags;\n            this.subtreeFlags = NoFlags;\n            this.deletions = null;\n            this.lanes = NoLanes;\n            this.childLanes = NoLanes;\n            this.alternate = null;\n            {\n                // Note: The following is done to avoid a v8 performance cliff.\n                //\n                // Initializing the fields below to smis and later updating them with\n                // double values will cause Fibers to end up having separate shapes.\n                // This behavior/bug has something to do with Object.preventExtension().\n                // Fortunately this only impacts DEV builds.\n                // Unfortunately it makes React unusably slow for some applications.\n                // To work around this, initialize the fields below with doubles.\n                //\n                // Learn more about this here:\n                // https://github.com/facebook/react/issues/14365\n                // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n                this.actualDuration = Number.NaN;\n                this.actualStartTime = Number.NaN;\n                this.selfBaseDuration = Number.NaN;\n                this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n                // This won't trigger the performance cliff mentioned above,\n                // and it simplifies other profiler code (including DevTools).\n                this.actualDuration = 0;\n                this.actualStartTime = -1;\n                this.selfBaseDuration = 0;\n                this.treeBaseDuration = 0;\n            }\n            {\n                // This isn't directly used but is handy for debugging internals:\n                this._debugSource = null;\n                this._debugOwner = null;\n                this._debugNeedsRemount = false;\n                this._debugHookTypes = null;\n                if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n                    Object.preventExtensions(this);\n                }\n            }\n        } // This is a constructor function, rather than a POJO constructor, still\n        // please ensure we do the following:\n        // 1) Nobody should add any instance methods on this. Instance methods can be\n        //    more difficult to predict when they get optimized and they are almost\n        //    never inlined properly in static compilers.\n        // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n        //    always know when it is a fiber.\n        // 3) We might want to experiment with using numeric keys since they are easier\n        //    to optimize in a non-JIT environment.\n        // 4) We can easily go from a constructor to a createFiber object literal if that\n        //    is faster.\n        // 5) It should be easy to port this to a C struct and keep a C implementation\n        //    compatible.\n        var createFiber = function(tag, pendingProps, key, mode) {\n            // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n            return new FiberNode(tag, pendingProps, key, mode);\n        };\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n            return typeof type === \"function\" && !shouldConstruct$1(type) && type.defaultProps === undefined;\n        }\n        function resolveLazyComponentTag(Component) {\n            if (typeof Component === \"function\") {\n                return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n            } else if (Component !== undefined && Component !== null) {\n                var $$typeof = Component.$$typeof;\n                if ($$typeof === REACT_FORWARD_REF_TYPE) {\n                    return ForwardRef;\n                }\n                if ($$typeof === REACT_MEMO_TYPE) {\n                    return MemoComponent;\n                }\n            }\n            return IndeterminateComponent;\n        } // This is used to create an alternate fiber to do work on.\n        function createWorkInProgress(current, pendingProps) {\n            var workInProgress = current.alternate;\n            if (workInProgress === null) {\n                // We use a double buffering pooling technique because we know that we'll\n                // only ever need at most two versions of a tree. We pool the \"other\" unused\n                // node that we're free to reuse. This is lazily created to avoid allocating\n                // extra objects for things that are never updated. It also allow us to\n                // reclaim the extra memory if needed.\n                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n                workInProgress.elementType = current.elementType;\n                workInProgress.type = current.type;\n                workInProgress.stateNode = current.stateNode;\n                {\n                    // DEV-only fields\n                    workInProgress._debugSource = current._debugSource;\n                    workInProgress._debugOwner = current._debugOwner;\n                    workInProgress._debugHookTypes = current._debugHookTypes;\n                }\n                workInProgress.alternate = current;\n                current.alternate = workInProgress;\n            } else {\n                workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // We already have an alternate.\n                // Reset the effect tag.\n                workInProgress.flags = NoFlags; // The effects are no longer valid.\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.deletions = null;\n                {\n                    // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n                    // This prevents time from endlessly accumulating in new commits.\n                    // This has the downside of resetting values for different priority renders,\n                    // But works for yielding (the common case) and should support resuming.\n                    workInProgress.actualDuration = 0;\n                    workInProgress.actualStartTime = -1;\n                }\n            } // Reset all effects except static ones.\n            // Static effects are not specific to a render.\n            workInProgress.flags = current.flags & StaticMask;\n            workInProgress.childLanes = current.childLanes;\n            workInProgress.lanes = current.lanes;\n            workInProgress.child = current.child;\n            workInProgress.memoizedProps = current.memoizedProps;\n            workInProgress.memoizedState = current.memoizedState;\n            workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n            // it cannot be shared with the current fiber.\n            var currentDependencies = current.dependencies;\n            workInProgress.dependencies = currentDependencies === null ? null : {\n                lanes: currentDependencies.lanes,\n                firstContext: currentDependencies.firstContext\n            }; // These will be overridden during the parent's reconciliation\n            workInProgress.sibling = current.sibling;\n            workInProgress.index = current.index;\n            workInProgress.ref = current.ref;\n            {\n                workInProgress.selfBaseDuration = current.selfBaseDuration;\n                workInProgress.treeBaseDuration = current.treeBaseDuration;\n            }\n            {\n                workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n                switch(workInProgress.tag){\n                    case IndeterminateComponent:\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                        workInProgress.type = resolveFunctionForHotReloading(current.type);\n                        break;\n                    case ClassComponent:\n                        workInProgress.type = resolveClassForHotReloading(current.type);\n                        break;\n                    case ForwardRef:\n                        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n                        break;\n                }\n            }\n            return workInProgress;\n        } // Used to reuse a Fiber for a second pass.\n        function resetWorkInProgress(workInProgress, renderLanes) {\n            // This resets the Fiber to what createFiber or createWorkInProgress would\n            // have set the values to before during the first pass. Ideally this wouldn't\n            // be necessary but unfortunately many code paths reads from the workInProgress\n            // when they should be reading from current and writing to workInProgress.\n            // We assume pendingProps, index, key, ref, return are still untouched to\n            // avoid doing another reconciliation.\n            // Reset the effect flags but keep any Placement tags, since that's something\n            // that child fiber is setting, not the reconciliation.\n            workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n            var current = workInProgress.alternate;\n            if (current === null) {\n                // Reset to createFiber's initial values.\n                workInProgress.childLanes = NoLanes;\n                workInProgress.lanes = renderLanes;\n                workInProgress.child = null;\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.memoizedProps = null;\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null;\n                workInProgress.dependencies = null;\n                workInProgress.stateNode = null;\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = 0;\n                    workInProgress.treeBaseDuration = 0;\n                }\n            } else {\n                // Reset to the cloned values that createWorkInProgress would've.\n                workInProgress.childLanes = current.childLanes;\n                workInProgress.lanes = current.lanes;\n                workInProgress.child = current.child;\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.deletions = null;\n                workInProgress.memoizedProps = current.memoizedProps;\n                workInProgress.memoizedState = current.memoizedState;\n                workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n                // it cannot be shared with the current fiber.\n                var currentDependencies = current.dependencies;\n                workInProgress.dependencies = currentDependencies === null ? null : {\n                    lanes: currentDependencies.lanes,\n                    firstContext: currentDependencies.firstContext\n                };\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = current.selfBaseDuration;\n                    workInProgress.treeBaseDuration = current.treeBaseDuration;\n                }\n            }\n            return workInProgress;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n            var mode;\n            if (tag === ConcurrentRoot) {\n                mode = ConcurrentMode;\n                if (isStrictMode === true) {\n                    mode |= StrictLegacyMode;\n                    {\n                        mode |= StrictEffectsMode;\n                    }\n                }\n            } else {\n                mode = NoMode;\n            }\n            if (isDevToolsPresent) {\n                // Always collect profile timings when DevTools are present.\n                // This enables DevTools to start capturing timing at any point–\n                // Without some nodes in the tree having empty base times.\n                mode |= ProfileMode;\n            }\n            return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n            var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n            var resolvedType = type;\n            if (typeof type === \"function\") {\n                if (shouldConstruct$1(type)) {\n                    fiberTag = ClassComponent;\n                    {\n                        resolvedType = resolveClassForHotReloading(resolvedType);\n                    }\n                } else {\n                    {\n                        resolvedType = resolveFunctionForHotReloading(resolvedType);\n                    }\n                }\n            } else if (typeof type === \"string\") {\n                fiberTag = HostComponent;\n            } else {\n                getTag: switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n                    case REACT_STRICT_MODE_TYPE:\n                        fiberTag = Mode;\n                        mode |= StrictLegacyMode;\n                        if ((mode & ConcurrentMode) !== NoMode) {\n                            // Strict effects should never run on legacy roots\n                            mode |= StrictEffectsMode;\n                        }\n                        break;\n                    case REACT_PROFILER_TYPE:\n                        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_TYPE:\n                        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n                    case REACT_OFFSCREEN_TYPE:\n                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n                    case REACT_LEGACY_HIDDEN_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_SCOPE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_CACHE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_TRACING_MARKER_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_DEBUG_TRACING_MODE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    default:\n                        {\n                            if (typeof type === \"object\" && type !== null) {\n                                switch(type.$$typeof){\n                                    case REACT_PROVIDER_TYPE:\n                                        fiberTag = ContextProvider;\n                                        break getTag;\n                                    case REACT_CONTEXT_TYPE:\n                                        // This is a consumer\n                                        fiberTag = ContextConsumer;\n                                        break getTag;\n                                    case REACT_FORWARD_REF_TYPE:\n                                        fiberTag = ForwardRef;\n                                        {\n                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                                        }\n                                        break getTag;\n                                    case REACT_MEMO_TYPE:\n                                        fiberTag = MemoComponent;\n                                        break getTag;\n                                    case REACT_LAZY_TYPE:\n                                        fiberTag = LazyComponent;\n                                        resolvedType = null;\n                                        break getTag;\n                                }\n                            }\n                            var info = \"\";\n                            {\n                                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                                }\n                                var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n                                if (ownerName) {\n                                    info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                                }\n                            }\n                            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n                        }\n                }\n            }\n            var fiber = createFiber(fiberTag, pendingProps, key, mode);\n            fiber.elementType = type;\n            fiber.type = resolvedType;\n            fiber.lanes = lanes;\n            {\n                fiber._debugOwner = owner;\n            }\n            return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n            var owner = null;\n            {\n                owner = element._owner;\n            }\n            var type = element.type;\n            var key = element.key;\n            var pendingProps = element.props;\n            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n            {\n                fiber._debugSource = element._source;\n                fiber._debugOwner = element._owner;\n            }\n            return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n            var fiber = createFiber(Fragment, elements, key, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n            {\n                if (typeof pendingProps.id !== \"string\") {\n                    error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n                }\n            }\n            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n            fiber.elementType = REACT_PROFILER_TYPE;\n            fiber.lanes = lanes;\n            {\n                fiber.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                };\n            }\n            return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_OFFSCREEN_TYPE;\n            fiber.lanes = lanes;\n            var primaryChildInstance = {};\n            fiber.stateNode = primaryChildInstance;\n            return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n            var fiber = createFiber(HostText, content, null, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromHostInstanceForDeletion() {\n            var fiber = createFiber(HostComponent, null, null, NoMode);\n            fiber.elementType = \"DELETED\";\n            return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n            var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n            fiber.stateNode = dehydratedNode;\n            return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n            var pendingProps = portal.children !== null ? portal.children : [];\n            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n            fiber.lanes = lanes;\n            fiber.stateNode = {\n                containerInfo: portal.containerInfo,\n                pendingChildren: null,\n                // Used by persistent updates\n                implementation: portal.implementation\n            };\n            return fiber;\n        } // Used for stashing WIP properties to replay failed work in DEV.\n        function assignFiberPropertiesInDEV(target, source) {\n            if (target === null) {\n                // This Fiber's initial properties will always be overwritten.\n                // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n                target = createFiber(IndeterminateComponent, null, null, NoMode);\n            } // This is intentionally written as a list of all properties.\n            // We tried to use Object.assign() instead but this is called in\n            // the hottest path, and Object.assign() was too slow:\n            // https://github.com/facebook/react/issues/12502\n            // This code is DEV-only so size is not a concern.\n            target.tag = source.tag;\n            target.key = source.key;\n            target.elementType = source.elementType;\n            target.type = source.type;\n            target.stateNode = source.stateNode;\n            target.return = source.return;\n            target.child = source.child;\n            target.sibling = source.sibling;\n            target.index = source.index;\n            target.ref = source.ref;\n            target.pendingProps = source.pendingProps;\n            target.memoizedProps = source.memoizedProps;\n            target.updateQueue = source.updateQueue;\n            target.memoizedState = source.memoizedState;\n            target.dependencies = source.dependencies;\n            target.mode = source.mode;\n            target.flags = source.flags;\n            target.subtreeFlags = source.subtreeFlags;\n            target.deletions = source.deletions;\n            target.lanes = source.lanes;\n            target.childLanes = source.childLanes;\n            target.alternate = source.alternate;\n            {\n                target.actualDuration = source.actualDuration;\n                target.actualStartTime = source.actualStartTime;\n                target.selfBaseDuration = source.selfBaseDuration;\n                target.treeBaseDuration = source.treeBaseDuration;\n            }\n            target._debugSource = source._debugSource;\n            target._debugOwner = source._debugOwner;\n            target._debugNeedsRemount = source._debugNeedsRemount;\n            target._debugHookTypes = source._debugHookTypes;\n            return target;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n            this.tag = tag;\n            this.containerInfo = containerInfo;\n            this.pendingChildren = null;\n            this.current = null;\n            this.pingCache = null;\n            this.finishedWork = null;\n            this.timeoutHandle = noTimeout;\n            this.context = null;\n            this.pendingContext = null;\n            this.callbackNode = null;\n            this.callbackPriority = NoLane;\n            this.eventTimes = createLaneMap(NoLanes);\n            this.expirationTimes = createLaneMap(NoTimestamp);\n            this.pendingLanes = NoLanes;\n            this.suspendedLanes = NoLanes;\n            this.pingedLanes = NoLanes;\n            this.expiredLanes = NoLanes;\n            this.mutableReadLanes = NoLanes;\n            this.finishedLanes = NoLanes;\n            this.entangledLanes = NoLanes;\n            this.entanglements = createLaneMap(NoLanes);\n            this.identifierPrefix = identifierPrefix;\n            this.onRecoverableError = onRecoverableError;\n            if (supportsHydration) {\n                this.mutableSourceEagerHydrationData = null;\n            }\n            {\n                this.effectDuration = 0;\n                this.passiveEffectDuration = 0;\n            }\n            {\n                this.memoizedUpdaters = new Set();\n                var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n                for(var _i = 0; _i < TotalLanes; _i++){\n                    pendingUpdatersLaneMap.push(new Set());\n                }\n            }\n            {\n                switch(tag){\n                    case ConcurrentRoot:\n                        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n                        break;\n                    case LegacyRoot:\n                        this._debugRootType = hydrate ? \"hydrate()\" : \"render()\";\n                        break;\n                }\n            }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // host config, but because they are passed in at runtime, we have to thread\n        // them through the root constructor. Perhaps we should put them all into a\n        // single type, like a DynamicHostConfig that is defined by the renderer.\n        identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n            // stateNode is any.\n            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n            root.current = uninitializedFiber;\n            uninitializedFiber.stateNode = root;\n            {\n                var _initialState = {\n                    element: initialChildren,\n                    isDehydrated: hydrate,\n                    cache: null,\n                    // not enabled yet\n                    transitions: null\n                };\n                uninitializedFiber.memoizedState = _initialState;\n            }\n            initializeUpdateQueue(uninitializedFiber);\n            return root;\n        }\n        var ReactVersion = \"18.0.0-fc46dba67-20220329\";\n        function createPortal(children, containerInfo, implementation) {\n            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            {\n                checkKeyStringCoercion(key);\n            }\n            return {\n                // This tag allow us to uniquely identify this as a React Portal\n                $$typeof: REACT_PORTAL_TYPE,\n                key: key == null ? null : \"\" + key,\n                children: children,\n                containerInfo: containerInfo,\n                implementation: implementation\n            };\n        }\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n            didWarnAboutNestedUpdates = false;\n            didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n            if (!parentComponent) {\n                return emptyContextObject;\n            }\n            var fiber = get(parentComponent);\n            var parentContext = findCurrentUnmaskedContext(fiber);\n            if (fiber.tag === ClassComponent) {\n                var Component = fiber.type;\n                if (isContextProvider(Component)) {\n                    return processChildContext(fiber, Component, parentContext);\n                }\n            }\n            return parentContext;\n        }\n        function findHostInstance(component) {\n            var fiber = get(component);\n            if (fiber === undefined) {\n                if (typeof component.render === \"function\") {\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                } else {\n                    var keys = Object.keys(component).join(\",\");\n                    throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n            {\n                var fiber = get(component);\n                if (fiber === undefined) {\n                    if (typeof component.render === \"function\") {\n                        throw new Error(\"Unable to find node on an unmounted component.\");\n                    } else {\n                        var keys = Object.keys(component).join(\",\");\n                        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                    }\n                }\n                var hostFiber = findCurrentHostFiber(fiber);\n                if (hostFiber === null) {\n                    return null;\n                }\n                if (hostFiber.mode & StrictLegacyMode) {\n                    var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                        didWarnAboutFindNodeInStrictMode[componentName] = true;\n                        var previousFiber = current;\n                        try {\n                            setCurrentFiber(hostFiber);\n                            if (fiber.mode & StrictLegacyMode) {\n                                error(\"%s is deprecated in StrictMode. \" + \"%s was passed an instance of %s which is inside StrictMode. \" + \"Instead, add a ref directly to the element you want to reference. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                            } else {\n                                error(\"%s is deprecated in StrictMode. \" + \"%s was passed an instance of %s which renders StrictMode children. \" + \"Instead, add a ref directly to the element you want to reference. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                            }\n                        } finally{\n                            // Ideally this should reset to previous but this shouldn't be called in\n                            // render and there's another warning for that anyway.\n                            if (previousFiber) {\n                                setCurrentFiber(previousFiber);\n                            } else {\n                                resetCurrentFiber();\n                            }\n                        }\n                    }\n                }\n                return hostFiber.stateNode;\n            }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var hydrate = false;\n            var initialChildren = null;\n            return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var hydrate = true;\n            var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError); // TODO: Move this to FiberRoot constructor\n            root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n            // a regular update because the initial render must match was was rendered\n            // on the server.\n            // NOTE: This update intentionally doesn't have a payload. We're only using\n            // the update to schedule work on the root fiber (and, for legacy roots, to\n            // enqueue the callback if one is provided).\n            var current = root.current;\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(current);\n            var update = createUpdate(eventTime, lane);\n            update.callback = callback !== undefined && callback !== null ? callback : null;\n            enqueueUpdate(current, update);\n            scheduleInitialHydrationOnRoot(root, lane, eventTime);\n            return root;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n            {\n                onScheduleRoot(container, element);\n            }\n            var current$1 = container.current;\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(current$1);\n            {\n                markRenderScheduled(lane);\n            }\n            var context = getContextForSubtree(parentComponent);\n            if (container.context === null) {\n                container.context = context;\n            } else {\n                container.pendingContext = context;\n            }\n            {\n                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n                    didWarnAboutNestedUpdates = true;\n                    error(\"Render methods should be a pure function of props and state; \" + \"triggering nested component updates from render is not allowed. \" + \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" + \"Check the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\");\n                }\n            }\n            var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: element\n            };\n            callback = callback === undefined ? null : callback;\n            if (callback !== null) {\n                {\n                    if (typeof callback !== \"function\") {\n                        error(\"render(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callback);\n                    }\n                }\n                update.callback = callback;\n            }\n            enqueueUpdate(current$1, update);\n            var root = scheduleUpdateOnFiber(current$1, lane, eventTime);\n            if (root !== null) {\n                entangleTransitions(root, current$1, lane);\n            }\n            return lane;\n        }\n        function getPublicRootInstance(container) {\n            var containerFiber = container.current;\n            if (!containerFiber.child) {\n                return null;\n            }\n            switch(containerFiber.child.tag){\n                case HostComponent:\n                    return getPublicInstance(containerFiber.child.stateNode);\n                default:\n                    return containerFiber.child.stateNode;\n            }\n        }\n        function attemptSynchronousHydration(fiber) {\n            switch(fiber.tag){\n                case HostRoot:\n                    var root = fiber.stateNode;\n                    if (isRootDehydrated(root)) {\n                        // Flush the first scheduled \"update\".\n                        var lanes = getHighestPriorityPendingLanes(root);\n                        flushRoot(root, lanes);\n                    }\n                    break;\n                case SuspenseComponent:\n                    var eventTime = requestEventTime();\n                    flushSync(function() {\n                        return scheduleUpdateOnFiber(fiber, SyncLane, eventTime);\n                    }); // If we're still blocked after this, we need to increase\n                    // the priority of any promises resolving within this\n                    // boundary so that they next attempt also has higher pri.\n                    var retryLane = SyncLane;\n                    markRetryLaneIfNotHydrated(fiber, retryLane);\n                    break;\n            }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n            }\n        } // Increases the priority of thenables when they resolve within this boundary.\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n            markRetryLaneImpl(fiber, retryLane);\n            var alternate = fiber.alternate;\n            if (alternate) {\n                markRetryLaneImpl(alternate, retryLane);\n            }\n        }\n        function attemptContinuousHydration(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority and they should not suspend on I/O,\n                // since you have to wrap anything that might suspend in\n                // Suspense.\n                return;\n            }\n            var eventTime = requestEventTime();\n            var lane = SelectiveHydrationLane;\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority other than synchronously flush it.\n                return;\n            }\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        var shouldErrorImpl = function(fiber) {\n            return null;\n        };\n        function shouldError(fiber) {\n            return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n            return false;\n        };\n        function shouldSuspend(fiber) {\n            return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n            var copyWithDeleteImpl = function(obj, path, index) {\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === path.length) {\n                    if (isArray(updated)) {\n                        updated.splice(key, 1);\n                    } else {\n                        delete updated[key];\n                    }\n                    return updated;\n                } // $FlowFixMe number or string is fine here\n                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n                return updated;\n            };\n            var copyWithDelete = function(obj, path) {\n                return copyWithDeleteImpl(obj, path, 0);\n            };\n            var copyWithRenameImpl = function(obj, oldPath, newPath, index) {\n                var oldKey = oldPath[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === oldPath.length) {\n                    var newKey = newPath[index]; // $FlowFixMe number or string is fine here\n                    updated[newKey] = updated[oldKey];\n                    if (isArray(updated)) {\n                        updated.splice(oldKey, 1);\n                    } else {\n                        delete updated[oldKey];\n                    }\n                } else {\n                    // $FlowFixMe number or string is fine here\n                    updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n                }\n                return updated;\n            };\n            var copyWithRename = function(obj, oldPath, newPath) {\n                if (oldPath.length !== newPath.length) {\n                    warn(\"copyWithRename() expects paths of the same length\");\n                    return;\n                } else {\n                    for(var i = 0; i < newPath.length - 1; i++){\n                        if (oldPath[i] !== newPath[i]) {\n                            warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                            return;\n                        }\n                    }\n                }\n                return copyWithRenameImpl(obj, oldPath, newPath, 0);\n            };\n            var copyWithSetImpl = function(obj, path, index, value) {\n                if (index >= path.length) {\n                    return value;\n                }\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe number or string is fine here\n                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n                return updated;\n            };\n            var copyWithSet = function(obj, path, value) {\n                return copyWithSetImpl(obj, path, 0, value);\n            };\n            var findHook = function(fiber, id) {\n                // For now, the \"id\" of stateful hooks is just the stateful hook index.\n                // This may change in the future with e.g. nested hooks.\n                var currentHook = fiber.memoizedState;\n                while(currentHook !== null && id > 0){\n                    currentHook = currentHook.next;\n                    id--;\n                }\n                return currentHook;\n            }; // Support DevTools editable values for useState and useReducer.\n            overrideHookState = function(fiber, id, path, value) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithSet(hook.memoizedState, path, value);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            };\n            overrideHookStateDeletePath = function(fiber, id, path) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithDelete(hook.memoizedState, path);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            };\n            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n            overrideProps = function(fiber, path, value) {\n                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            overridePropsDeletePath = function(fiber, path) {\n                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            overridePropsRenamePath = function(fiber, oldPath, newPath) {\n                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            scheduleUpdate = function(fiber) {\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            setErrorHandler = function(newShouldErrorImpl) {\n                shouldErrorImpl = newShouldErrorImpl;\n            };\n            setSuspenseHandler = function(newShouldSuspendImpl) {\n                shouldSuspendImpl = newShouldSuspendImpl;\n            };\n        }\n        function findHostInstanceByFiber(fiber) {\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n            return null;\n        }\n        function getCurrentFiberForDevTools() {\n            return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n            return injectInternals({\n                bundleType: devToolsConfig.bundleType,\n                version: devToolsConfig.version,\n                rendererPackageName: devToolsConfig.rendererPackageName,\n                rendererConfig: devToolsConfig.rendererConfig,\n                overrideHookState: overrideHookState,\n                overrideHookStateDeletePath: overrideHookStateDeletePath,\n                overrideHookStateRenamePath: overrideHookStateRenamePath,\n                overrideProps: overrideProps,\n                overridePropsDeletePath: overridePropsDeletePath,\n                overridePropsRenamePath: overridePropsRenamePath,\n                setErrorHandler: setErrorHandler,\n                setSuspenseHandler: setSuspenseHandler,\n                scheduleUpdate: scheduleUpdate,\n                currentDispatcherRef: ReactCurrentDispatcher,\n                findHostInstanceByFiber: findHostInstanceByFiber,\n                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n                // React Refresh\n                findHostInstancesForRefresh: findHostInstancesForRefresh,\n                scheduleRefresh: scheduleRefresh,\n                scheduleRoot: scheduleRoot,\n                setRefreshHandler: setRefreshHandler,\n                // Enables DevTools to append owner stacks to error messages in DEV mode.\n                getCurrentFiber: getCurrentFiberForDevTools,\n                // Enables DevTools to detect reconciler version rather than renderer version\n                // which may not match for third party renderers.\n                reconcilerVersion: ReactVersion\n            });\n        }\n        exports.attemptContinuousHydration = attemptContinuousHydration;\n        exports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\n        exports.attemptSynchronousHydration = attemptSynchronousHydration;\n        exports.batchedUpdates = batchedUpdates;\n        exports.createComponentSelector = createComponentSelector;\n        exports.createContainer = createContainer;\n        exports.createHasPseudoClassSelector = createHasPseudoClassSelector;\n        exports.createHydrationContainer = createHydrationContainer;\n        exports.createPortal = createPortal;\n        exports.createRoleSelector = createRoleSelector;\n        exports.createTestNameSelector = createTestNameSelector;\n        exports.createTextSelector = createTextSelector;\n        exports.deferredUpdates = deferredUpdates;\n        exports.discreteUpdates = discreteUpdates;\n        exports.findAllNodes = findAllNodes;\n        exports.findBoundingRects = findBoundingRects;\n        exports.findHostInstance = findHostInstance;\n        exports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\n        exports.findHostInstanceWithWarning = findHostInstanceWithWarning;\n        exports.flushControlled = flushControlled;\n        exports.flushPassiveEffects = flushPassiveEffects;\n        exports.flushSync = flushSync;\n        exports.focusWithin = focusWithin;\n        exports.getCurrentUpdatePriority = getCurrentUpdatePriority;\n        exports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\n        exports.getPublicRootInstance = getPublicRootInstance;\n        exports.injectIntoDevTools = injectIntoDevTools;\n        exports.isAlreadyRendering = isAlreadyRendering;\n        exports.observeVisibleRects = observeVisibleRects;\n        exports.registerMutableSourceForHydration = registerMutableSourceForHydration;\n        exports.runWithPriority = runWithPriority;\n        exports.shouldError = shouldError;\n        exports.shouldSuspend = shouldSuspend;\n        exports.updateContainer = updateContainer;\n        return exports;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDekNDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxjQUFjQyxhQUFhO1FBQ25ELElBQUlGLFVBQVUsQ0FBQztRQUNuQjtRQUVBLElBQUlHLFFBQVFDLG1CQUFPQSxDQUFDO1FBQ3BCLElBQUlDLFlBQVlELG1CQUFPQSxDQUFDO1FBRXhCLElBQUlFLHVCQUF1QkgsTUFBTUksa0RBQWtEO1FBRW5GLElBQUlDLGtCQUFrQjtRQUN0QixTQUFTQyxtQkFBbUJDLGtCQUFrQjtZQUM1QztnQkFDRUYsa0JBQWtCRTtZQUNwQjtRQUNGLEVBQUUsK0RBQStEO1FBQ2pFLCtDQUErQztRQUMvQyxFQUFFO1FBQ0YsOERBQThEO1FBQzlELHFDQUFxQztRQUVyQyxTQUFTQyxLQUFLQyxNQUFNO1lBQ2xCO2dCQUNFLElBQUksQ0FBQ0osaUJBQWlCO29CQUNwQixJQUFLLElBQUlLLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7d0JBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7b0JBQ2xDO29CQUVBQyxhQUFhLFFBQVFQLFFBQVFJO2dCQUMvQjtZQUNGO1FBQ0Y7UUFDQSxTQUFTSSxNQUFNUixNQUFNO1lBQ25CO2dCQUNFLElBQUksQ0FBQ0osaUJBQWlCO29CQUNwQixJQUFLLElBQUlhLFFBQVFQLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSSxRQUFRLElBQUlBLFFBQVEsSUFBSSxJQUFJQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7d0JBQ2pITixJQUFJLENBQUNN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UUFDN0JqakUsUUFBUW83RCxtQkFBbUIsR0FBR0E7UUFDOUJwN0QsUUFBUWdxQyxpQ0FBaUMsR0FBR0E7UUFDNUNocUMsUUFBUW9qQixlQUFlLEdBQUdBO1FBQzFCcGpCLFFBQVEyakQsV0FBVyxHQUFHQTtRQUN0QjNqRCxRQUFRc21ELGFBQWEsR0FBR0E7UUFDeEJ0bUQsUUFBUXduRSxlQUFlLEdBQUdBO1FBQ3RCLE9BQU94bkU7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGlmb2xpbzIwMjQvLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanM/ZDVkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gJCQkcmVjb25jaWxlcigkJCRob3N0Q29uZmlnKSB7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBTY2hlZHVsZXIgPSByZXF1aXJlKCdzY2hlZHVsZXInKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBzdXBwcmVzc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpIHtcbiAge1xuICAgIHN1cHByZXNzV2FybmluZyA9IG5ld1N1cHByZXNzV2FybmluZztcbiAgfVxufSAvLyBJbiBERVYsIGNhbGxzIHRvIGNvbnNvbGUud2FybiBhbmQgY29uc29sZS5lcnJvciBnZXQgcmVwbGFjZWRcbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGlmICghc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBlbmFibGVQZXJzaXN0ZW50T2Zmc2NyZWVuSG9zdENvbnRhaW5lciA9IGZhbHNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdGhlIHJlYWN0LXJlY29uY2lsZXIgcGFja2FnZS5cblxudmFyIGVuYWJsZU5ld1JlY29uY2lsZXIgPSBmYWxzZTsgLy8gU3VwcG9ydCBsZWdhY3kgUHJpbWVyIHN1cHBvcnQgb24gaW50ZXJuYWwgRkIgd3d3XG5cbnZhciBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uID0gZmFsc2U7IC8vIEZCLW9ubHkgdXNhZ2UuIFRoZSBuZXcgQVBJIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzLlxuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuXG52YXIgZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjayA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRml6elxudmFyIHdhcm5BYm91dFN0cmluZ1JlZnMgPSBmYWxzZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlYnVnZ2luZyBhbmQgRGV2VG9vbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuLy8gZm9yIGFuIGV4cGVyaW1lbnRhbCB0aW1lbGluZSB0b29sLlxuXG52YXIgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyID0gdHJ1ZTsgLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIHJlbmRlci1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlXG5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyA9IHRydWU7IC8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAyOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG5cbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgRnJhZ21lbnQgPSA3O1xudmFyIE1vZGUgPSA4O1xudmFyIENvbnRleHRDb25zdW1lciA9IDk7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG52YXIgRm9yd2FyZFJlZiA9IDExO1xudmFyIFByb2ZpbGVyID0gMTI7XG52YXIgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbnZhciBNZW1vQ29tcG9uZW50ID0gMTQ7XG52YXIgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xudmFyIExhenlDb21wb25lbnQgPSAxNjtcbnZhciBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbnZhciBEZWh5ZHJhdGVkRnJhZ21lbnQgPSAxODtcbnZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIE9mZnNjcmVlbkNvbXBvbmVudCA9IDIyO1xudmFyIExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IDIzO1xudmFyIENhY2hlQ29tcG9uZW50ID0gMjQ7XG52YXIgVHJhY2luZ01hcmtlckNvbXBvbmVudCA9IDI1O1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKTtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QudHJhY2luZ19tYXJrZXInKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUkMShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lJDEodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgdmFyIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnQ2FjaGUnO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lJDEocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRGVoeWRyYXRlZEZyYWdtZW50JztcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSQxKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgLy8gSG9zdCBjb21wb25lbnQgdHlwZSBpcyB0aGUgZGlzcGxheSBuYW1lIChlLmcuIFwiZGl2XCIsIFwiVmlld1wiKVxuICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuICdSb290JztcblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gJ1RleHQnO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgLy8gTmFtZSBjb21lcyBmcm9tIHRoZSB0eXBlIGluIHRoaXMgY2FzZTsgd2UgZG9uJ3QgaGF2ZSBhIHRhZy5cbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSkge1xuICAgICAgICAvLyBEb24ndCBiZSBsZXNzIHNwZWNpZmljIHRoYW4gc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuICAgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ01vZGUnO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTY29wZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnVHJhY2luZ01hcmtlcic7XG4gICAgLy8gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhpcyB0YWdzIGNvbWUgZnJvbSB0aGUgdXNlci1wcm92aWRlZCB0eXBlOlxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuUGxhY2VtZW50IHwgVXBkYXRlO1xudmFyIENoaWxkRGVsZXRpb24gPVxuLyogICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENvbnRlbnRSZXNldCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIENhbGxiYWNrID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjY0O1xudmFyIERpZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBGb3JjZUNsaWVudFJlbmRlciA9XG4vKiAgICAgICAgICAgICovXG4yNTY7XG52YXIgUmVmID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyO1xudmFyIFNuYXBzaG90ID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgUGFzc2l2ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBIeWRyYXRpbmcgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIEh5ZHJhdGluZ0FuZFVwZGF0ZSA9XG4vKiAgICAgICAgICAgKi9cbkh5ZHJhdGluZyB8IFVwZGF0ZTtcbnZhciBWaXNpYmlsaXR5ID1cbi8qICAgICAgICAgICAgICAgICAgICovXG44MTkyO1xudmFyIFN0b3JlQ29uc2lzdGVuY3kgPVxuLyogICAgICAgICAgICAgKi9cbjE2Mzg0O1xudmFyIExpZmVjeWNsZUVmZmVjdE1hc2sgPSBQYXNzaXZlIHwgVXBkYXRlIHwgQ2FsbGJhY2sgfCBSZWYgfCBTbmFwc2hvdCB8IFN0b3JlQ29uc2lzdGVuY3k7IC8vIFVuaW9uIG9mIGFsbCBjb21taXQgZmxhZ3MgKGZsYWdzIHdpdGggdGhlIGxpZmV0aW1lIG9mIGEgcGFydGljdWxhciBjb21taXQpXG5cbnZhciBIb3N0RWZmZWN0TWFzayA9XG4vKiAgICAgICAgICAgICAgICovXG4zMjc2NzsgLy8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cblxudmFyIEluY29tcGxldGUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFNob3VsZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgKi9cbjY1NTM2O1xudmFyIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UgPVxuLyogKi9cbjEzMTA3MjtcbnZhciBGb3JrZWQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4xMDQ4NTc2OyAvLyBTdGF0aWMgdGFncyBkZXNjcmliZSBhc3BlY3RzIG9mIGEgZmliZXIgdGhhdCBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLFxuLy8gZS5nLiBhIGZpYmVyIHVzZXMgYSBwYXNzaXZlIGVmZmVjdCAoZXZlbiBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlcyBvbiB0aGlzIHBhcnRpY3VsYXIgcmVuZGVyKS5cbi8vIFRoaXMgZW5hYmxlcyB1cyB0byBkZWZlciBtb3JlIHdvcmsgaW4gdGhlIHVubW91bnQgY2FzZSxcbi8vIHNpbmNlIHdlIGNhbiBkZWZlciB0cmF2ZXJzaW5nIHRoZSB0cmVlIGR1cmluZyBsYXlvdXQgdG8gbG9vayBmb3IgUGFzc2l2ZSBlZmZlY3RzLFxuLy8gYW5kIGluc3RlYWQgcmVseSBvbiB0aGUgc3RhdGljIGZsYWcgYXMgYSBzaWduYWwgdGhhdCB0aGVyZSBtYXkgYmUgY2xlYW51cCB3b3JrLlxuXG52YXIgUmVmU3RhdGljID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBMYXlvdXRTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgICovXG40MTk0MzA0O1xudmFyIFBhc3NpdmVTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7IC8vIFRoZXNlIGZsYWdzIGFsbG93IHVzIHRvIHRyYXZlcnNlIHRvIGZpYmVycyB0aGF0IGhhdmUgZWZmZWN0cyBvbiBtb3VudFxuLy8gd2l0aG91dCB0cmF2ZXJzaW5nIHRoZSBlbnRpcmUgdHJlZSBhZnRlciBldmVyeSBjb21taXQgZm9yXG4vLyBkb3VibGUgaW52b2tpbmdcblxudmFyIE1vdW50TGF5b3V0RGV2ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIE1vdW50UGFzc2l2ZURldiA9XG4vKiAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyOyAvLyBHcm91cHMgb2YgZmxhZ3MgdGhhdCBhcmUgdXNlZCBpbiB0aGUgY29tbWl0IHBoYXNlIHRvIHNraXAgb3ZlciB0cmVlcyB0aGF0XG4vLyBkb24ndCBjb250YWluIGVmZmVjdHMsIGJ5IGNoZWNraW5nIHN1YnRyZWVGbGFncy5cblxudmFyIEJlZm9yZU11dGF0aW9uTWFzayA9IC8vIFRPRE86IFJlbW92ZSBVcGRhdGUgZmxhZyBmcm9tIGJlZm9yZSBtdXRhdGlvbiBwaGFzZSBieSByZS1sYW5kaW5nIFZpc2liaWxpdHlcbi8vIGZsYWcgbG9naWMgKHNlZSAjMjAwNDMpXG5VcGRhdGUgfCBTbmFwc2hvdCB8ICggMCk7XG52YXIgTXV0YXRpb25NYXNrID0gUGxhY2VtZW50IHwgVXBkYXRlIHwgQ2hpbGREZWxldGlvbiB8IENvbnRlbnRSZXNldCB8IFJlZiB8IEh5ZHJhdGluZyB8IFZpc2liaWxpdHk7XG52YXIgTGF5b3V0TWFzayA9IFVwZGF0ZSB8IENhbGxiYWNrIHwgUmVmIHwgVmlzaWJpbGl0eTsgLy8gVE9ETzogU3BsaXQgaW50byBQYXNzaXZlTW91bnRNYXNrIGFuZCBQYXNzaXZlVW5tb3VudE1hc2tcblxudmFyIFBhc3NpdmVNYXNrID0gUGFzc2l2ZSB8IENoaWxkRGVsZXRpb247IC8vIFVuaW9uIG9mIHRhZ3MgdGhhdCBkb24ndCBnZXQgcmVzZXQgb24gY2xvbmVzLlxuLy8gVGhpcyBhbGxvd3MgY2VydGFpbiBjb25jZXB0cyB0byBwZXJzaXN0IHdpdGhvdXQgcmVjYWxjdWxhdGluZyB0aGVtLFxuLy8gZS5nLiB3aGV0aGVyIGEgc3VidHJlZSBjb250YWlucyBwYXNzaXZlIGVmZmVjdHMgb3IgcG9ydGFscy5cblxudmFyIFN0YXRpY01hc2sgPSBMYXlvdXRTdGF0aWMgfCBQYXNzaXZlU3RhdGljIHwgUmVmU3RhdGljO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmV4dE5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG5cbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcblxuICAgIGlmIChwYXJlbnRBID09PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cbiAgICBpZiAocGFyZW50QiA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4gICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgLy8gaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiB0aGUgU3VzcGVuc2UgZmliZXIgYW5kIGl0cyBjaGlsZHJlbi4gU2tpcFxuICAgICAgLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbiAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cbiAgICAgIGlmIChuZXh0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGEgPSBiID0gbmV4dFBhcmVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSdyZSBhdCB0aGUgcm9vdC5cblxuXG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cblxuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH0gLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyAnICsgJ2luIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhLmFsdGVybmF0ZSAhPT0gYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIiArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG5cblxuICBpZiAoYS50YWcgIT09IEhvc3RSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gIH1cblxuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuXG5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGN1cnJlbnRQYXJlbnQpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY2hpbGQpO1xuXG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICByZXR1cm4gY3VycmVudFBhcmVudCAhPT0gbnVsbCA/IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY3VycmVudFBhcmVudCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoY2hpbGQudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGNoaWxkKTtcblxuICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGlzIGlzIGEgaG9zdCBjb25maWcgdGhhdCdzIHVzZWQgZm9yIHRoZSBgcmVhY3QtcmVjb25jaWxlcmAgcGFja2FnZSBvbiBucG0uXG4vLyBJdCBpcyBvbmx5IHVzZWQgYnkgdGhpcmQtcGFydHkgcmVuZGVyZXJzLlxuLy9cbi8vIEl0cyBBUEkgbGV0cyB5b3UgcGFzcyB0aGUgaG9zdCBjb25maWcgYXMgYW4gYXJndW1lbnQuXG4vLyBIb3dldmVyLCBpbnNpZGUgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCB3ZSB0cmVhdCBob3N0IGNvbmZpZyBhcyBhIG1vZHVsZS5cbi8vIFRoaXMgZmlsZSBpcyBhIHNoaW0gYmV0d2VlbiB0d28gd29ybGRzLlxuLy9cbi8vIEl0IHdvcmtzIGJlY2F1c2UgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCBidW5kbGUgaXMgd3JhcHBlZCBpbiBzb21ldGhpbmcgbGlrZTpcbi8vXG4vLyBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkJCRjb25maWcpIHtcbi8vICAgLyogcmVjb25jaWxlciBjb2RlICovXG4vLyB9XG4vL1xuLy8gU28gYCQkJGNvbmZpZ2AgbG9va3MgbGlrZSBhIGdsb2JhbCB2YXJpYWJsZSwgYnV0IGl0J3Ncbi8vIHJlYWxseSBhbiBhcmd1bWVudCB0byBhIHRvcC1sZXZlbCB3cmFwcGluZyBmdW5jdGlvbi5cbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbnZhciBnZXRQdWJsaWNJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZ2V0UHVibGljSW5zdGFuY2U7XG52YXIgZ2V0Um9vdEhvc3RDb250ZXh0ID0gJCQkaG9zdENvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG52YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9ICQkJGhvc3RDb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dDtcbnZhciBwcmVwYXJlRm9yQ29tbWl0ID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlRm9yQ29tbWl0O1xudmFyIHJlc2V0QWZ0ZXJDb21taXQgPSAkJCRob3N0Q29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG52YXIgY3JlYXRlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNyZWF0ZUluc3RhbmNlO1xudmFyIGFwcGVuZEluaXRpYWxDaGlsZCA9ICQkJGhvc3RDb25maWcuYXBwZW5kSW5pdGlhbENoaWxkO1xudmFyIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gJCQkaG9zdENvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbjtcbnZhciBwcmVwYXJlVXBkYXRlID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlVXBkYXRlO1xudmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gJCQkaG9zdENvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudDtcbnZhciBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZTtcbnZhciBzY2hlZHVsZVRpbWVvdXQgPSAkJCRob3N0Q29uZmlnLnNjaGVkdWxlVGltZW91dDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gJCQkaG9zdENvbmZpZy5jYW5jZWxUaW1lb3V0O1xudmFyIG5vVGltZW91dCA9ICQkJGhvc3RDb25maWcubm9UaW1lb3V0O1xudmFyIG5vdyA9ICQkJGhvc3RDb25maWcubm93O1xudmFyIGlzUHJpbWFyeVJlbmRlcmVyID0gJCQkaG9zdENvbmZpZy5pc1ByaW1hcnlSZW5kZXJlcjtcbnZhciB3YXJuc0lmTm90QWN0aW5nID0gJCQkaG9zdENvbmZpZy53YXJuc0lmTm90QWN0aW5nO1xudmFyIHN1cHBvcnRzTXV0YXRpb24gPSAkJCRob3N0Q29uZmlnLnN1cHBvcnRzTXV0YXRpb247XG52YXIgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGhvc3RDb25maWcuc3VwcG9ydHNQZXJzaXN0ZW5jZTtcbnZhciBzdXBwb3J0c0h5ZHJhdGlvbiA9ICQkJGhvc3RDb25maWcuc3VwcG9ydHNIeWRyYXRpb247XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9ICQkJGhvc3RDb25maWcuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbnZhciBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIgPSAkJCRob3N0Q29uZmlnLmJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjtcbnZhciBhZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICQkJGhvc3RDb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG52YXIgcHJlcGFyZVBvcnRhbE1vdW50ID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG52YXIgcHJlcGFyZVNjb3BlVXBkYXRlID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG52YXIgZ2V0SW5zdGFuY2VGcm9tU2NvcGUgPSAkJCRob3N0Q29uZmlnLmdldEluc3RhbmNlRnJvbVNjb3BlO1xudmFyIGdldEN1cnJlbnRFdmVudFByaW9yaXR5ID0gJCQkaG9zdENvbmZpZy5nZXRDdXJyZW50RXZlbnRQcmlvcml0eTtcbnZhciBkZXRhY2hEZWxldGVkSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRldGFjaERlbGV0ZWRJbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgICBNaWNyb3Rhc2tzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNNaWNyb3Rhc2tzID0gJCQkaG9zdENvbmZpZy5zdXBwb3J0c01pY3JvdGFza3M7XG52YXIgc2NoZWR1bGVNaWNyb3Rhc2sgPSAkJCRob3N0Q29uZmlnLnNjaGVkdWxlTWljcm90YXNrOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgIFRlc3Qgc2VsZWN0b3JzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNUZXN0U2VsZWN0b3JzID0gJCQkaG9zdENvbmZpZy5zdXBwb3J0c1Rlc3RTZWxlY3RvcnM7XG52YXIgZmluZEZpYmVyUm9vdCA9ICQkJGhvc3RDb25maWcuZmluZEZpYmVyUm9vdDtcbnZhciBnZXRCb3VuZGluZ1JlY3QgPSAkJCRob3N0Q29uZmlnLmdldEJvdW5kaW5nUmVjdDtcbnZhciBnZXRUZXh0Q29udGVudCA9ICQkJGhvc3RDb25maWcuZ2V0VGV4dENvbnRlbnQ7XG52YXIgaXNIaWRkZW5TdWJ0cmVlID0gJCQkaG9zdENvbmZpZy5pc0hpZGRlblN1YnRyZWU7XG52YXIgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSA9ICQkJGhvc3RDb25maWcubWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZTtcbnZhciBzZXRGb2N1c0lmRm9jdXNhYmxlID0gJCQkaG9zdENvbmZpZy5zZXRGb2N1c0lmRm9jdXNhYmxlO1xudmFyIHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAkJCRob3N0Q29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgTXV0YXRpb25cbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBhcHBlbmRDaGlsZCA9ICQkJGhvc3RDb25maWcuYXBwZW5kQ2hpbGQ7XG52YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjtcbnZhciBjb21taXRUZXh0VXBkYXRlID0gJCQkaG9zdENvbmZpZy5jb21taXRUZXh0VXBkYXRlO1xudmFyIGNvbW1pdE1vdW50ID0gJCQkaG9zdENvbmZpZy5jb21taXRNb3VudDtcbnZhciBjb21taXRVcGRhdGUgPSAkJCRob3N0Q29uZmlnLmNvbW1pdFVwZGF0ZTtcbnZhciBpbnNlcnRCZWZvcmUgPSAkJCRob3N0Q29uZmlnLmluc2VydEJlZm9yZTtcbnZhciBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9ICQkJGhvc3RDb25maWcuaW5zZXJ0SW5Db250YWluZXJCZWZvcmU7XG52YXIgcmVtb3ZlQ2hpbGQgPSAkJCRob3N0Q29uZmlnLnJlbW92ZUNoaWxkO1xudmFyIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xudmFyIHJlc2V0VGV4dENvbnRlbnQgPSAkJCRob3N0Q29uZmlnLnJlc2V0VGV4dENvbnRlbnQ7XG52YXIgaGlkZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oaWRlSW5zdGFuY2U7XG52YXIgaGlkZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaGlkZVRleHRJbnN0YW5jZTtcbnZhciB1bmhpZGVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcudW5oaWRlSW5zdGFuY2U7XG52YXIgdW5oaWRlVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy51bmhpZGVUZXh0SW5zdGFuY2U7XG52YXIgY2xlYXJDb250YWluZXIgPSAkJCRob3N0Q29uZmlnLmNsZWFyQ29udGFpbmVyOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgUGVyc2lzdGVuY2Vcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBjbG9uZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jbG9uZUluc3RhbmNlO1xudmFyIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gJCQkaG9zdENvbmZpZy5jcmVhdGVDb250YWluZXJDaGlsZFNldDtcbnZhciBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRob3N0Q29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldDtcbnZhciBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkaG9zdENvbmZpZy5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuO1xudmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9ICQkJGhvc3RDb25maWcucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuO1xudmFyIGdldE9mZnNjcmVlbkNvbnRhaW5lclR5cGUgPSAkJCRob3N0Q29uZmlnLmdldE9mZnNjcmVlbkNvbnRhaW5lclR5cGU7XG52YXIgZ2V0T2Zmc2NyZWVuQ29udGFpbmVyUHJvcHMgPSAkJCRob3N0Q29uZmlnLmdldE9mZnNjcmVlbkNvbnRhaW5lclByb3BzO1xudmFyIGNsb25lSGlkZGVuSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNsb25lSGlkZGVuSW5zdGFuY2U7XG52YXIgY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNsb25lSGlkZGVuVGV4dEluc3RhbmNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgSHlkcmF0aW9uXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jYW5IeWRyYXRlSW5zdGFuY2U7XG52YXIgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyA9ICQkJGhvc3RDb25maWcuaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZztcbnZhciBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayA9ICQkJGhvc3RDb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2s7XG52YXIgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkgPSAkJCRob3N0Q29uZmlnLnJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5O1xudmFyIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9ICQkJGhvc3RDb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nO1xudmFyIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gJCQkaG9zdENvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDtcbnZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXI7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgaHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oeWRyYXRlSW5zdGFuY2U7XG52YXIgaHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBjb21taXRIeWRyYXRlZENvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXI7XG52YXIgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2U7XG52YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5ID0gJCQkaG9zdENvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnk7XG52YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcjtcbnZhciBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyA9ICQkJGhvc3RDb25maWcuc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXM7XG52YXIgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTtcbnZhciBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlO1xudmFyIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyO1xudmFyIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RIeWRyYXRlSW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcjtcbnZhciBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXI7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlV2l0aGluQ29udGFpbmVyID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXI7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlO1xudmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlO1xudmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTtcbnZhciBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZXJyb3JIeWRyYXRpbmdDb250YWluZXIgPSAkJCRob3N0Q29uZmlnLmVycm9ySHlkcmF0aW5nQ29udGFpbmVyO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xudmFyIGZpYmVyU3RhY2s7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG52YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O1xuXG57XG4gIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufSAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlDb250ZXh0T2JqZWN0KTsgLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cblxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIpIHtcbiAge1xuICAgIGlmIChkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIgJiYgaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgICAgLy8gd2UgbWF5IGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9IC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gICAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuXG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICB7XG4gICAgaWYgKGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzOyAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gICAgLy8gSWYgdGhlIGluc3RhbmNlIGRvZXMgbm90IGV4aXN0IHlldCwgd2Ugd2lsbCBwdXNoIG51bGwgYXQgZmlyc3QsXG4gICAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuXG4gICAgdmFyIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgfHwgZW1wdHlDb250ZXh0T2JqZWN0OyAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gICAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG5cbiAgICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHR5cGUsIGRpZENoYW5nZSkge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuICAgICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7IC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG5cbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7IC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuXG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICAvLyBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgd2l0aCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsgbm90IHN1cmUgaWYgaXRcbiAgICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgICBpZiAoIWlzRmliZXJNb3VudGVkKGZpYmVyKSB8fCBmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IG5vZGUudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHBhcmVudC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbnZhciBMZWdhY3lSb290ID0gMDtcbnZhciBDb25jdXJyZW50Um9vdCA9IDE7XG5cbnZhciBOb01vZGUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7IC8vIFRPRE86IFJlbW92ZSBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3QgdGFnIGluc3RlYWRcblxudmFyIENvbmN1cnJlbnRNb2RlID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBQcm9maWxlTW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgU3RyaWN0TGVnYWN5TW9kZSA9XG4vKiAgICAgICAgICAgICAgICovXG44O1xudmFyIFN0cmljdEVmZmVjdHNNb2RlID1cbi8qICAgICAgICAgICAgICAqL1xuMTY7XG5cbi8vIFRPRE86IFRoaXMgaXMgcHJldHR5IHdlbGwgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzLiBNYXliZSB3ZSBjYW4gZHJvcCBpdC5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbmZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICB2YXIgYXNVaW50ID0geCA+Pj4gMDtcblxuICBpZiAoYXNVaW50ID09PSAwKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9XG5cbiAgcmV0dXJuIDMxIC0gKGxvZyhhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBJZiB0aG9zZSB2YWx1ZXMgYXJlIGNoYW5nZWQgdGhhdCBwYWNrYWdlIHNob3VsZCBiZSByZWJ1aWx0IGFuZCByZWRlcGxveWVkLlxuXG52YXIgVG90YWxMYW5lcyA9IDMxO1xudmFyIE5vTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBOb0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIFN5bmNMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAqL1xuMjtcbnZhciBJbnB1dENvbnRpbnVvdXNMYW5lID1cbi8qICAgICAgICAgICAgKi9cbjQ7XG52YXIgRGVmYXVsdEh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAqL1xuODtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBUcmFuc2l0aW9uTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG40MTk0MjQwO1xudmFyIFRyYW5zaXRpb25MYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG42NDtcbnZhciBUcmFuc2l0aW9uTGFuZTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFRyYW5zaXRpb25MYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgVHJhbnNpdGlvbkxhbmU0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBUcmFuc2l0aW9uTGFuZTUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBUcmFuc2l0aW9uTGFuZTYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBUcmFuc2l0aW9uTGFuZTcgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBUcmFuc2l0aW9uTGFuZTggPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBUcmFuc2l0aW9uTGFuZTkgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTYzODQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxMCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFRyYW5zaXRpb25MYW5lMTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBUcmFuc2l0aW9uTGFuZTEyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTMxMDcyO1xudmFyIFRyYW5zaXRpb25MYW5lMTMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4yNjIxNDQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUyNDI4ODtcbnZhciBUcmFuc2l0aW9uTGFuZTE1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTE2ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMzAwMjM0MjQ7XG52YXIgUmV0cnlMYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxOTQzMDQ7XG52YXIgUmV0cnlMYW5lMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7XG52YXIgUmV0cnlMYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIFJldHJ5TGFuZTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBSZXRyeUxhbmU1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjcxMDg4NjQ7XG52YXIgU29tZVJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAqL1xuMTM0MjE3NzI4O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNjg0MzU0NTU7XG52YXIgSWRsZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAqL1xuMjY4NDM1NDU2O1xudmFyIElkbGVMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xudmFyIE9mZnNjcmVlbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEwNzM3NDE4MjQ7IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgdGhlIGV4cGVyaW1lbnRhbCB0aW1lbGluZSAocmVhY3QtZGV2dG9vbHMtdGltZWxpbmUpXG4vLyBJdCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIExhbmVzIHZhbHVlcyBhYm92ZS5cblxuZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpIHtcbiAge1xuICAgIGlmIChsYW5lICYgU3luY0xhbmUpIHtcbiAgICAgIHJldHVybiAnU3luYyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91c0h5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNMYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91cyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZhdWx0SHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZhdWx0SHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIERlZmF1bHRMYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmF1bHQnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbkh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBSZXRyeUxhbmVzKSB7XG4gICAgICByZXR1cm4gJ1JldHJ5JztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnU2VsZWN0aXZlSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElkbGVIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lkbGVIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSWRsZUxhbmUpIHtcbiAgICAgIHJldHVybiAnSWRsZSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG4gICAgfVxuICB9XG59XG52YXIgTm9UaW1lc3RhbXAgPSAtMTtcbnZhciBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG52YXIgbmV4dFJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIHN3aXRjaCAoZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykpIHtcbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgICAgcmV0dXJuIFN5bmNMYW5lO1xuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgcmV0dXJuIERlZmF1bHRMYW5lO1xuXG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNjpcbiAgICAgIHJldHVybiBsYW5lcyAmIFRyYW5zaXRpb25MYW5lcztcblxuICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICBjYXNlIFJldHJ5TGFuZTI6XG4gICAgY2FzZSBSZXRyeUxhbmUzOlxuICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICBjYXNlIFJldHJ5TGFuZTU6XG4gICAgICByZXR1cm4gbGFuZXMgJiBSZXRyeUxhbmVzO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElkbGVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIHJldHVybiBJZGxlTGFuZTtcblxuICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcbiAgICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgICAgIHJldHVybiBsYW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybiBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIG5leHRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7IC8vIERvIG5vdCB3b3JrIG9uIGFueSBpZGxlIHdvcmsgdW50aWwgYWxsIHRoZSBub24taWRsZSB3b3JrIGhhcyBmaW5pc2hlZCxcbiAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG5cbiAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiBOb25JZGxlTGFuZXM7XG5cbiAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbm9uSWRsZVVuYmxvY2tlZExhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgIGlmIChub25JZGxlVW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgIGlmIChub25JZGxlUGluZ2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbiAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICBpZiAodW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cblxuICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4gIC8vIGJvdGhlciB3YWl0aW5nIHVudGlsIHRoZSByb290IGlzIGNvbXBsZXRlLlxuICAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbmV4dExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7XG4gICAgdmFyIHdpcExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHdpcExhbmVzKTtcblxuICAgIGlmICggLy8gVGVzdHMgd2hldGhlciB0aGUgbmV4dCBsYW5lIGlzIGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5IHRoYW4gdGhlIHdpcFxuICAgIC8vIG9uZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXRzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICAgIG5leHRMYW5lID49IHdpcExhbmUgfHwgLy8gRGVmYXVsdCBwcmlvcml0eSB1cGRhdGVzIHNob3VsZCBub3QgaW50ZXJydXB0IHRyYW5zaXRpb24gdXBkYXRlcy4gVGhlXG4gICAgLy8gb25seSBkaWZmZXJlbmNlIGJldHdlZW4gZGVmYXVsdCB1cGRhdGVzIGFuZCB0cmFuc2l0aW9uIHVwZGF0ZXMgaXMgdGhhdFxuICAgIC8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxuICAgIG5leHRMYW5lID09PSBEZWZhdWx0TGFuZSAmJiAod2lwTGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICAgIC8vIEtlZXAgd29ya2luZyBvbiB0aGUgZXhpc3RpbmcgaW4tcHJvZ3Jlc3MgdHJlZS4gRG8gbm90IGludGVycnVwdC5cbiAgICAgIHJldHVybiB3aXBMYW5lcztcbiAgICB9XG4gIH1cblxuICBpZiAoKG5leHRMYW5lcyAmIElucHV0Q29udGludW91c0xhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gV2hlbiB1cGRhdGVzIGFyZSBzeW5jIGJ5IGRlZmF1bHQsIHdlIGVudGFuZ2xlIGNvbnRpbnVvdXMgcHJpb3JpdHkgdXBkYXRlc1xuICAgIC8vIGFuZCBkZWZhdWx0IHVwZGF0ZXMsIHNvIHRoZXkgcmVuZGVyIGluIHRoZSBzYW1lIGJhdGNoLiBUaGUgb25seSByZWFzb25cbiAgICAvLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG4gICAgLy8gdHJhbnNpdGlvbnMsIGJ1dCBkZWZhdWx0IHVwZGF0ZXMgc2hvdWxkIG5vdC5cbiAgICBuZXh0TGFuZXMgfD0gcGVuZGluZ0xhbmVzICYgRGVmYXVsdExhbmU7XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcy4gVGhlIGNvdW50ZXItYXJndW1lbnQgaXMgdGhhdCB0aGUgcGFydGlhbCB3b3JrXG4gIC8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gIC8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG4gIC8vIHRpbWUgaXQgdGFrZXMgdG8gc2hvdyB0aGUgZmluYWwgc3RhdGUsIHdoaWNoIGlzIHdoYXQgdGhleSBhcmUgYWN0dWFsbHlcbiAgLy8gd2FpdGluZyBmb3IuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LCBsaWtlXG4gIC8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4gIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG4gIHZhciBlbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG5cbiAgaWYgKGVudGFuZ2xlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gICAgdmFyIGxhbmVzID0gbmV4dExhbmVzICYgZW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIG5leHRMYW5lcyB8PSBlbnRhbmdsZW1lbnRzW2luZGV4XTtcbiAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV2ZW50VGltZSA9IGV2ZW50VGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV2ZW50VGltZSA+IG1vc3RSZWNlbnRFdmVudFRpbWUpIHtcbiAgICAgIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBldmVudFRpbWU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICByZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIHN3aXRjaCAobGFuZSkge1xuICAgIGNhc2UgU3luY0xhbmU6XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgc2V0IHRvIHRoZSBjb3JyZXNwb25kaW5nIGNvbnN0YW50IGFzIGluIFNjaGVkdWxlci5qcy5cbiAgICAgIC8vIFdoZW4gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZ1xuICAgICAgLy8gdGhlcmUncyBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCdzIGJlaW5nIHN0YXJ2ZWQgYnkgYSBzZXJpZXMgb2ZcbiAgICAgIC8vIHN5bmNocm9ub3VzIHVwZGF0ZXMuIElmIHRoYXQgdGhlb3J5IGlzIGNvcnJlY3QsIHRoZSBwcm9wZXIgc29sdXRpb24gaXNcbiAgICAgIC8vIHRvIGZpeCB0aGUgc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0XG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzIGFyZSBhbiBpbXBvcnRhbnQgc2FmZWd1YXJkIHdoZW4gc3RhcnZhdGlvblxuICAgICAgLy8gZG9lcyBoYXBwZW4uXG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyAyNTA7XG5cbiAgICBjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgIGNhc2UgUmV0cnlMYW5lNTpcbiAgICAgIC8vIFRPRE86IFJldHJpZXMgc2hvdWxkIGJlIGFsbG93ZWQgdG8gZXhwaXJlIGlmIHRoZXkgYXJlIENQVSBib3VuZCBmb3JcbiAgICAgIC8vIHRvbyBsb25nLCBidXQgd2hlbiBJIG1hZGUgdGhpcyBjaGFuZ2UgaXQgY2F1c2VkIGEgc3Bpa2UgaW4gYnJvd3NlclxuICAgICAgLy8gY3Jhc2hlcy4gVGhlcmUgbXVzdCBiZSBzb21lIG90aGVyIHVuZGVybHlpbmcgYnVnOyBub3Qgc3VwZXIgdXJnZW50IGJ1dFxuICAgICAgLy8gaWRlYWxseSBzaG91bGQgZmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gVW5mb3J0dW5hdGVseSB3ZSBkb24ndCBoYXZlXG4gICAgICAvLyBhIHJlcHJvIGZvciB0aGUgY3Jhc2hlcywgb25seSBkZXRlY3RlZCB2aWEgcHJvZHVjdGlvbiBtZXRyaWNzLlxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICBjYXNlIE9mZnNjcmVlbkxhbmU6XG4gICAgICAvLyBBbnl0aGluZyBpZGxlIHByaW9yaXR5IG9yIGxvd2VyIHNob3VsZCBuZXZlciBleHBpcmUuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3JpbmdcbiAgLy8gdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZSBvbiB0aGUgcm9vdC4gVGhlbiB1c2UgdGhhdCB0byBxdWlja2x5IGJhaWwgb3V0XG4gIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbiAgLy8gZXhwaXJhdGlvbiB0aW1lLiBJZiBzbywgd2UnbGwgYXNzdW1lIHRoZSB1cGRhdGUgaXMgYmVpbmcgc3RhcnZlZCBhbmQgbWFya1xuICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuICAgICAgLy8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3JcbiAgICAgIC8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgaWYgKChsYW5lICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzIHx8IChsYW5lICYgcGluZ2VkTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIC8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufSAvLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuLy8gYXJlIHN1c3BlbmRlZC5cblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpIHtcbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHJvb3QucGVuZGluZ0xhbmVzKTtcbn1cbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNTeW5jTGFuZShsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgU3luY0xhbmUpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSB7XG5cbiAgdmFyIFN5bmNEZWZhdWx0TGFuZXMgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRIeWRyYXRpb25MYW5lIHwgRGVmYXVsdExhbmU7XG4gIHJldHVybiAobGFuZXMgJiBTeW5jRGVmYXVsdExhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCwgbGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhIHNlcGFyYXRlIGNoZWNrIGZyb20gaW5jbHVkZXNCbG9ja2luZ0xhbmUgYmVjYXVzZSBhIGxhbmUgY2FuXG4gIC8vIGV4cGlyZSBhZnRlciBhIHJlbmRlciBoYXMgYWxyZWFkeSBzdGFydGVkLlxuICByZXR1cm4gKGxhbmVzICYgcm9vdC5leHBpcmVkTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uTGFuZShsYW5lKSB7XG4gIHJldHVybiAobGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IDA7XG59XG5mdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpIHtcbiAgLy8gQ3ljbGUgdGhyb3VnaCB0aGUgbGFuZXMsIGFzc2lnbmluZyBlYWNoIG5ldyB0cmFuc2l0aW9uIHRvIHRoZSBuZXh0IGxhbmUuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgbWVhbnMgZXZlcnkgdHJhbnNpdGlvbiBnZXRzIGl0cyBvd24gbGFuZSwgdW50aWwgd2VcbiAgLy8gcnVuIG91dCBvZiBsYW5lcyBhbmQgY3ljbGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLlxuICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuXG4gIGlmICgobmV4dFRyYW5zaXRpb25MYW5lICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gMCkge1xuICAgIG5leHRUcmFuc2l0aW9uTGFuZSA9IFRyYW5zaXRpb25MYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gIG5leHRSZXRyeUxhbmUgPDw9IDE7XG5cbiAgaWYgKChuZXh0UmV0cnlMYW5lICYgUmV0cnlMYW5lcykgPT09IDApIHtcbiAgICBuZXh0UmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykge1xuICByZXR1cm4gbGFuZXMgJiAtbGFuZXM7XG59XG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdExhbmVzKGEsIGIpIHtcbiAgcmV0dXJuIGEgJiBiO1xufSAvLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuXG5mdW5jdGlvbiBsYW5lVG9MYW5lcyhsYW5lKSB7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gaGlnaGVyUHJpb3JpdHlMYW5lKGEsIGIpIHtcbiAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXQgcmFuZ2VzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICByZXR1cm4gYSAhPT0gTm9MYW5lICYmIGEgPCBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgLy8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG4gIC8vIGh0dHBzOi8vdjguZGV2L2Jsb2cvZWxlbWVudHMta2luZHMjYXZvaWQtY3JlYXRpbmctaG9sZXNcbiAgdmFyIGxhbmVNYXAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFRvdGFsTGFuZXM7IGkrKykge1xuICAgIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHVwZGF0ZUxhbmUsIGV2ZW50VGltZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lOyAvLyBJZiB0aGVyZSBhcmUgYW55IHN1c3BlbmRlZCB0cmFuc2l0aW9ucywgaXQncyBwb3NzaWJsZSB0aGlzIG5ldyB1cGRhdGVcbiAgLy8gY291bGQgdW5ibG9jayB0aGVtLiBDbGVhciB0aGUgc3VzcGVuZGVkIGxhbmVzIHNvIHRoYXQgd2UgY2FuIHRyeSByZW5kZXJpbmdcbiAgLy8gdGhlbSBhZ2Fpbi5cbiAgLy9cbiAgLy8gVE9ETzogV2UgcmVhbGx5IG9ubHkgbmVlZCB0byB1bnN1c3BlbmQgb25seSBsYW5lcyB0aGF0IGFyZSBpbiB0aGVcbiAgLy8gYHN1YnRyZWVMYW5lc2Agb2YgdGhlIHVwZGF0ZWQgZmliZXIsIG9yIHRoZSB1cGRhdGUgbGFuZXMgb2YgdGhlIHJldHVyblxuICAvLyBwYXRoLiBUaGlzIHdvdWxkIGV4Y2x1ZGUgc3VzcGVuZGVkIHVwZGF0ZXMgaW4gYW4gdW5yZWxhdGVkIHNpYmxpbmcgdHJlZSxcbiAgLy8gc2luY2UgdGhlcmUncyBubyB3YXkgZm9yIHRoaXMgdXBkYXRlIHRvIHVuYmxvY2sgaXQuXG4gIC8vXG4gIC8vIFdlIGRvbid0IGRvIHRoaXMgaWYgdGhlIGluY29taW5nIHVwZGF0ZSBpcyBpZGxlLCBiZWNhdXNlIHdlIG5ldmVyIHByb2Nlc3NcbiAgLy8gaWRsZSB1cGRhdGVzIHVudGlsIGFmdGVyIGFsbCB0aGUgcmVndWxhciB1cGRhdGVzIGhhdmUgZmluaXNoZWQ7IHRoZXJlJ3Mgbm9cbiAgLy8gd2F5IGl0IGNvdWxkIHVuYmxvY2sgYSB0cmFuc2l0aW9uLlxuXG4gIGlmICh1cGRhdGVMYW5lICE9PSBJZGxlTGFuZSkge1xuICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHJvb3QucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KHVwZGF0ZUxhbmUpOyAvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3RcbiAgLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuXG4gIGV2ZW50VGltZXNbaW5kZXhdID0gZXZlbnRUaW1lO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7IC8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMsIGV2ZW50VGltZSkge1xuICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgdmFyIG5vTG9uZ2VyUGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7IC8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5cbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IDA7XG4gIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5tdXRhYmxlUmVhZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gQ2xlYXIgdGhlIGxhbmVzIHRoYXQgbm8gbG9uZ2VyIGhhdmUgcGVuZGluZyB3b3JrXG5cbiAgdmFyIGxhbmVzID0gbm9Mb25nZXJQZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IE5vTGFuZXM7XG4gICAgZXZlbnRUaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gIC8vIEluIGFkZGl0aW9uIHRvIGVudGFuZ2xpbmcgZWFjaCBvZiB0aGUgZ2l2ZW4gbGFuZXMgd2l0aCBlYWNoIG90aGVyLCB3ZSBhbHNvXG4gIC8vIGhhdmUgdG8gY29uc2lkZXIgX3RyYW5zaXRpdmVfIGVudGFuZ2xlbWVudHMuIEZvciBlYWNoIGxhbmUgdGhhdCBpcyBhbHJlYWR5XG4gIC8vIGVudGFuZ2xlZCB3aXRoICphbnkqIG9mIHRoZSBnaXZlbiBsYW5lcywgdGhhdCBsYW5lIGlzIG5vdyB0cmFuc2l0aXZlbHlcbiAgLy8gZW50YW5nbGVkIHdpdGggKmFsbCogdGhlIGdpdmVuIGxhbmVzLlxuICAvL1xuICAvLyBUcmFuc2xhdGVkOiBJZiBDIGlzIGVudGFuZ2xlZCB3aXRoIEEsIHRoZW4gZW50YW5nbGluZyBBIHdpdGggQiBhbHNvXG4gIC8vIGVudGFuZ2xlcyBDIHdpdGggQi5cbiAgLy9cbiAgLy8gSWYgdGhpcyBpcyBoYXJkIHRvIGdyYXNwLCBpdCBtaWdodCBoZWxwIHRvIGludGVudGlvbmFsbHkgYnJlYWsgdGhpc1xuICAvLyBmdW5jdGlvbiBhbmQgbG9vayBhdCB0aGUgdGVzdHMgdGhhdCBmYWlsIGluIFJlYWN0VHJhbnNpdGlvbi10ZXN0LmpzLiBUcnlcbiAgLy8gY29tbWVudGluZyBvdXQgb25lIG9mIHRoZSBjb25kaXRpb25zIGJlbG93LlxuICB2YXIgcm9vdEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcztcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBsYW5lcyA9IHJvb3RFbnRhbmdsZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMpIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG5cbiAgICBpZiAoIC8vIElzIHRoaXMgb25lIG9mIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG4gICAgbGFuZSAmIGVudGFuZ2xlZExhbmVzIHwgLy8gSXMgdGhpcyBsYW5lIHRyYW5zaXRpdmVseSBlbnRhbmdsZWQgd2l0aCB0aGUgbmV3bHkgZW50YW5nbGVkIGxhbmVzP1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdICYgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gIHZhciByZW5kZXJMYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShyZW5kZXJMYW5lcyk7XG4gIHZhciBsYW5lO1xuXG4gIHN3aXRjaCAocmVuZGVyTGFuZSkge1xuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIGxhbmUgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgbGFuZSA9IERlZmF1bHRIeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgIGNhc2UgUmV0cnlMYW5lNTpcbiAgICAgIGxhbmUgPSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIGxhbmUgPSBJZGxlSHlkcmF0aW9uTGFuZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBhbHJlYWR5IGVpdGhlciBhIGh5ZHJhdGlvbiBsYW5lLCBvciBzaG91bGRuJ3RcbiAgICAgIC8vIGJlIHJldHJpZWQgYXQgYSBoeWRyYXRpb24gbGFuZS5cbiAgICAgIGxhbmUgPSBOb0xhbmU7XG4gICAgICBicmVhaztcbiAgfSAvLyBDaGVjayBpZiB0aGUgbGFuZSB3ZSBjaG9zZSBpcyBzdXNwZW5kZWQuIElmIHNvLCB0aGF0IGluZGljYXRlcyB0aGF0IHdlXG4gIC8vIGFscmVhZHkgYXR0ZW1wdGVkIGFuZCBmYWlsZWQgdG8gaHlkcmF0ZSBhdCB0aGF0IGxldmVsLiBBbHNvIGNoZWNrIGlmIHdlJ3JlXG4gIC8vIGFscmVhZHkgcmVuZGVyaW5nIHRoYXQgbGFuZSwgd2hpY2ggaXMgcmFyZSBidXQgY291bGQgaGFwcGVuLlxuXG5cbiAgaWYgKChsYW5lICYgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfCByZW5kZXJMYW5lcykpICE9PSBOb0xhbmUpIHtcbiAgICAvLyBHaXZlIHVwIHRyeWluZyB0byBoeWRyYXRlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlci5cbiAgICByZXR1cm4gTm9MYW5lO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmVzKSB7XG5cbiAgaWYgKCFpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciB1cGRhdGVycyA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuICAgIHVwZGF0ZXJzLmFkZChmaWJlcik7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcykge1xuXG4gIGlmICghaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDtcbiAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIHVwZGF0ZXJzID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG5cbiAgICBpZiAodXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgIHVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCAhbWVtb2l6ZWRVcGRhdGVycy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1cGRhdGVycy5jbGVhcigpO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBTeW5jTGFuZTtcbnZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmU7XG52YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0TGFuZTtcbnZhciBJZGxlRXZlbnRQcmlvcml0eSA9IElkbGVMYW5lO1xudmFyIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IE5vTGFuZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSwgZm4pIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG5cbiAgdHJ5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmV2aW91c1ByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBoaWdoZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IDAgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGxvd2VyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSAwIHx8IGEgPiBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYjtcbn1cbmZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG4gIHZhciBsYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7XG5cbiAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5LCBsYW5lKSkge1xuICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoIWlzSGlnaGVyRXZlbnRQcmlvcml0eShDb250aW51b3VzRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcbiAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoaW5jbHVkZXNOb25JZGxlV29yayhsYW5lKSkge1xuICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIHJldHVybiBJZGxlRXZlbnRQcmlvcml0eTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgb25seSBleGlzdHMgYXMgYW4gRVNNIHdyYXBwZXIgYXJvdW5kIHRoZSBleHRlcm5hbCBDb21tb25KU1xudmFyIHNjaGVkdWxlQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaztcbnZhciBjYW5jZWxDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaztcbnZhciBzaG91bGRZaWVsZCA9IFNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZDtcbnZhciByZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50O1xudmFyIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eTtcbnZhciBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eTtcbnZhciBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5O1xuLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IG9uIHRoZSBzY2hlZHVsZXIsIGJ1dCBpdCAqZG9lcypcbi8vIG9uIHNjaGVkdWxlci91bnN0YWJsZV9tb2NrLCB3aGljaCB3ZSdsbCBuZWVkIGZvciBpbnRlcm5hbCB0ZXN0aW5nXG52YXIgdW5zdGFibGVfeWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV95aWVsZFZhbHVlO1xudmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcikge1xuICAgICAgLy8gQ29uZGl0aW9uYWxseSBpbmplY3QgdGhlc2UgaG9va3Mgb25seSBpZiBUaW1lbGluZSBwcm9maWxlciBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBidWlsZC5cbiAgICAgIC8vIFRoaXMgZ2l2ZXMgRGV2VG9vbHMgYSB3YXkgdG8gZmVhdHVyZSBkZXRlY3QgdGhhdCBpc24ndCB0aWVkIHRvIHZlcnNpb24gbnVtYmVyXG4gICAgICAvLyAoc2luY2UgcHJvZmlsaW5nIGFuZCB0aW1lbGluZSBhcmUgY29udHJvbGxlZCBieSBkaWZmZXJlbnQgZmVhdHVyZSBmbGFncykuXG4gICAgICBpbnRlcm5hbHMgPSBhc3NpZ24oe30sIGludGVybmFscywge1xuICAgICAgICBnZXRMYW5lTGFiZWxNYXA6IGdldExhbmVMYWJlbE1hcCxcbiAgICAgICAgaW5qZWN0UHJvZmlsaW5nSG9va3M6IGluamVjdFByb2ZpbGluZ0hvb2tzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTsgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cblxuICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhvb2suY2hlY2tEQ0UpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSByZWFsIERldlRvb2xzLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgaG9vayBpbnN0YWxsZWQgYnkgRmFzdCBSZWZyZXNoIHJ1bnRpbWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuICB7XG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QsIGV2ZW50UHJpb3JpdHkpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkaWRFcnJvciA9IChyb290LmN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gRGlkQ2FwdHVyZTtcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5O1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgICAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgc2NoZWR1bGVyUHJpb3JpdHksIGRpZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCB1bmRlZmluZWQsIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Qb3N0Q29tbWl0Um9vdChyb290KSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgdW5zdGFibGVfeWllbGRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UncmUgaW4gYSB0ZXN0IGJlY2F1c2UgU2NoZWR1bGVyLnVuc3RhYmxlX3lpZWxkVmFsdWUgb25seSBleGlzdHNcbiAgICAgIC8vIGluIFNjaGVkdWxlck1vY2suIFRvIHJlZHVjZSB0aGUgbm9pc2UgaW4gc3RyaWN0IG1vZGUgdGVzdHMsXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBhbmQgZGlzYWJsZSBzY2hlZHVsZXIgeWllbGRpbmcgZHVyaW5nIHRoZSBkb3VibGUgcmVuZGVyXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgc2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBQcm9maWxlciBBUEkgaG9va3NcblxuZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xufVxuXG5mdW5jdGlvbiBnZXRMYW5lTGFiZWxNYXAoKSB7XG4gIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciBsYW5lID0gMTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBUb3RhbExhbmVzOyBpbmRleCsrKSB7XG4gICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICBtYXAuc2V0KGxhbmUsIGxhYmVsKTtcbiAgICAgIGxhbmUgKj0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlciwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyWWllbGRlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgc3luY1F1ZXVlID0gbnVsbDtcbnZhciBpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MgPSBmYWxzZTtcbnZhciBpc0ZsdXNoaW5nU3luY1F1ZXVlID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZVN5bmNDYWxsYmFjayhjYWxsYmFjaykge1xuICAvLyBQdXNoIHRoaXMgY2FsbGJhY2sgaW50byBhbiBpbnRlcm5hbCBxdWV1ZS4gV2UnbGwgZmx1c2ggdGhlc2UgZWl0aGVyIGluXG4gIC8vIHRoZSBuZXh0IHRpY2ssIG9yIGVhcmxpZXIgaWYgc29tZXRoaW5nIGNhbGxzIGBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlYC5cbiAgaWYgKHN5bmNRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHN5bmNRdWV1ZSA9IFtjYWxsYmFja107XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuICAgIC8vIHdlIGFscmVhZHkgc2NoZWR1bGVkIG9uZSB3aGVuIHdlIGNyZWF0ZWQgdGhlIHF1ZXVlLlxuICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgc2NoZWR1bGVTeW5jQ2FsbGJhY2soY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpIHtcbiAgLy8gT25seSBmbHVzaGVzIHRoZSBxdWV1ZSBpZiB0aGVyZSdzIGEgbGVnYWN5IHN5bmMgY2FsbGJhY2sgc2NoZWR1bGVkLlxuICAvLyBUT0RPOiBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgdHlwZSBvZiBjYWxsYmFjazogcGVyZm9ybVN5bmNPbldvcmtPblJvb3QuIFNvXG4gIC8vIGl0IG1pZ2h0IG1ha2UgbW9yZSBzZW5zZSBmb3IgdGhlIHF1ZXVlIHRvIGJlIGEgbGlzdCBvZiByb290cyBpbnN0ZWFkIG9mIGFcbiAgLy8gbGlzdCBvZiBnZW5lcmljIGNhbGxiYWNrcy4gVGhlbiB3ZSBjYW4gaGF2ZSB0d286IG9uZSBmb3IgbGVnYWN5IHJvb3RzLCBvbmVcbiAgLy8gZm9yIGNvbmN1cnJlbnQgcm9vdHMuIEFuZCB0aGlzIG1ldGhvZCB3b3VsZCBvbmx5IGZsdXNoIHRoZSBsZWdhY3kgb25lcy5cbiAgaWYgKGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcykge1xuICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3MoKSB7XG4gIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmNlLlxuICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSB0cnVlO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc1N5bmMgPSB0cnVlO1xuICAgICAgdmFyIHF1ZXVlID0gc3luY1F1ZXVlOyAvLyBUT0RPOiBJcyB0aGlzIG5lY2Vzc2FyeSBhbnltb3JlPyBUaGUgb25seSB1c2VyIGNvZGUgdGhhdCBydW5zIGluIHRoaXNcbiAgICAgIC8vIHF1ZXVlIGlzIGluIHRoZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlcy5cblxuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG5cbiAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaXNTeW5jKTtcbiAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBzeW5jUXVldWUgPSBudWxsO1xuICAgICAgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHNvbWV0aGluZyB0aHJvd3MsIGxlYXZlIHRoZSByZW1haW5pbmcgY2FsbGJhY2tzIG9uIHRoZSBxdWV1ZS5cbiAgICAgIGlmIChzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgc3luY1F1ZXVlID0gc3luY1F1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgIH0gLy8gUmVzdW1lIGZsdXNoaW5nIGluIHRoZSBuZXh0IHRpY2tcblxuXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5LCBmbHVzaFN5bmNDYWxsYmFja3MpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZVByaW9yaXR5KTtcbiAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVGhpcyBpcyBpbXBvcnRlZCBieSB0aGUgZXZlbnQgcmVwbGF5aW5nIGltcGxlbWVudGF0aW9uIGluIFJlYWN0IERPTS4gSXQnc1xuLy8gaW4gYSBzZXBhcmF0ZSBmaWxlIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSByZW5kZXJlciBhbmRcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gaXNSb290RGVoeWRyYXRlZChyb290KSB7XG4gIHZhciBjdXJyZW50U3RhdGUgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG59XG5cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xudmFyIE5vVHJhbnNpdGlvbiA9IG51bGw7XG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iamVjdElzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtpXTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBjdXJyZW50S2V5KSB8fCAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICB2YXIgb3duZXIgPSAgZmliZXIuX2RlYnVnT3duZXIgPyBmaWJlci5fZGVidWdPd25lci50eXBlIDogbnVsbCA7XG4gIHZhciBzb3VyY2UgPSAgZmliZXIuX2RlYnVnU291cmNlIDtcblxuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICBkbyB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBjdXJyZW50ID0gbnVsbDtcbnZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG93bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cblxuXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgIGN1cnJlbnQgPSBudWxsO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICB7XG4gICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gIH1cbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXBlIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIGRvIGFuIGluaXRpYWwgcGFzcyB0byBnYXRoZXIgY29tcG9uZW50IG5hbWVzXG4gICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9IC8vIEZpbmFsbHksIHdlIGZsdXNoIGFsbCB0aGUgd2FybmluZ3NcbiAgICAvLyBVTlNBRkVfIG9uZXMgYmVmb3JlIHRoZSBkZXByZWNhdGVkIG9uZXMsIHNpbmNlIHRoZXknbGwgYmUgJ2xvdWRlcidcblxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIHNvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIFwiICsgJ3JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMyID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMik7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczMpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM0ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIFwiICsgJ2NvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kZXJpdmVkLXN0YXRlXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM0KTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzNSA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxVcGRhdGUgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgdmFyIHN0cmljdFJvb3QgPSBmaW5kU3RyaWN0Um9vdChmaWJlcik7XG5cbiAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuXG5cbiAgICBpZiAoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KTtcblxuICAgIGlmIChmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290ID0gW107XG4gICAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICAgIH1cblxuICAgICAgd2FybmluZ3NGb3JSb290LnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlckFycmF5LCBzdHJpY3RSb290KSB7XG4gICAgICBpZiAoZmliZXJBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF07XG4gICAgICB2YXIgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaXJzdEZpYmVyKTtcblxuICAgICAgICBlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJyArICdcXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyAnICsgJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2xlZ2FjeS1jb250ZXh0Jywgc29ydGVkTmFtZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gIH07XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIHByb3AgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xudmFyIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbmZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG5cbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlcik7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQsIHByb3ZpZGVyRmliZXIpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG5cbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAge1xuICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgLy8gVXBkYXRlIHRoZSBjaGlsZCBsYW5lcyBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nIHRoZSBhbHRlcm5hdGVzLlxuICB2YXIgbm9kZSA9IHBhcmVudDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcblxuICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBub2RlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmICFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChub2RlICE9PSBwcm9wYWdhdGlvblJvb3QpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcblxuICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7IC8vIFZpc2l0IHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBNYXRjaCEgU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoaXMgZmliZXIuXG4gICAgICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZm9yY2UgdXBkYXRlIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTsgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgLy8gSW5saW5lZCBgZW5xdWV1ZVVwZGF0ZWAgdG8gcmVtb3ZlIGludGVybGVhdmVkIHVwZGF0ZSBjaGVja1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICAgICAgICAgIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSBpZiAoIGZpYmVyLnRhZyA9PT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgaXMgaW4gdGhpcyBzdWJ0cmVlLCB3ZSBkb24ndCBrbm93XG4gICAgICAvLyBpZiBpdCB3aWxsIGhhdmUgYW55IGNvbnRleHQgY29uc3VtZXJzIGluIGl0LiBUaGUgYmVzdCB3ZSBjYW4gZG8gaXNcbiAgICAgIC8vIG1hcmsgaXQgYXMgaGF2aW5nIHVwZGF0ZXMuXG4gICAgICB2YXIgcGFyZW50U3VzcGVuc2UgPSBmaWJlci5yZXR1cm47XG5cbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudFN1c3BlbnNlLmxhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnRTdXNwZW5zZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIF9hbHRlcm5hdGUgPSBwYXJlbnRTdXNwZW5zZS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIF9hbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKF9hbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHBhc3NpbmcgdGhpcyBmaWJlciBhcyB0aGUgcGFyZW50XG4gICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gc2NoZWR1bGUgdGhpcyBmaWJlciBhcyBoYXZpbmcgd29ya1xuICAgICAgLy8gb24gaXRzIGNoaWxkcmVuLiBXZSdsbCB1c2UgdGhlIGNoaWxkTGFuZXMgb25cbiAgICAgIC8vIHRoaXMgZmliZXIgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cblxuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnRTdXNwZW5zZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuXG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuXG5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHZhciBmaXJzdENvbnRleHQgPSBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuXG4gICAgICBpZiAoZmlyc3RDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICAgICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICAgIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbHVlID0gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuXG4gIGlmIChsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPT09IGNvbnRleHQpIDsgZWxzZSB7XG4gICAgdmFyIGNvbnRleHRJdGVtID0ge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG1lbW9pemVkVmFsdWU6IHZhbHVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuXG5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0SXRlbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBBbiBhcnJheSBvZiBhbGwgdXBkYXRlIHF1ZXVlcyB0aGF0IHJlY2VpdmVkIHVwZGF0ZXMgZHVyaW5nIHRoZSBjdXJyZW50XG4vLyByZW5kZXIuIFdoZW4gdGhpcyByZW5kZXIgZXhpdHMsIGVpdGhlciBiZWNhdXNlIGl0IGZpbmlzaGVzIG9yIGJlY2F1c2UgaXQgaXNcbi8vIGludGVycnVwdGVkLCB0aGUgaW50ZXJsZWF2ZWQgdXBkYXRlcyB3aWxsIGJlIHRyYW5zZmVycmVkIG9udG8gdGhlIG1haW4gcGFydFxuLy8gb2YgdGhlIHF1ZXVlLlxudmFyIGludGVybGVhdmVkUXVldWVzID0gbnVsbDtcbmZ1bmN0aW9uIHB1c2hJbnRlcmxlYXZlZFF1ZXVlKHF1ZXVlKSB7XG4gIGlmIChpbnRlcmxlYXZlZFF1ZXVlcyA9PT0gbnVsbCkge1xuICAgIGludGVybGVhdmVkUXVldWVzID0gW3F1ZXVlXTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcmxlYXZlZFF1ZXVlcy5wdXNoKHF1ZXVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUludGVybGVhdmVkVXBkYXRlcygpIHtcbiAgLy8gVHJhbnNmZXIgdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgb250byB0aGUgbWFpbiBxdWV1ZS4gRWFjaCBxdWV1ZSBoYXMgYVxuICAvLyBgcGVuZGluZ2AgZmllbGQgYW5kIGFuIGBpbnRlcmxlYXZlZGAgZmllbGQuIFdoZW4gdGhleSBhcmUgbm90IG51bGwsIHRoZXlcbiAgLy8gcG9pbnQgdG8gdGhlIGxhc3Qgbm9kZSBpbiBhIGNpcmN1bGFyIGxpbmtlZCBsaXN0LiBXZSBuZWVkIHRvIGFwcGVuZCB0aGVcbiAgLy8gaW50ZXJsZWF2ZWQgbGlzdCB0byB0aGUgZW5kIG9mIHRoZSBwZW5kaW5nIGxpc3QgYnkgam9pbmluZyB0aGVtIGludG8gYVxuICAvLyBzaW5nbGUsIGNpcmN1bGFyIGxpc3QuXG4gIGlmIChpbnRlcmxlYXZlZFF1ZXVlcyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJsZWF2ZWRRdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZSA9IGludGVybGVhdmVkUXVldWVzW2ldO1xuICAgICAgdmFyIGxhc3RJbnRlcmxlYXZlZFVwZGF0ZSA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgICBpZiAobGFzdEludGVybGVhdmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmludGVybGVhdmVkID0gbnVsbDtcbiAgICAgICAgdmFyIGZpcnN0SW50ZXJsZWF2ZWRVcGRhdGUgPSBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dDtcbiAgICAgICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcXVldWUucGVuZGluZztcblxuICAgICAgICBpZiAobGFzdFBlbmRpbmdVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICAgICAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gZmlyc3RJbnRlcmxlYXZlZFVwZGF0ZTtcbiAgICAgICAgICBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBsYXN0SW50ZXJsZWF2ZWRVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW50ZXJsZWF2ZWRRdWV1ZXMgPSBudWxsO1xuICB9XG59XG5cbnZhciBVcGRhdGVTdGF0ZSA9IDA7XG52YXIgUmVwbGFjZVN0YXRlID0gMTtcbnZhciBGb3JjZVVwZGF0ZSA9IDI7XG52YXIgQ2FwdHVyZVVwZGF0ZSA9IDM7IC8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG52YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO1xuXG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDoge1xuICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgIGludGVybGVhdmVkOiBudWxsLFxuICAgICAgbGFuZXM6IE5vTGFuZXNcbiAgICB9LFxuICAgIGVmZmVjdHM6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgZXZlbnRUaW1lOiBldmVudFRpbWUsXG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG4gIGlmIChpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyKSkge1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IHNoYXJlZFF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG4gICAgICBwdXNoSW50ZXJsZWF2ZWRRdWV1ZShzaGFyZWRRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgc2hhcmVkUXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBlbmRpbmcgPSBzaGFyZWRRdWV1ZS5wZW5kaW5nO1xuXG4gICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB9XG5cbiAge1xuICAgIGlmIChjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHNoYXJlZFF1ZXVlICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICBlcnJvcignQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuXG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG5cbiAgaWYgKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpIHtcbiAgICB2YXIgcXVldWVMYW5lcyA9IHNoYXJlZFF1ZXVlLmxhbmVzOyAvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5IG11c3RcbiAgICAvLyBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaCByZXByZXNlbnRzXG4gICAgLy8gYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZSBtYXkgZW50YW5nbGVcbiAgICAvLyBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmIHdlICpkb24ndCpcbiAgICAvLyBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cblxuICAgIHF1ZXVlTGFuZXMgPSBpbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLCByb290LnBlbmRpbmdMYW5lcyk7IC8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG5cbiAgICB2YXIgbmV3UXVldWVMYW5lcyA9IG1lcmdlTGFuZXMocXVldWVMYW5lcywgbGFuZSk7XG4gICAgc2hhcmVkUXVldWUubGFuZXMgPSBuZXdRdWV1ZUxhbmVzOyAvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG4gICAgLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbiAgICAvLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxuXG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbmV3UXVldWVMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY2FwdHVyZWRVcGRhdGUpIHtcbiAgLy8gQ2FwdHVyZWQgdXBkYXRlcyBhcmUgdXBkYXRlcyB0aGF0IGFyZSB0aHJvd24gYnkgYSBjaGlsZCBkdXJpbmcgdGhlIHJlbmRlclxuICAvLyBwaGFzZS4gVGhleSBzaG91bGQgYmUgZGlzY2FyZGVkIGlmIHRoZSByZW5kZXIgaXMgYWJvcnRlZC4gVGhlcmVmb3JlLFxuICAvLyB3ZSBzaG91bGQgb25seSBwdXQgdGhlbSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgbm90IHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIENoZWNrIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGEgY2xvbmUuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAgIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlblxuICAgICAgLy8gd2UgYmFpbCBvdXQgb24gYSBwYXJlbnQgZmliZXIgdGhhdCB0aGVuIGNhcHR1cmVzIGFuIGVycm9yIHRocm93biBieVxuICAgICAgLy8gYSBjaGlsZC4gU2luY2Ugd2Ugd2FudCB0byBhcHBlbmQgdGhlIHVwZGF0ZSBvbmx5IHRvIHRoZSB3b3JrLWluXG4gICAgICAvLyAtcHJvZ3Jlc3MgcXVldWUsIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHVwZGF0ZXMuIFdlIHVzdWFsbHkgY2xvbmUgZHVyaW5nXG4gICAgICAvLyBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCB0aGF0IGRpZG4ndCBoYXBwZW4gaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2VcbiAgICAgIC8vIHNraXBwZWQgb3ZlciB0aGUgcGFyZW50IHdoZW4gd2UgYmFpbGVkIG91dC5cbiAgICAgIHZhciBuZXdGaXJzdCA9IG51bGw7XG4gICAgICB2YXIgbmV3TGFzdCA9IG51bGw7XG4gICAgICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgdXBkYXRlcyBhbmQgY2xvbmUgdGhlbS5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGUuZXZlbnRUaW1lLFxuICAgICAgICAgICAgbGFuZTogdXBkYXRlLmxhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2xvbmU7XG4gICAgICAgICAgICBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vIEFwcGVuZCB0aGUgY2FwdHVyZWQgdXBkYXRlIHRoZSBlbmQgb2YgdGhlIGNsb25lZCBsaXN0LlxuXG5cbiAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgICBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBubyBiYXNlIHVwZGF0ZXMuXG4gICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG5ld0ZpcnN0LFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgICBlZmZlY3RzOiBjdXJyZW50UXVldWUuZWZmZWN0c1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cblxuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gIH1cblxuICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcblxuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gICAgICAgIHJldHVybiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgcHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG4gIH1cblxuICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gSWYgc28sIHRyYW5zZmVyIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgdmFyIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7IC8vIFRoZSBwZW5kaW5nIHF1ZXVlIGlzIGNpcmN1bGFyLiBEaXNjb25uZWN0IHRoZSBwb2ludGVyIGJldHdlZW4gZmlyc3RcbiAgICAvLyBhbmQgbGFzdCBzbyB0aGF0IGl0J3Mgbm9uLWNpcmN1bGFyLlxuXG4gICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHZhciBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgIGxhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsOyAvLyBBcHBlbmQgcGVuZGluZyB1cGRhdGVzIHRvIGJhc2UgcXVldWVcblxuICAgIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH1cblxuICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7IC8vIElmIHRoZXJlJ3MgYSBjdXJyZW50IHF1ZXVlLCBhbmQgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgYmFzZSBxdWV1ZSwgdGhlblxuICAgIC8vIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlIHVwZGF0ZXMgdG8gdGhhdCBxdWV1ZSwgdG9vLiBCZWNhdXNlIHRoZSBiYXNlXG4gICAgLy8gcXVldWUgaXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgd2l0aCBubyBjeWNsZXMsIHdlIGNhbiBhcHBlbmQgdG8gYm90aFxuICAgIC8vIGxpc3RzIGFuZCB0YWtlIGFkdmFudGFnZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuXG4gICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnRcblxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgdmFyIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSAhPT0gbGFzdEJhc2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG5cblxuICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIHVwZGF0ZXMgdG8gY29tcHV0ZSB0aGUgcmVzdWx0LlxuICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTsgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmUgcmVuZGVyTGFuZXNcbiAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuICAgIHZhciBuZXdMYW5lcyA9IE5vTGFuZXM7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0xhc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSB1cGRhdGUubGFuZTtcbiAgICAgIHZhciB1cGRhdGVFdmVudFRpbWUgPSB1cGRhdGUuZXZlbnRUaW1lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGVFdmVudFRpbWUsXG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUgPSBjbG9uZTtcbiAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5cblxuICAgICAgICBuZXdMYW5lcyA9IG1lcmdlTGFuZXMobmV3TGFuZXMsIHVwZGF0ZUxhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZUV2ZW50VGltZSxcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4gICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBfY2xvbmU7XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIG5ld1N0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBuZXdTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuXG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCAmJiAvLyBJZiB0aGUgdXBkYXRlIHdhcyBhbHJlYWR5IGNvbW1pdHRlZCwgd2Ugc2hvdWxkIG5vdCBxdWV1ZSBpdHNcbiAgICAgICAgLy8gY2FsbGJhY2sgYWdhaW4uXG4gICAgICAgIHVwZGF0ZS5sYW5lICE9PSBOb0xhbmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDYWxsYmFjaztcbiAgICAgICAgICB2YXIgZWZmZWN0cyA9IHF1ZXVlLmVmZmVjdHM7XG5cbiAgICAgICAgICBpZiAoZWZmZWN0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUuZWZmZWN0cyA9IFt1cGRhdGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG5cbiAgICAgIGlmICh1cGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGEgcmVkdWNlci4gQWRkIHRoZSBuZXdcbiAgICAgICAgICAvLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxuICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2VcbiAgICAgICAgICAvLyB1bnJhdmVsIHRoZW0gd2hlbiB0cmFuc2ZlcnJpbmcgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICAgICAgICAgIHZhciBfZmlyc3RQZW5kaW5nVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZSA9IF9maXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBuZXdGaXJzdEJhc2VVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTsgLy8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuICAgIC8vIHByb2Nlc3MgdGhlbSBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCB3ZSBkbyBuZWVkIHRvIHRyYWNrIHdoaWNoIGxhbmVzXG4gICAgLy8gYXJlIHJlbWFpbmluZy5cblxuICAgIHZhciBsYXN0SW50ZXJsZWF2ZWQgPSBxdWV1ZS5zaGFyZWQuaW50ZXJsZWF2ZWQ7XG5cbiAgICBpZiAobGFzdEludGVybGVhdmVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJsZWF2ZWQgPSBsYXN0SW50ZXJsZWF2ZWQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmV3TGFuZXMgPSBtZXJnZUxhbmVzKG5ld0xhbmVzLCBpbnRlcmxlYXZlZC5sYW5lKTtcbiAgICAgICAgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuICAgICAgfSB3aGlsZSAoaW50ZXJsZWF2ZWQgIT09IGxhc3RJbnRlcmxlYXZlZCk7XG4gICAgfSBlbHNlIGlmIChmaXJzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAgcXVldWUuc2hhcmVkLmxhbmVzID0gTm9MYW5lcztcbiAgICB9IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cblxuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbmV3TGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkICcgKyAoXCJyZWNlaXZlZDogXCIgKyBjYWxsYmFjaykpO1xuICB9XG5cbiAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKSB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5mdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIGZpbmlzaGVkUXVldWUsIGluc3RhbmNlKSB7XG4gIC8vIENvbW1pdCB0aGUgZWZmZWN0c1xuICB2YXIgZWZmZWN0cyA9IGZpbmlzaGVkUXVldWUuZWZmZWN0cztcbiAgZmluaXNoZWRRdWV1ZS5lZmZlY3RzID0gbnVsbDtcblxuICBpZiAoZWZmZWN0cyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVmZmVjdCA9IGVmZmVjdHNbaV07XG4gICAgICB2YXIgY2FsbGJhY2sgPSBlZmZlY3QuY2FsbGJhY2s7XG5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBlZmZlY3QuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307IC8vIFJlYWN0LkNvbXBvbmVudCB1c2VzIGEgc2hhcmVkIGZyb3plbiBvYmplY3QgYnkgZGVmYXVsdC5cbi8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG5cbnZhciBlbXB0eVJlZnNPYmplY3QgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkucmVmcztcbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gY2FsbGVyTmFtZSArICdfJyArIGNhbGxiYWNrO1xuXG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcblxuICAgICAgZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgJyArICdtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgJyArICdhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyAnICsgXCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgXCIgKyAndG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggJyArICd0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXh0UHJvcHMpIHtcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7IC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFF1ZXVlIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgY2xhc3Nlc1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgdmFyIHJvb3QgPSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgKyAnVGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSB1bmRlZmluZWQgJiYgaGFzTXV0YXRlZFByb3BzKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGVycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3RvcikpIHtcbiAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7XG5cbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiAnICsgJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGNvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0ID0gaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cbiAge1xuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cblxuXG4gIGlmIChpc0xlZ2FjeUNvbnRleHRDb25zdW1lcikge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgIHtcbiAgICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgIH1cblxuICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBmaWJlckZsYWdzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG4gICAgICB7XG4gICAgICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBfZmliZXJGbGFncyB8PSBMYXlvdXRTdGF0aWM7XG4gICAgICB9XG5cbiAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICBfZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gX2ZpYmVyRmxhZ3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9maWJlckZsYWdzMiA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBfZmliZXJGbGFnczIgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX2ZpYmVyRmxhZ3MyIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgICAgfVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBfZmliZXJGbGFnczI7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyB1bnJlc29sdmVkT2xkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSAmJiAhKGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gICApKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkgfHwgLy8gVE9ETzogSW4gc29tZSBjYXNlcywgd2UnbGwgZW5kIHVwIGNoZWNraW5nIGlmIGNvbnRleHQgaGFzIGNoYW5nZWQgdHdpY2UsXG4gIC8vIGJvdGggYmVmb3JlIGFuZCBhZnRlciBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBoYXMgYmVlbiBjYWxsZWQuIE5vdCBpZGVhbCxcbiAgLy8gYnV0IEknbSBsb2F0aCB0byByZWZhY3RvciB0aGlzIGZ1bmN0aW9uLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgbWVtb2l6ZWRcbiAgLy8gY29tcG9uZW50cyBzbyBpdCdzIG5vdCB0aGF0IGNvbW1vbi5cbiAgZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiAgIDtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbi8vIFRPRE86IFVzZSB0aGUgdW5pZmllZCBmaWJlciBzdGFjayBtb2R1bGUgaW5zdGVhZCBvZiB0aGlzIGxvY2FsIG9uZT9cbi8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGl0IHlldCB0byBkZXJpc2sgdGhlIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIGJlY2F1c2Vcbi8vIHRoZSB3YXkgd2UgcHVzaC9wb3AgdGhlc2UgdmFsdWVzIGlzIGEgYml0IHVudXN1YWwuIElmIHRoZXJlJ3MgYSBtaXN0YWtlLCBJJ2Rcbi8vIHJhdGhlciB0aGUgaWRzIGJlIHdyb25nIHRoYW4gY3Jhc2ggdGhlIHdob2xlIHJlY29uY2lsZXIuXG52YXIgZm9ya1N0YWNrID0gW107XG52YXIgZm9ya1N0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVGb3JrQ291bnQgPSAwO1xudmFyIGlkU3RhY2sgPSBbXTtcbnZhciBpZFN0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVDb250ZXh0SWQgPSAxO1xudmFyIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSAnJztcbmZ1bmN0aW9uIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JrZWQpICE9PSBOb0ZsYWdzO1xufVxuZnVuY3Rpb24gZ2V0Rm9ya3NBdExldmVsKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICByZXR1cm4gdHJlZUZvcmtDb3VudDtcbn1cbmZ1bmN0aW9uIGdldFRyZWVJZCgpIHtcbiAgdmFyIG92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciB3ZSByZWNvbmNpbGUgYW4gYXJyYXkgKG9yIGl0ZXJhdG9yKSBvZiBjaGlsZFxuICAvLyBmaWJlcnMsIGJlY2F1c2UgdGhhdCdzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHdlIGtub3cgaG93IG1hbnkgY2hpbGRyZW4gaW5cbiAgLy8gdGhlIHdob2xlIHNldCB3aXRob3V0IGRvaW5nIGV4dHJhIHdvcmsgbGF0ZXIsIG9yIHN0b3JpbmcgYWRkdGlvbmFsXG4gIC8vIGluZm9ybWF0aW9uIG9uIHRoZSBmaWJlci5cbiAgLy9cbiAgLy8gVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGlzIHNlcGFyYXRlIGZyb20gcHVzaFRyZWVJZCDigJQgaXQncyBjYWxsZWQgZHVyaW5nXG4gIC8vIHRoZSByZW5kZXIgcGhhc2Ugb2YgdGhlIGZvcmsgcGFyZW50LCBub3QgdGhlIGNoaWxkLCB3aGljaCBpcyB3aGVyZSB3ZSBwdXNoXG4gIC8vIHRoZSBvdGhlciBjb250ZXh0IHZhbHVlcy5cbiAgLy9cbiAgLy8gSW4gdGhlIEZpenogaW1wbGVtZW50YXRpb24gdGhpcyBpcyBtdWNoIHNpbXBsZXIgYmVjYXVzZSB0aGUgY2hpbGQgaXNcbiAgLy8gcmVuZGVyZWQgaW4gdGhlIHNhbWUgY2FsbHN0YWNrIGFzIHRoZSBwYXJlbnQuXG4gIC8vXG4gIC8vIEl0IG1pZ2h0IGJlIGJldHRlciB0byBqdXN0IGFkZCBhIGBmb3Jrc2AgZmllbGQgdG8gdGhlIEZpYmVyIHR5cGUuIEl0IHdvdWxkXG4gIC8vIG1ha2UgdGhpcyBtb2R1bGUgc2ltcGxlci5cbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrQ291bnQ7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdHJlZUZvcmtDb3VudCA9IHRvdGFsQ2hpbGRyZW47XG59XG5mdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgYmFzZU92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IHJlc3RPZkxlbmd0aCB8IGlkO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3JtYWwgcGF0aFxuICAgIHZhciBuZXdCaXRzID0gc2xvdCA8PCBiYXNlTGVuZ3RoO1xuXG4gICAgdmFyIF9pZCA9IG5ld0JpdHMgfCBiYXNlSWQ7XG5cbiAgICB2YXIgX292ZXJmbG93ID0gYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IGxlbmd0aCB8IF9pZDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gX292ZXJmbG93O1xuICB9XG59XG5mdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpOyAvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFRoaXMgd2lsbCBhZmZlY3QgYW55IGlkcyB0aGF0IGFwcGVhclxuICAvLyBpbiBpdHMgY2hpbGRyZW4uXG5cbiAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBudW1iZXJPZkZvcmtzID0gMTtcbiAgICB2YXIgc2xvdEluZGV4ID0gMDtcbiAgICBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MpO1xuICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MsIHNsb3RJbmRleCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufVxuXG5mdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZXMuXG4gIC8vIFRoaXMgaXMgYSBiaXQgbW9yZSBjb21wbGljYXRlZCB0aGFuIG90aGVyIGNvbnRleHQtbGlrZSBtb2R1bGVzIGluIEZpYmVyXG4gIC8vIGJlY2F1c2UgdGhlIHNhbWUgRmliZXIgbWF5IGFwcGVhciBvbiB0aGUgc3RhY2sgbXVsdGlwbGUgdGltZXMgYW5kIGZvclxuICAvLyBkaWZmZXJlbnQgcmVhc29ucy4gV2UgaGF2ZSB0byBrZWVwIHBvcHBpbmcgdW50aWwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaXNcbiAgLy8gbm8gbG9uZ2VyIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVGb3JrUHJvdmlkZXIpIHtcbiAgICB0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO1xuICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVGb3JrQ291bnQgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG4gICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGw7XG4gIH1cblxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXIpIHtcbiAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dElkID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuXG4gIGlmICh0cmVlQ29udGV4dFByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0cmVlQ29udGV4dElkLFxuICAgICAgb3ZlcmZsb3c6IHRyZWVDb250ZXh0T3ZlcmZsb3dcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbmRlZENvbnRleHQpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0SWQgPSBzdXNwZW5kZWRDb250ZXh0LmlkO1xuICB0cmVlQ29udGV4dE92ZXJmbG93ID0gc3VzcGVuZGVkQ29udGV4dC5vdmVyZmxvdztcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKSB7XG4gIHtcbiAgICBpZiAoIWdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlICcgKyAnYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG52YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbnZhciBkaWRTdXNwZW5kID0gZmFsc2U7IC8vIEh5ZHJhdGlvbiBlcnJvcnMgdGhhdCB3ZXJlIHRocm93biBpbnNpZGUgdGhpcyBib3VuZGFyeVxuXG52YXIgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcblxuZnVuY3Rpb24gd2FybklmSHlkcmF0aW5nKCkge1xuICB7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICBlcnJvcignV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtEaWRTdXNwZW5kV2hpbGVIeWRyYXRpbmdERVYoKSB7XG4gIHtcbiAgICBkaWRTdXNwZW5kID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICBkaWRTdXNwZW5kID0gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIsIHN1c3BlbnNlSW5zdGFuY2UsIHRyZWVDb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmQgPSBmYWxzZTtcblxuICBpZiAodHJlZUNvbnRleHQgIT09IG51bGwpIHtcbiAgICByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQoZmliZXIsIHRyZWVDb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHJldHVybkZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGlmIChzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHdhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKTtcbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV07XG4gICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAge1xuICAgIGlmIChkaWRTdXNwZW5kKSB7XG4gICAgICAvLyBJbnNpZGUgYSBib3VuZGFyeSB0aGF0IGFscmVhZHkgc3VzcGVuZGVkLiBXZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHRoZVxuICAgICAgLy8gc2libGluZ3Mgb2YgYSBzdXNwZW5kZWQgbm9kZS4gVGhlIG1pc21hdGNoIG1heSBiZSBkdWUgdG8gdGhlIG1pc3NpbmdcbiAgICAgIC8vIGRhdGEsIHNvIGl0J3MgcHJvYmFibHkgYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIF9wcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSByZXR1cm5GaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgICAgICAgaWYgKF9wYXJlbnRJbnN0YW5jZSAhPT0gbnVsbCkgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlMiA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHMyID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UsIF90eXBlMiwgX3Byb3BzMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgX3RleHQyID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UoX3BhcmVudEluc3RhbmNlLCBfdGV4dDIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcikge1xuICBmaWJlci5mbGFncyA9IGZpYmVyLmZsYWdzICYgfkh5ZHJhdGluZyB8IFBsYWNlbWVudDtcbiAgd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuXG4gICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjsgLy8gVGV4dCBJbnN0YW5jZXMgZG9uJ3QgaGF2ZSBjaGlsZHJlbiBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gaHlkcmF0ZS5cblxuICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dEluc3RhbmNlKTtcblxuICAgICAgICAgIGlmIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgZGVoeWRyYXRlZDogc3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgICAgICAgICAgdHJlZUNvbnRleHQ6IGdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCksXG4gICAgICAgICAgICAgIHJldHJ5TGFuZTogT2Zmc2NyZWVuTGFuZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBzdXNwZW5zZVN0YXRlOyAvLyBTdG9yZSB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudCBhcyBhIGNoaWxkIGZpYmVyLlxuICAgICAgICAgICAgLy8gVGhpcyBzaW1wbGlmaWVzIHRoZSBjb2RlIGZvciBnZXRIb3N0U2libGluZyBhbmQgZGVsZXRpbmcgbm9kZXMsXG4gICAgICAgICAgICAvLyBzaW5jZSBpdCBkb2Vzbid0IGhhdmUgdG8gY29uc2lkZXIgYWxsIFN1c3BlbnNlIGJvdW5kYXJpZXMgYW5kXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGV5J3JlIGRlaHlkcmF0ZWQgb25lcyBvciBub3QuXG5cbiAgICAgICAgICAgIHZhciBkZWh5ZHJhdGVkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgICAgICBkZWh5ZHJhdGVkRnJhZ21lbnQucmV0dXJuID0gZmliZXI7XG4gICAgICAgICAgICBmaWJlci5jaGlsZCA9IGRlaHlkcmF0ZWRGcmFnbWVudDtcbiAgICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFdoaWxlIGEgU3VzcGVuc2UgSW5zdGFuY2UgZG9lcyBoYXZlIGNoaWxkcmVuLCB3ZSB3b24ndCBzdGVwIGludG9cbiAgICAgICAgICAgIC8vIGl0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSW5zdGVhZCwgd2UnbGwgcmVlbnRlciBpdCBsYXRlci5cblxuICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpIHtcbiAgcmV0dXJuICAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlICYmIChmaWJlci5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgJyArICdyZW5kZXJlZCBvbiB0aGUgc2VydmVyLicpO1xufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgaWYgKCFuZXh0SW5zdGFuY2UpIHtcbiAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcbiAgICAgIHdhcm5Ob25oeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTtcbiAgICB9IC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG5cblxuICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UgPSBuZXh0SW5zdGFuY2U7XG5cbiAgaWYgKCF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgaWYgKHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpKSB7XG4gICAgICB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKCk7XG4gICAgfSAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuXG5cbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gICAgdmFyIHByZXZIeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuXG4gICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZDtcbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyLCBzaG91bGRXYXJuSWZNaXNtYXRjaERldik7IC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuXG4gIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZDtcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIsIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKHJldHVybkZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcblxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbiAgICAgICAgICAgIGlzQ29uY3VycmVudE1vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG4gICAgICAgICAgICBpc0NvbmN1cnJlbnRNb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgLy8gc2lkZSBvZiB0aGVtLiBXZSBhbHNvIGRvbid0IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgdGhlIHJvb3QgY29udGFpbmVyLlxuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QgJiYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICBpZiAobmV4dEluc3RhbmNlKSB7XG4gICAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcbiAgICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcik7XG4gICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpO1xuICB9IGVsc2Uge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXNVbmh5ZHJhdGVkVGFpbE5vZGVzKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmcgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcikge1xuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgd2FyblVuaHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgZGlkU3VzcGVuZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyAhPT0gbnVsbCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgYSBmb3JjZWQgY2xpZW50IHJlbmRlci4gVGhlIGVycm9ycyB0aGF0IG9jY3VycmVkXG4gICAgLy8gZHVyaW5nIHRoZSBoeWRyYXRpb24gYXR0ZW1wdCBhcmUgbm93IHJlY292ZXJlZC4gV2Ugd2lsbCBsb2cgdGhlbSBpblxuICAgIC8vIGNvbW1pdCBwaGFzZSwgb25jZSB0aGUgZW50aXJlIHRyZWUgaGFzIGZpbmlzaGVkLlxuICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKTtcbiAgICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldElzSHlkcmF0aW5nKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmc7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyA9PT0gbnVsbCkge1xuICAgIGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnM7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7XG52YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nO1xuXG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7fTtcblxue1xuICBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5fc3RvcmUgfHwgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQuX3N0b3JlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCkge1xuICB2YXIgbWl4ZWRSZWYgPSBlbGVtZW50LnJlZjtcblxuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICAvLyBUT0RPOiBDbGVhbiB0aGlzIHVwIG9uY2Ugd2UgdHVybiBvbiB0aGUgc3RyaW5nIHJlZiB3YXJuaW5nIGZvclxuICAgICAgLy8gZXZlcnlvbmUsIGJlY2F1c2UgdGhlIHN0cmljdCBtb2RlIGNhc2Ugd2lsbCBubyBsb25nZXIgYmUgcmVsZXZhbnRcbiAgICAgIGlmICgocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgfHwgd2FybkFib3V0U3RyaW5nUmVmcykgJiYgLy8gV2Ugd2FybiBpbiBSZWFjdEVsZW1lbnQuanMgaWYgb3duZXIgYW5kIHNlbGYgYXJlIGVxdWFsIGZvciBzdHJpbmcgcmVmc1xuICAgICAgLy8gYmVjYXVzZSB0aGVzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb25cbiAgICAgIC8vIHVzaW5nIGEgY29kZW1vZC4gVGhlcmVmb3JlLCB3ZSBkb24ndCBoYXZlIHRvIHdhcm4gYWJvdXQgc3RyaW5nIHJlZnMgYWdhaW4uXG4gICAgICAhKGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX3NlbGYgJiYgZWxlbWVudC5fb3duZXIuc3RhdGVOb2RlICE9PSBlbGVtZW50Ll9zZWxmKSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCdBIHN0cmluZyByZWYsIFwiJXNcIiwgaGFzIGJlZW4gZm91bmQgd2l0aGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdTdHJpbmcgcmVmcyBhcmUgYSBzb3VyY2Ugb2YgcG90ZW50aWFsIGJ1Z3MgYW5kIHNob3VsZCBiZSBhdm9pZGVkLiAnICsgJ1dlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIG1peGVkUmVmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdDtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG5cbiAgICAgICAgaWYgKG93bmVyRmliZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSBzdHJpbmcgcmVmcy4gJyArICdXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbnN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIgKyBtaXhlZFJlZiArIFwiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBcIiArICdidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0IHNvIEZsb3cga25vd3MgaXQgd29uJ3QgY2hhbmdlIGluIHRoZSBjbG9zdXJlXG5cblxuICAgICAgdmFyIHJlc29sdmVkSW5zdCA9IGluc3Q7XG5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tQcm9wU3RyaW5nQ29lcmNpb24obWl4ZWRSZWYsICdyZWYnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7IC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudC5yZWYgPT09ICdmdW5jdGlvbicgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IHJlc29sdmVkSW5zdC5yZWZzO1xuXG4gICAgICAgIGlmIChyZWZzID09PSBlbXB0eVJlZnNPYmplY3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbGF6eSBwb29sZWQgZnJvemVuIG9iamVjdCwgc28gd2UgbmVlZCB0byBpbml0aWFsaXplLlxuICAgICAgICAgIHJlZnMgPSByZXNvbHZlZEluc3QucmVmcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG1peGVkUmVmICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhIHN0cmluZywgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciBudWxsLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKFwiICsgbWl4ZWRSZWYgKyBcIikgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2ZcIiArICcgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbiBjb21wb25lbnRcXG4nICsgXCIyLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnQncyByZW5kZXIgbWV0aG9kXFxuXCIgKyAnMy4gWW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgdmFyIGNoaWxkU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZFN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRTdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxhenkobGF6eVR5cGUpIHtcbiAgdmFyIHBheWxvYWQgPSBsYXp5VHlwZS5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5VHlwZS5faW5pdDtcbiAgcmV0dXJuIGluaXQocGF5bG9hZCk7XG59IC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5cblxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcblxuICAgIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXTtcbiAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cblxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICAvLyBpbnN0ZWFkLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIER1cmluZyBoeWRyYXRpb24sIHRoZSB1c2VJZCBhbGdvcml0aG0gbmVlZHMgdG8ga25vdyB3aGljaCBmaWJlcnMgYXJlXG4gICAgICAvLyBwYXJ0IG9mIGEgbGlzdCBvZiBjaGlsZHJlbiAoYXJyYXlzLCBpdGVyYXRvcnMpLlxuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gRm9ya2VkO1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuXG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQsIGxhbmVzKSB7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIGxhbmVzLCBlbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSApIHx8IC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuICAgICAgLy8gYmVjYXVzZSBob3QgcmVsb2FkaW5nIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gcHJvZCBiZWNhdXNlXG4gICAgICAvLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG4gICAgICAgdHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCAmJiBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmIHJlc29sdmVMYXp5KGVsZW1lbnRUeXBlKSA9PT0gY3VycmVudC50eXBlKSB7XG4gICAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIF9jcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZDIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIG51bGwpO1xuXG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicsIGtleSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBjaGlsZC5faW5pdDtcbiAgICAgICAgICAgIHdhcm5PbkludmFsaWRLZXkoaW5pdChwYXlsb2FkKSwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgICAgaWYgKF9uZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgdmFyIF9udW1iZXJPZkZvcmtzMiA9IG5ld0lkeDtcbiAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBsYW5lcykge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCB0b1N0cmluZ1RhZ1xuICAgICAgbmV3Q2hpbGRyZW5JdGVyYWJsZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnR2VuZXJhdG9yJykge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICAgIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9IC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuXG5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKG5ld0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgX251bWJlck9mRm9ya3MzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzMyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczQgPSBuZXdJZHg7XG4gICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG5cblxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCkge1xuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHwgKCAvLyBLZWVwIHRoaXMgY2hlY2sgaW5saW5lIHNvIGl0IG9ubHkgcnVucyBvbiB0aGUgZmFsc2UgcGF0aDpcbiAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLCBlbGVtZW50KSApIHx8IC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBhZnRlciB0aGUgSG90IFJlbG9hZGluZyBjaGVjayBhYm92ZSxcbiAgICAgICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2VcbiAgICAgICAgICAvLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG4gICAgICAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGNoaWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcblxuICAgICAgICAgICAgdmFyIF9leGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnByb3BzKTtcblxuICAgICAgICAgICAgX2V4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgX2V4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEaWRuJ3QgbWF0Y2guXG5cblxuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgX2NyZWF0ZWQ0LnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH0gLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuXG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWN1cnNpdmUuXG4gICAgLy8gSWYgdGhlIHRvcCBsZXZlbCBpdGVtIGlzIGFuIGFycmF5LCB3ZSB0cmVhdCBpdCBhcyBhIHNldCBvZiBjaGlsZHJlbixcbiAgICAvLyBub3QgYXMgYSBmcmFnbWVudC4gTmVzdGVkIGFycmF5cyBvbiB0aGUgb3RoZXIgaGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBmcmFnbWVudCBub2Rlcy4gUmVjdXJzaW9uIGhhcHBlbnMgYXQgdGhlIG5vcm1hbCBmbG93LlxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICB2YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGw7XG5cbiAgICBpZiAoaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9IC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcblxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7IC8vIFRPRE86IFRoaXMgZnVuY3Rpb24gaXMgc3VwcG9zZWQgdG8gYmUgbm9uLXJlY3Vyc2l2ZS5cblxuICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gICAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn0gLy8gUmVzZXQgYSB3b3JrSW5Qcm9ncmVzcyBjaGlsZCBzZXQgdG8gcHJlcGFyZSBpdCBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyhjaGlsZCwgbGFuZXMpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xudmFyIGNvbnRleHRTdGFja0N1cnNvciQxID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG5mdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICBpZiAoYyA9PT0gTk9fQ09OVEVYVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7IC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgTk9fQ09OVEVYVCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUsIHJvb3RJbnN0YW5jZSk7IC8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuXG4gIGlmIChjb250ZXh0ID09PSBuZXh0Q29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxudmFyIERlZmF1bHRTdXNwZW5zZUNvbnRleHQgPSAwOyAvLyBUaGUgU3VzcGVuc2UgQ29udGV4dCBpcyBzcGxpdCBpbnRvIHR3byBwYXJ0cy4gVGhlIGxvd2VyIGJpdHMgaXNcbi8vIGluaGVyaXRlZCBkZWVwbHkgZG93biB0aGUgc3VidHJlZS4gVGhlIHVwcGVyIGJpdHMgb25seSBhZmZlY3Rcbi8vIHRoaXMgaW1tZWRpYXRlIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBnZXRzIHJlc2V0IGVhY2ggbmV3XG4vLyBib3VuZGFyeSBvciBzdXNwZW5zZSBsaXN0LlxuXG52YXIgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgPSAxOyAvLyBTdWJ0cmVlIEZsYWdzOlxuLy8gSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0IGluZGljYXRlcyB0aGF0IG9uZSBvZiBvdXIgcGFyZW50IFN1c3BlbnNlXG4vLyBib3VuZGFyaWVzIGlzIG5vdCBjdXJyZW50bHkgc2hvd2luZyB2aXNpYmxlIG1haW4gY29udGVudC5cbi8vIEVpdGhlciBiZWNhdXNlIGl0IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIG9yIGlzIG5vdCBtb3VudGVkIGF0IGFsbC5cbi8vIFdlIGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgaXQgaXMgZGVzaXJhYmxlIHRvIHRyaWdnZXIgYSBmYWxsYmFjayBhdFxuLy8gdGhlIHBhcmVudC4gSWYgbm90LCB0aGVuIHdlIG1pZ2h0IG5lZWQgdG8gdHJpZ2dlciB1bmRlc2lyYWJsZSBib3VuZGFyaWVzXG4vLyBhbmQvb3Igc3VzcGVuZCB0aGUgY29tbWl0IHRvIGF2b2lkIGhpZGluZyB0aGUgcGFyZW50IGNvbnRlbnQuXG5cbnZhciBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgPSAxOyAvLyBTaGFsbG93IEZsYWdzOlxuLy8gRm9yY2VTdXNwZW5zZUZhbGxiYWNrIGNhbiBiZSB1c2VkIGJ5IFN1c3BlbnNlTGlzdCB0byBmb3JjZSBuZXdseSBhZGRlZFxuLy8gaXRlbXMgaW50byB0aGVpciBmYWxsYmFjayBzdGF0ZSBkdXJpbmcgb25lIG9mIHRoZSByZW5kZXIgcGFzc2VzLlxuXG52YXIgRm9yY2VTdXNwZW5zZUZhbGxiYWNrID0gMjtcbnZhciBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKERlZmF1bHRTdXNwZW5zZUNvbnRleHQpO1xuZnVuY3Rpb24gaGFzU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIGZsYWcpIHtcbiAgcmV0dXJuIChwYXJlbnRDb250ZXh0ICYgZmxhZykgIT09IDA7XG59XG5mdW5jdGlvbiBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG59XG5mdW5jdGlvbiBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIHNoYWxsb3dDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgfCBzaGFsbG93Q29udGV4dDtcbn1cbmZ1bmN0aW9uIGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc3VidHJlZUNvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgfCBzdWJ0cmVlQ29udGV4dDtcbn1cbmZ1bmN0aW9uIHB1c2hTdXNwZW5zZUNvbnRleHQoZmliZXIsIG5ld0NvbnRleHQpIHtcbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXdDb250ZXh0LCBmaWJlcik7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUNvbnRleHQoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKHdvcmtJblByb2dyZXNzLCBoYXNJbnZpc2libGVQYXJlbnQpIHtcbiAgLy8gSWYgaXQgd2FzIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHRoYXQganVzdCBzdXNwZW5kZWQsIGNhcHR1cmUgYW5kIHJlbmRlciB0aGVcbiAgLy8gZmFsbGJhY2suIE90aGVyd2lzZSwgZG9uJ3QgY2FwdHVyZSBhbmQgYnViYmxlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobmV4dFN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5leHRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGRlaHlkcmF0ZWQgYm91bmRhcnkgYWx3YXlzIGNhcHR1cmVzLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczsgLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG4gIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYm91bmRhcnkgd2Ugc2hvdWxkIGF2b2lkLCB0aGVuIHdlIHByZWZlciB0byBidWJibGUgdXAgdG8gdGhlXG59XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgICovXG4wOyAvLyBSZXByZXNlbnRzIHdoZXRoZXIgZWZmZWN0IHNob3VsZCBmaXJlLlxuXG52YXIgSGFzRWZmZWN0ID1cbi8qICovXG4xOyAvLyBSZXByZXNlbnRzIHRoZSBwaGFzZSBpbiB3aGljaCB0aGUgZWZmZWN0IChub3QgdGhlIGNsZWFuLXVwKSBmaXJlcy5cblxudmFyIEluc2VydGlvbiA9XG4vKiAgKi9cbjI7XG52YXIgTGF5b3V0ID1cbi8qICAgICovXG40O1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICovXG44O1xuXG4vLyBhbmQgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyByZW5kZXIuXG4vLyBUaGlzIHRyYWNrcyB3aGljaCBtdXRhYmxlIHNvdXJjZXMgbmVlZCB0byBiZSByZXNldCBhZnRlciBhIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzU291cmNlcyA9IFtdO1xuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtdXRhYmxlU291cmNlID0gd29ya0luUHJvZ3Jlc3NTb3VyY2VzW2ldO1xuXG4gICAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgICBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uU2Vjb25kYXJ5ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoID0gMDtcbn1cbi8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSB2ZXJzaW9uIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcgbWF0Y2hlcyB0aGUgb25lXG4vLyB0aGF0IGlzIGV2ZW50dWFsbHkgcmVhZCBkdXJpbmcgaHlkcmF0aW9uLlxuLy8gSWYgdGhleSBkb24ndCBtYXRjaCB0aGVyZSdzIGEgcG90ZW50aWFsIHRlYXIgYW5kIGEgZnVsbCBkZW9wdCByZW5kZXIgaXMgcmVxdWlyZWQuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LCBtdXRhYmxlU291cmNlKSB7XG4gIHZhciBnZXRWZXJzaW9uID0gbXV0YWJsZVNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKG11dGFibGVTb3VyY2UuX3NvdXJjZSk7IC8vIFRPRE8gQ2xlYXIgdGhpcyBkYXRhIG9uY2UgYWxsIHBlbmRpbmcgaHlkcmF0aW9uIHdvcmsgaXMgZmluaXNoZWQuXG4gIC8vIFJldGFpbmluZyBpdCBmb3JldmVyIG1heSBpbnRlcmZlcmUgd2l0aCBHQy5cblxuICBpZiAocm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID09IG51bGwpIHtcbiAgICByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSBbbXV0YWJsZVNvdXJjZSwgdmVyc2lvbl07XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2gobXV0YWJsZVNvdXJjZSwgdmVyc2lvbik7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xudmFyIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDtcblxue1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50LlxuXG52YXIgbG9jYWxJZENvdW50ZXIgPSAwOyAvLyBVc2VkIGZvciBpZHMgdGhhdCBhcmUgZ2VuZXJhdGVkIGNvbXBsZXRlbHkgY2xpZW50LXNpZGUgKGkuZS4gbm90IGR1cmluZ1xuLy8gaHlkcmF0aW9uKS4gVGhpcyBjb3VudGVyIGlzIGdsb2JhbCwgc28gY2xpZW50IGlkcyBhcmUgbm90IHN0YWJsZSBhY3Jvc3Ncbi8vIHJlbmRlciBhdHRlbXB0cy5cblxudmFyIGdsb2JhbENsaWVudElkQ291bnRlciA9IDA7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsOyAvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxuXG52YXIgaG9va1R5cGVzRGV2ID0gbnVsbDtcbnZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpIHtcbiAgICAgICAgd2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gIHtcbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIWlzQXJyYXkoZGVwcykpIHtcbiAgICAgIC8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cbiAgICBpZiAoIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gJyc7XG4gICAgICAgIHZhciBzZWNvbmRDb2x1bW5TdGFydCA9IDMwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2OyBpKyspIHtcbiAgICAgICAgICB2YXIgb2xkSG9va05hbWUgPSBob29rVHlwZXNEZXZbaV07XG4gICAgICAgICAgdmFyIG5ld0hvb2tOYW1lID0gaSA9PT0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPyBjdXJyZW50SG9va05hbWUgOiBvbGRIb29rTmFtZTtcbiAgICAgICAgICB2YXIgcm93ID0gaSArIDEgKyBcIi4gXCIgKyBvbGRIb29rTmFtZTsgLy8gRXh0cmEgc3BhY2Ugc28gc2Vjb25kIGNvbHVtbiBsaW5lcyB1cFxuICAgICAgICAgIC8vIGxvbCBAIElFIG5vdCBzdXBwb3J0aW5nIFN0cmluZyNyZXBlYXRcblxuICAgICAgICAgIHdoaWxlIChyb3cubGVuZ3RoIDwgc2Vjb25kQ29sdW1uU3RhcnQpIHtcbiAgICAgICAgICAgIHJvdyArPSAnICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ICs9IG5ld0hvb2tOYW1lICsgJ1xcbic7XG4gICAgICAgICAgdGFibGUgKz0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJ1JlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiAnICsgJ1RoaXMgd2lsbCBsZWFkIHRvIGJ1Z3MgYW5kIGVycm9ycyBpZiBub3QgZml4ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlIFJ1bGVzIG9mIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3NcXG5cXG4nICsgJyAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuJyArICcgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nICsgJyVzJyArICcgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG4nLCBjb21wb25lbnROYW1lLCB0YWJsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAge1xuICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykge1xuICAgICAgLy8gT25seSB0cnVlIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYmVpbmcgaG90IHJlbG9hZGVkLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArICd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcgKyAnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJywgY3VycmVudEhvb2tOYW1lSW5EZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZywgbmV4dFJlbmRlckxhbmVzKSB7XG4gIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gVXNlZCBmb3IgaG90IHJlbG9hZGluZzpcblxuICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4gIC8vIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBsb2NhbElkQ291bnRlciA9IDA7XG4gIC8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbiAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4gIC8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4gIC8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4gIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbiAgLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG5cbiAge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbiAgICAvLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbiAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG4gICAgICBsb2NhbElkQ291bnRlciA9IDA7XG5cbiAgICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJyArICdhbiBpbmZpbml0ZSBsb29wLicpO1xuICAgICAgfVxuXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAgICB7XG4gICAgICAgIC8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuICAgICAgfSAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG5cbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIH1cblxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIDtcbiAgICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gIH0gLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG5cblxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuICAvLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cblxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gQ29uZmlybSB0aGF0IGEgc3RhdGljIGZsYWcgd2FzIG5vdCBhZGRlZCBvciByZW1vdmVkIHNpbmNlIHRoZSBsYXN0XG4gICAgLy8gcmVuZGVyLiBJZiB0aGlzIGZpcmVzLCBpdCBzdWdnZXN0cyB0aGF0IHdlIGluY29ycmVjdGx5IHJlc2V0IHRoZSBzdGF0aWNcbiAgICAvLyBmbGFncyBpbiBzb21lIG90aGVyIHBhcnQgb2YgdGhlIGNvZGViYXNlLiBUaGlzIGhhcyBoYXBwZW5lZCBiZWZvcmUsIGZvclxuICAgIC8vIGV4YW1wbGUsIGluIHRoZSBTdXNwZW5zZUxpc3QgaW1wbGVtZW50YXRpb24uXG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAoY3VycmVudC5mbGFncyAmIFN0YXRpY01hc2spICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBTdGF0aWNNYXNrKSAmJiAvLyBEaXNhYmxlIHRoaXMgd2FybmluZyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBsZWdhY3kgU3VzcGVuc2UgaXMgd2VpcmRcbiAgICAvLyBhbmQgY3JlYXRlcyBmYWxzZSBwb3NpdGl2ZXMuIFRvIG1ha2UgdGhpcyB3b3JrIGluIGxlZ2FjeSBtb2RlLCB3ZSdkXG4gICAgLy8gbmVlZCB0byBtYXJrIGZpYmVycyB0aGF0IGNvbW1pdCBpbiBhbiBpbmNvbXBsZXRlIHN0YXRlLCBzb21laG93LiBGb3JcbiAgICAvLyBub3cgSSdsbCBkaXNhYmxlIHRoZSB3YXJuaW5nIHRoYXQgbW9zdCBvZiB0aGUgYnVncyB0aGF0IHdvdWxkIHRyaWdnZXJcbiAgICAvLyBpdCBhcmUgZWl0aGVyIGV4Y2x1c2l2ZSB0byBjb25jdXJyZW50IG1vZGUgb3IgZXhpc3QgaW4gYm90aC5cbiAgICAoY3VycmVudC5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSAnICsgJ25vdGlmeSB0aGUgUmVhY3QgdGVhbS4nKTtcbiAgICB9XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgaXMgcmVzZXQgYnkgY2hlY2tEaWRSZW5kZXJJZEhvb2tcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuXG4gIGlmIChkaWRSZW5kZXJUb29GZXdIb29rcykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgJyArICdlYXJseSByZXR1cm4gc3RhdGVtZW50LicpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSByZW5kZXJXaXRoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiByZW5kZXJXaXRoSG9va3M7IGl0J3Mgb25seSBhXG4gIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuICB2YXIgZGlkUmVuZGVySWRIb29rID0gbG9jYWxJZENvdW50ZXIgIT09IDA7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBmbGFncyBoZXJlLCBiZWNhdXNlIHRoZXkncmUgcmVzZXQgaW4gdGhlXG4gIC8vIGNvbXBsZXRlIHBoYXNlIChidWJibGVQcm9wZXJ0aWVzKS5cblxuICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KE1vdW50UGFzc2l2ZURldiB8IE1vdW50TGF5b3V0RGV2IHwgUGFzc2l2ZSB8IFVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihQYXNzaXZlIHwgVXBkYXRlKTtcbiAgfVxuXG4gIGN1cnJlbnQubGFuZXMgPSByZW1vdmVMYW5lcyhjdXJyZW50LmxhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzQWZ0ZXJUaHJvdygpIHtcbiAgLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVGhlcmUgd2VyZSByZW5kZXIgcGhhc2UgdXBkYXRlcy4gVGhlc2UgYXJlIG9ubHkgdmFsaWQgZm9yIHRoaXMgcmVuZGVyXG4gICAgLy8gcGhhc2UsIHdoaWNoIHdlIGFyZSBub3cgYWJvcnRpbmcuIFJlbW92ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZXMgc29cbiAgICAvLyB0aGV5IGRvIG5vdCBwZXJzaXN0IHRvIHRoZSBuZXh0IHJlbmRlci4gRG8gbm90IHJlbW92ZSB1cGRhdGVzIGZyb20gaG9va3NcbiAgICAvLyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkLlxuICAgIC8vXG4gICAgLy8gT25seSByZXNldCB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZSBpZiBpdCBoYXMgYSBjbG9uZS4gSWYgaXQgZG9lc1xuICAgIC8vIG5vdCBoYXZlIGEgY2xvbmUsIHRoYXQgbWVhbnMgaXQgd2Fzbid0IHByb2Nlc3NlZCwgYW5kIHRoZSB1cGRhdGVzIHdlcmVcbiAgICAvLyBzY2hlZHVsZWQgYmVmb3JlIHdlIGVudGVyZWQgdGhlIHJlbmRlciBwaGFzZS5cbiAgICB2YXIgaG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhvb2sgPSBob29rLm5leHQ7XG4gICAgfVxuXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgY3VycmVudEhvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xuICBsb2NhbElkQ291bnRlciA9IDA7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuICAvLyB0aGUgZGlzcGF0Y2hlciB1c2VkIGZvciBtb3VudHMuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAobmV4dEN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgICB2YXIgbmV3SG9vayA9IHtcbiAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0LlxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gbmV3SG9vaztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5ld0hvb2s7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgIHN0b3JlczogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICB9IGVsc2Uge1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgaW50ZXJsZWF2ZWQ6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogcmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50ID0gY3VycmVudEhvb2s7IC8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuICB2YXIgYmFzZVF1ZXVlID0gY3VycmVudC5iYXNlUXVldWU7IC8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuICAgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIHZhciBwZW5kaW5nRmlyc3QgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ0ZpcnN0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBjdXJyZW50LmJhc2VTdGF0ZTtcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cblxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBfY2xvbmU7XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIGlmICh1cGRhdGUuaGFzRWFnZXJTdGF0ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgdXBkYXRlIGlzIGEgc3RhdGUgdXBkYXRlIChub3QgYSByZWR1Y2VyKSBhbmQgd2FzIHByb2Nlc3NlZCBlYWdlcmx5LFxuICAgICAgICAgIC8vIHdlIGNhbiB1c2UgdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGVcbiAgICAgICAgICBuZXdTdGF0ZSA9IHVwZGF0ZS5lYWdlclN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBmaXJzdCk7XG5cbiAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuICAgIH0gLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIEludGVybGVhdmVkIHVwZGF0ZXMgYXJlIHN0b3JlZCBvbiBhIHNlcGFyYXRlIHF1ZXVlLiBXZSBhcmVuJ3QgZ29pbmcgdG9cbiAgLy8gcHJvY2VzcyB0aGVtIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHdlIGRvIG5lZWQgdG8gdHJhY2sgd2hpY2ggbGFuZXNcbiAgLy8gYXJlIHJlbWFpbmluZy5cblxuXG4gIHZhciBsYXN0SW50ZXJsZWF2ZWQgPSBxdWV1ZS5pbnRlcmxlYXZlZDtcblxuICBpZiAobGFzdEludGVybGVhdmVkICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVybGVhdmVkID0gbGFzdEludGVybGVhdmVkO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIGludGVybGVhdmVkTGFuZSA9IGludGVybGVhdmVkLmxhbmU7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCBpbnRlcmxlYXZlZExhbmUpO1xuICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhpbnRlcmxlYXZlZExhbmUpO1xuICAgICAgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuICAgIH0gd2hpbGUgKGludGVybGVhdmVkICE9PSBsYXN0SW50ZXJsZWF2ZWQpO1xuICB9IGVsc2UgaWYgKGJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICBxdWV1ZS5sYW5lcyA9IE5vTGFuZXM7XG4gIH1cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyOyAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAvLyB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBxdWV1ZS5wZW5kaW5nO1xuICB2YXIgbmV3U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBxdWV1ZSBkb2Vzbid0IHBlcnNpc3QgcGFzdCB0aGlzIHJlbmRlciBwYXNzLlxuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgIC8vIHJlbmRlcidzLlxuICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpOyAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuICAgIGlmICghb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7IC8vIERvbid0IHBlcnNpc3QgdGhlIHN0YXRlIGFjY3VtdWxhdGVkIGZyb20gdGhlIHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvXG4gICAgLy8gdGhlIGJhc2Ugc3RhdGUgdW5sZXNzIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAvLyBUT0RPOiBOb3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBkZXNpcmVkIHNlbWFudGljcywgYnV0IGl0J3Mgd2hhdCB3ZVxuICAgIC8vIGRvIGZvciBnRFNGUC4gSSBjYW4ndCByZW1lbWJlciB3aHkuXG5cbiAgICBpZiAoaG9vay5iYXNlUXVldWUgPT09IG51bGwpIHtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHRTbmFwc2hvdDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZ2V0SXNIeWRyYXRpbmcoKTtcblxuICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICBpZiAoZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICB9XG5cbiAgICBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICBpZiAobmV4dFNuYXBzaG90ICE9PSBnZXRTZXJ2ZXJTbmFwc2hvdCgpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U2VydmVyU25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgICBpZiAoIW9iamVjdElzKG5leHRTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuICAgIC8vXG4gICAgLy8gV2Ugd29uJ3QgZG8gdGhpcyBpZiB3ZSdyZSBoeWRyYXRpbmcgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQsIGJlY2F1c2UgaWZcbiAgICAvLyB0aGUgY29udGVudCBpcyBzdGFsZSwgaXQncyBhbHJlYWR5IHZpc2libGUgYW55d2F5LiBJbnN0ZWFkIHdlJ2xsIHBhdGNoXG4gICAgLy8gaXQgdXAgaW4gYSBwYXNzaXZlIGVmZmVjdC5cblxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIHJlbmRlckxhbmVzKSkge1xuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbiAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgdmFyIGluc3QgPSB7XG4gICAgdmFsdWU6IG5leHRTbmFwc2hvdCxcbiAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IGluc3Q7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBzdWJzY3JpYmUgdG8gdGhlIHN0b3JlLlxuXG4gIG1vdW50RWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSwgW3N1YnNjcmliZV0pOyAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gdXBkYXRlIHRoZSBtdXRhYmxlIGluc3RhbmNlIGZpZWxkcy4gV2Ugd2lsbCB1cGRhdGVcbiAgLy8gdGhpcyB3aGVuZXZlciBzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBvciB2YWx1ZSBjaGFuZ2VzLiBCZWNhdXNlIHRoZXJlJ3Mgbm9cbiAgLy8gY2xlYW4tdXAgZnVuY3Rpb24sIGFuZCB3ZSB0cmFjayB0aGUgZGVwcyBjb3JyZWN0bHksIHdlIGNhbiBjYWxsIHB1c2hFZmZlY3RcbiAgLy8gZGlyZWN0bHksIHdpdGhvdXQgc3RvcmluZyBhbnkgYWRkaXRpb25hbCBzdGF0ZS4gRm9yIHRoZSBzYW1lIHJlYXNvbiwgd2VcbiAgLy8gZG9uJ3QgbmVlZCB0byBzZXQgYSBzdGF0aWMgZmxhZywgZWl0aGVyLlxuICAvLyBUT0RPOiBXZSBjYW4gbW92ZSB0aGlzIHRvIHRoZSBwYXNzaXZlIHBoYXNlIG9uY2Ugd2UgYWRkIGEgcHJlLWNvbW1pdFxuICAvLyBjb25zaXN0ZW5jeSBjaGVjay4gU2VlIHRoZSBuZXh0IGNvbW1lbnQuXG5cbiAgZmliZXIuZmxhZ3MgfD0gUGFzc2l2ZTtcbiAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIHVuZGVmaW5lZCwgbnVsbCk7XG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbiAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuICB2YXIgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgaWYgKCFvYmplY3RJcyhuZXh0U25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZTbmFwc2hvdCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHNuYXBzaG90Q2hhbmdlZCA9ICFvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG5cbiAgaWYgKHNuYXBzaG90Q2hhbmdlZCkge1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIGluc3QgPSBob29rLnF1ZXVlO1xuICB1cGRhdGVFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbc3Vic2NyaWJlXSk7IC8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuICAvLyBjb21taXQgcGhhc2UgaWYgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIG11dGF0aW9uLiBJbiBjb25jdXJyZW50IG1vZGVcbiAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAvLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG5cbiAgaWYgKGluc3QuZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8IHNuYXBzaG90Q2hhbmdlZCB8fCAvLyBDaGVjayBpZiB0aGUgc3VzYmNyaWJlIGZ1bmN0aW9uIGNoYW5nZWQuIFdlIGNhbiBzYXZlIHNvbWUgbWVtb3J5IGJ5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgd2Ugc2NoZWR1bGVkIGEgc3Vic2NyaXB0aW9uIGVmZmVjdCBhYm92ZS5cbiAgd29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLnRhZyAmIEhhc0VmZmVjdCkge1xuICAgIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmU7XG4gICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIHVuZGVmaW5lZCwgbnVsbCk7IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIHJlbmRlckxhbmVzKSkge1xuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIHJlbmRlcmVkU25hcHNob3QpIHtcbiAgZmliZXIuZmxhZ3MgfD0gU3RvcmVDb25zaXN0ZW5jeTtcbiAgdmFyIGNoZWNrID0ge1xuICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCxcbiAgICB2YWx1ZTogcmVuZGVyZWRTbmFwc2hvdFxuICB9O1xuICB2YXIgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChjb21wb25lbnRVcGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjb21wb25lbnRVcGRhdGVRdWV1ZTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdG9yZXMgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXM7XG5cbiAgICBpZiAoc3RvcmVzID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZXMucHVzaChjaGVjayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHtcbiAgLy8gVGhlc2UgYXJlIHVwZGF0ZWQgaW4gdGhlIHBhc3NpdmUgcGhhc2VcbiAgaW5zdC52YWx1ZSA9IG5leHRTbmFwc2hvdDtcbiAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBTb21ldGhpbmcgbWF5IGhhdmUgYmVlbiBtdXRhdGVkIGluIGJldHdlZW4gcmVuZGVyIGFuZCBjb21taXQuIFRoaXMgY291bGRcbiAgLy8gaGF2ZSBiZWVuIGluIGFuIGV2ZW50IHRoYXQgZmlyZWQgYmVmb3JlIHRoZSBwYXNzaXZlIGVmZmVjdHMsIG9yIGl0IGNvdWxkXG4gIC8vIGhhdmUgYmVlbiBpbiBhIGxheW91dCBlZmZlY3QuIEluIHRoYXQgY2FzZSwgd2Ugd291bGQgaGF2ZSB1c2VkIHRoZSBvbGRcbiAgLy8gc25hcHNobyBhbmQgZ2V0U25hcHNob3QgdmFsdWVzIHRvIGJhaWwgb3V0LiBXZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIHRpbWUuXG5cbiAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuICB2YXIgaGFuZGxlU3RvcmVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2VcbiAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgfVxuICB9OyAvLyBTdWJzY3JpYmUgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gYSBjbGVhbi11cCBmdW5jdGlvbi5cblxuXG4gIHJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xufVxuXG5mdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZSgpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGludGVybGVhdmVkOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoRWZmZWN0KHRhZywgY3JlYXRlLCBkZXN0cm95LCBkZXBzKSB7XG4gIHZhciBlZmZlY3QgPSB7XG4gICAgdGFnOiB0YWcsXG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgZGVzdHJveTogZGVzdHJveSxcbiAgICBkZXBzOiBkZXBzLFxuICAgIC8vIENpcmN1bGFyXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICB2YXIgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChjb21wb25lbnRVcGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjb21wb25lbnRVcGRhdGVRdWV1ZTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhc3RFZmZlY3QgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKGxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgbGFzdEVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgICAgZWZmZWN0Lm5leHQgPSBmaXJzdEVmZmVjdDtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVmZmVjdDtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICB7XG4gICAgdmFyIF9yZWYyID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBfcmVmMjtcbiAgICByZXR1cm4gX3JlZjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gaG9vay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCB1bmRlZmluZWQsIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIGRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGN1cnJlbnRIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZFZmZlY3QgPSBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICAgIGRlc3Ryb3kgPSBwcmV2RWZmZWN0LmRlc3Ryb3k7XG5cbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZFZmZlY3QuZGVwcztcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0ZsYWdzLCBjcmVhdGUsIGRlc3Ryb3ksIG5leHREZXBzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgaWYgKCAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKE1vdW50UGFzc2l2ZURldiB8IFBhc3NpdmUgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChQYXNzaXZlIHwgUGFzc2l2ZVN0YXRpYywgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoUGFzc2l2ZSwgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG4gIHtcbiAgICBmaWJlckZsYWdzIHw9IExheW91dFN0YXRpYztcbiAgfVxuXG4gIGlmICggKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxuXG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZDYWxsYmFjayhfaW5zdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlZk9iamVjdCA9IHJlZjtcblxuICAgIHtcbiAgICAgIGlmICghcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnICsgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2luc3QyID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0MjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgdmFyIGZpYmVyRmxhZ3MgPSBVcGRhdGU7XG5cbiAge1xuICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICB9XG5cbiAgaWYgKCAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICB9XG5cbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudERlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7Ly8gVGhpcyBob29rIGlzIG5vcm1hbGx5IGEgbm8tb3AuXG4gIC8vIFRoZSByZWFjdC1kZWJ1Zy1ob29rcyBwYWNrYWdlIGluamVjdHMgaXRzIG93biBpbXBsZW1lbnRhdGlvblxuICAvLyBzbyB0aGF0IGUuZy4gRGV2VG9vbHMgY2FuIGRpc3BsYXkgY3VzdG9tIGhvb2sgdmFsdWVzLlxufVxuXG52YXIgdXBkYXRlRGVidWdWYWx1ZSA9IG1vdW50RGVidWdWYWx1ZTtcblxuZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIG1vdW50TWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAvLyBBc3N1bWUgdGhlc2UgYXJlIGRlZmluZWQuIElmIHRoZXkncmUgbm90LCBhcmVIb29rSW5wdXRzRXF1YWwgd2lsbCB3YXJuLlxuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgX21vdW50U3RhdGUgPSBtb3VudFN0YXRlKHZhbHVlKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9tb3VudFN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfbW91bnRTdGF0ZVsxXTtcblxuICBtb3VudEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgX3VwZGF0ZVN0YXRlID0gdXBkYXRlU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF91cGRhdGVTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX3VwZGF0ZVN0YXRlWzFdO1xuXG4gIHVwZGF0ZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfcmVyZW5kZXJTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSB7fTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBwcmV2VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzZXRQZW5kaW5nLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoaGlnaGVyRXZlbnRQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5LCBDb250aW51b3VzRXZlbnRQcmlvcml0eSkpO1xuICBzZXRQZW5kaW5nKHRydWUpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgc2V0UGVuZGluZyhmYWxzZSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICB7XG4gICAgICBpZiAocHJldlRyYW5zaXRpb24gPT09IG51bGwgJiYgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICB2YXIgX21vdW50U3RhdGUyID0gbW91bnRTdGF0ZShmYWxzZSksXG4gICAgICBpc1BlbmRpbmcgPSBfbW91bnRTdGF0ZTJbMF0sXG4gICAgICBzZXRQZW5kaW5nID0gX21vdW50U3RhdGUyWzFdOyAvLyBUaGUgYHN0YXJ0YCBtZXRob2QgbmV2ZXIgY2hhbmdlcy5cblxuXG4gIHZhciBzdGFydCA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKG51bGwsIHNldFBlbmRpbmcpO1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXJ0O1xuICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICB2YXIgX3VwZGF0ZVN0YXRlMiA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfdXBkYXRlU3RhdGUyWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUyID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3JlcmVuZGVyU3RhdGUyWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxudmFyIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbmZ1bmN0aW9uIGdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpIHtcbiAge1xuICAgIHJldHVybiBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SWQoKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTsgLy8gVE9ETzogSW4gRml6eiwgaWQgZ2VuZXJhdGlvbiBpcyBzcGVjaWZpYyB0byBlYWNoIHNlcnZlciBjb25maWcuIE1heWJlIHdlXG4gIC8vIHNob3VsZCBkbyB0aGlzIGluIEZpYmVyLCB0b28/IERlZmVycmluZyB0aGlzIGRlY2lzaW9uIGZvciBub3cgYmVjYXVzZVxuICAvLyB0aGVyZSdzIG5vIG90aGVyIHBsYWNlIHRvIHN0b3JlIHRoZSBwcmVmaXggZXhjZXB0IGZvciBhbiBpbnRlcm5hbCBmaWVsZCBvblxuICAvLyB0aGUgcHVibGljIGNyZWF0ZVJvb3Qgb2JqZWN0LCB3aGljaCB0aGUgZmliZXIgdHJlZSBkb2VzIG5vdCBjdXJyZW50bHkgaGF2ZVxuICAvLyBhIHJlZmVyZW5jZSB0by5cblxuICB2YXIgaWRlbnRpZmllclByZWZpeCA9IHJvb3QuaWRlbnRpZmllclByZWZpeDtcbiAgdmFyIGlkO1xuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCgpOyAvLyBVc2UgYSBjYXB0aWFsIFIgcHJlZml4IGZvciBzZXJ2ZXItZ2VuZXJhdGVkIGlkcy5cblxuICAgIGlkID0gJzonICsgaWRlbnRpZmllclByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gICAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuICAgIC8vIGhvb2tzIGZvciB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxvY2FsSWQgPSBsb2NhbElkQ291bnRlcisrO1xuXG4gICAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgICBpZCArPSAnSCcgKyBsb2NhbElkLnRvU3RyaW5nKDMyKTtcbiAgICB9XG5cbiAgICBpZCArPSAnOic7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIGEgbG93ZXJjYXNlIHIgcHJlZml4IGZvciBjbGllbnQtZ2VuZXJhdGVkIGlkcy5cbiAgICB2YXIgZ2xvYmFsQ2xpZW50SWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKztcbiAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAncicgKyBnbG9iYWxDbGllbnRJZC50b1N0cmluZygzMikgKyAnOic7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBpZDtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJZCgpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGlkID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoUmVkdWNlckFjdGlvbihmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlKTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSk7XG4gICAgfVxuICB9XG5cbiAgbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIiArICdzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnICsgJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBsYW5lOiBsYW5lLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6IGZhbHNlLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUpO1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoZmliZXIubGFuZXMgPT09IE5vTGFuZXMgJiYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCBhbHRlcm5hdGUubGFuZXMgPT09IE5vTGFuZXMpKSB7XG4gICAgICAvLyBUaGUgcXVldWUgaXMgY3VycmVudGx5IGVtcHR5LCB3aGljaCBtZWFucyB3ZSBjYW4gZWFnZXJseSBjb21wdXRlIHRoZVxuICAgICAgLy8gbmV4dCBzdGF0ZSBiZWZvcmUgZW50ZXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gSWYgdGhlIG5ldyBzdGF0ZSBpcyB0aGVcbiAgICAgIC8vIHNhbWUgYXMgdGhlIGN1cnJlbnQgc3RhdGUsIHdlIG1heSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVudGlyZWx5LlxuICAgICAgdmFyIGxhc3RSZW5kZXJlZFJlZHVjZXIgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyO1xuXG4gICAgICBpZiAobGFzdFJlbmRlcmVkUmVkdWNlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXI7XG5cbiAgICAgICAge1xuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlO1xuICAgICAgICAgIHZhciBlYWdlclN0YXRlID0gbGFzdFJlbmRlcmVkUmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7IC8vIFN0YXNoIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLCBhbmQgdGhlIHJlZHVjZXIgdXNlZCB0byBjb21wdXRlXG4gICAgICAgICAgLy8gaXQsIG9uIHRoZSB1cGRhdGUgb2JqZWN0LiBJZiB0aGUgcmVkdWNlciBoYXNuJ3QgY2hhbmdlZCBieSB0aGVcbiAgICAgICAgICAvLyB0aW1lIHdlIGVudGVyIHRoZSByZW5kZXIgcGhhc2UsIHRoZW4gdGhlIGVhZ2VyIHN0YXRlIGNhbiBiZSB1c2VkXG4gICAgICAgICAgLy8gd2l0aG91dCBjYWxsaW5nIHRoZSByZWR1Y2VyIGFnYWluLlxuXG4gICAgICAgICAgdXBkYXRlLmhhc0VhZ2VyU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcblxuICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKSB7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGguIFdlIGNhbiBiYWlsIG91dCB3aXRob3V0IHNjaGVkdWxpbmcgUmVhY3QgdG8gcmUtcmVuZGVyLlxuICAgICAgICAgICAgLy8gSXQncyBzdGlsbCBwb3NzaWJsZSB0aGF0IHdlJ2xsIG5lZWQgdG8gcmViYXNlIHRoaXMgdXBkYXRlIGxhdGVyLFxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcbiAgICAgICAgICAgIC8vIHRpbWUgdGhlIHJlZHVjZXIgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikgey8vIFN1cHByZXNzIHRoZSBlcnJvci4gSXQgd2lsbCB0aHJvdyBhZ2FpbiBpbiB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgcm9vdCA9IHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lKTtcbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICByZXR1cm4gZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIGlmIChpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyKSkge1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG4gICAgICBwdXNoSW50ZXJsZWF2ZWRRdWV1ZShxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgcXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSkge1xuICBpZiAoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7IC8vIElmIGFueSBlbnRhbmdsZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBwZW5kaW5nIG9uIHRoZSByb290LCB0aGVuIHRoZXlcbiAgICAvLyBtdXN0IGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoXG4gICAgLy8gcmVwcmVzZW50cyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlXG4gICAgLy8gbWF5IGVudGFuZ2xlIG1vcmUgdGhhbiB3ZSBuZWVkIHRvLCBidXQgdGhhdCdzIE9LLiBJbiBmYWN0IGl0J3Mgd29yc2UgaWZcbiAgICAvLyB3ZSAqZG9uJ3QqIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxuXG4gICAgcXVldWVMYW5lcyA9IGludGVyc2VjdExhbmVzKHF1ZXVlTGFuZXMsIHJvb3QucGVuZGluZ0xhbmVzKTsgLy8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cblxuICAgIHZhciBuZXdRdWV1ZUxhbmVzID0gbWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLCBsYW5lKTtcbiAgICBxdWV1ZS5sYW5lcyA9IG5ld1F1ZXVlTGFuZXM7IC8vIEV2ZW4gaWYgcXVldWUubGFuZXMgYWxyZWFkeSBpbmNsdWRlIGxhbmUsIHdlIGRvbid0IGtub3cgZm9yIGNlcnRhaW4gaWZcbiAgICAvLyB0aGUgbGFuZSBmaW5pc2hlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGVudGFuZ2xlZCBpdC4gU28gd2UgbmVlZCB0b1xuICAgIC8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5cbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBuZXdRdWV1ZUxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSwgYWN0aW9uKSB7XG5cbiAge1xuICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNdXRhYmxlU291cmNlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxufTtcblxudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG5cbntcbiAgdmFyIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gIH07XG5cbiAgdmFyIHdhcm5JbnZhbGlkSG9va0FjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG59XG5cbnZhciBub3ckMiA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbnZhciBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gLTE7XG4vKipcbiAqIFRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQvY2FzY2FkaW5nIHVwZGF0ZSAoc2NoZWR1bGVkIGZyb20gYSBsYXlvdXQgZWZmZWN0KS5cbiAqXG4gKiBUaGUgb3ZlcmFsbCBzZXF1ZW5jZSBpczpcbiAqICAgMS4gcmVuZGVyXG4gKiAgIDIuIGNvbW1pdCAoYW5kIGNhbGwgYG9uUmVuZGVyYCwgYG9uQ29tbWl0YClcbiAqICAgMy4gY2hlY2sgZm9yIG5lc3RlZCB1cGRhdGVzXG4gKiAgIDQuIGZsdXNoIHBhc3NpdmUgZWZmZWN0cyAoYW5kIGNhbGwgYG9uUG9zdENvbW1pdGApXG4gKlxuICogTmVzdGVkIHVwZGF0ZXMgYXJlIGlkZW50aWZpZWQgaW4gc3RlcCAzIGFib3ZlLFxuICogYnV0IHN0ZXAgNCBzdGlsbCBhcHBsaWVzIHRvIHRoZSB3b3JrIHRoYXQgd2FzIGp1c3QgY29tbWl0dGVkLlxuICogV2UgdXNlIHR3byBmbGFncyB0byB0cmFjayBuZXN0ZWQgdXBkYXRlcyB0aGVuOlxuICogb25lIHRyYWNrcyB3aGV0aGVyIHRoZSB1cGNvbWluZyB1cGRhdGUgaXMgYSBuZXN0ZWQgdXBkYXRlLFxuICogYW5kIHRoZSBvdGhlciB0cmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkIHVwZGF0ZS5cbiAqIFRoZSBmaXJzdCB2YWx1ZSBnZXRzIHN5bmNlZCB0byB0aGUgc2Vjb25kIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLlxuICovXG5cbnZhciBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbnZhciBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkge1xuICByZXR1cm4gY3VycmVudFVwZGF0ZUlzTmVzdGVkO1xufVxuXG5mdW5jdGlvbiBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCkge1xuICB7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKSB7XG4gIHtcbiAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jTmVzdGVkVXBkYXRlRmxhZygpIHtcbiAge1xuICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IG5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcblxuICBjb21taXRUaW1lID0gbm93JDIoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3ckMigpO1xuXG4gIGlmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPCAwKSB7XG4gICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gbm93JDIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuXG4gICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChsYXlvdXRFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBsYXlvdXRFZmZlY3RTdGFydFRpbWU7XG4gICAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7IC8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3JcbiAgICAvLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAgd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpYmVyKSB7XG5cbiAgaWYgKHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lO1xuICAgIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSAtMTsgLy8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuICAgIC8vIE9yIHRoZSByb290IChmb3IgdGhlIERldlRvb2xzIFByb2ZpbGVyIHRvIHJlYWQpXG5cbiAgICB2YXIgcGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgICB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGFjaGVkIGZpYmVycyBoYXZlIHRoZWlyIHN0YXRlIG5vZGUgY2xlYXJlZCBvdXQuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZXR1cm4gcG9pbnRlciBpcyBhbHNvIGNsZWFyZWQgb3V0LFxuICAgICAgICAgICAgLy8gc28gd2Ugd29uJ3QgYmUgYWJsZSB0byByZXBvcnQgdGhlIHRpbWUgc3BlbnQgaW4gdGhpcyBQcm9maWxlcidzIHN1YnRyZWUuXG4gICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKSB7XG5cbiAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gbm93JDIoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKSB7XG5cbiAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IG5vdyQyKCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpIHtcbiAgLy8gVHJhbnNmZXIgdGltZSBzcGVudCByZW5kZXJpbmcgdGhlc2UgY2hpbGRyZW4gc28gd2UgZG9uJ3QgbG9zZSBpdFxuICAvLyBhZnRlciB3ZSByZXJlbmRlci4gVGhpcyBpcyB1c2VkIGFzIGEgaGVscGVyIGluIHNwZWNpYWwgY2FzZXNcbiAgLy8gd2hlcmUgd2Ugc2hvdWxkIGNvdW50IHRoZSB3b3JrIG9mIG11bHRpcGxlIHBhc3Nlcy5cbiAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZSkge1xuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbiAgLy8gc28gdGhlIHN0YWNrIGlzIGFjY3VyYXRlLlxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgfTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgaXMgZm9ya2VkIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuXG4vLyBCeSBkZWZhdWx0LCByZXR1cm4gYHRydWVgIHRvIGxvZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUuXG4vLyBGb3JrcyBjYW4gcmV0dXJuIGBmYWxzZWAgaWYgdGhpcyBpc24ndCBkZXNpcmFibGUuXG5mdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksIGVycm9ySW5mbykge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgdmFyIGxvZ0Vycm9yID0gc2hvd0Vycm9yRGlhbG9nKGJvdW5kYXJ5LCBlcnJvckluZm8pOyAvLyBBbGxvdyBpbmplY3RlZCBzaG93RXJyb3JEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuICAgIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cblxuICAgIGlmIChsb2dFcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICBpZiAodHJ1ZSkge1xuICAgICAgdmFyIHNvdXJjZSA9IGVycm9ySW5mby5zb3VyY2U7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJyc7IC8vIEJyb3dzZXJzIHN1cHBvcnQgc2lsZW5jaW5nIHVuY2F1Z2h0IGVycm9ycyBieSBjYWxsaW5nXG4gICAgICAvLyBgcHJldmVudERlZmF1bHQoKWAgaW4gd2luZG93IGBlcnJvcmAgaGFuZGxlci5cbiAgICAgIC8vIFdlIHJlY29yZCB0aGlzIGluZm9ybWF0aW9uIGFzIGFuIGV4cGFuZG8gb24gdGhlIGVycm9yLlxuXG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCAmJiBlcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgIGlmIChib3VuZGFyeS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgLy8gVGhlIGVycm9yIGlzIHJlY292ZXJhYmxlIGFuZCB3YXMgc2lsZW5jZWQuXG4gICAgICAgICAgLy8gSWdub3JlIGl0IGFuZCBkb24ndCBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG4gICAgICAgICAgLy8gVGhpcyBpcyBoYW5keSBmb3IgdGVzdGluZyBlcnJvciBib3VuZGFyaWVzIHdpdGhvdXQgbm9pc2UuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFRoZSBlcnJvciBpcyBmYXRhbC4gU2luY2UgdGhlIHNpbGVuY2luZyBtaWdodCBoYXZlXG4gICAgICAgIC8vIGJlZW4gYWNjaWRlbnRhbCwgd2UnbGwgc3VyZmFjZSBpdCBhbnl3YXkuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBicm93c2VyIHdvdWxkIGhhdmUgc2lsZW5jZWQgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAgIC8vIHNvIHdlJ2xsIHByaW50IGl0IGZpcnN0LCBhbmQgdGhlbiBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG5cblxuICAgICAgICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgICAgIC8vIEZvciBhIG1vcmUgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhpcyBibG9jaywgc2VlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IHNvdXJjZSA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoc291cmNlKSA6IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50OlwiIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG4gICAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7XG5cbiAgICAgIGlmIChib3VuZGFyeS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGJvdW5kYXJ5KSB8fCAnQW5vbnltb3VzJztcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIFwiICsgKFwidXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIgKyBlcnJvckJvdW5kYXJ5TmFtZSArIFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9IGNvbXBvbmVudE5hbWVNZXNzYWdlICsgXCJcXG5cIiArIGNvbXBvbmVudFN0YWNrICsgXCJcXG5cXG5cIiArIChcIlwiICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpOyAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cblxuICAgICAgY29uc29sZVsnZXJyb3InXShjb21iaW5lZE1lc3NhZ2UpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgd2UgcHJpbnQgdGhlIGVycm9yIGRpcmVjdGx5LlxuICAgICAgLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIG1lc3NhZ2UsIHRoZSBKUyBzdGFjaywgYW5kIGFueXRoaW5nIHRoZSBicm93c2VyIHdhbnRzIHRvIHNob3cuXG4gICAgICAvLyBXZSBwYXNzIHRoZSBlcnJvciBvYmplY3QgaW5zdGVhZCBvZiBjdXN0b20gbWVzc2FnZSBzbyB0aGF0IHRoZSBicm93c2VyIGRpc3BsYXlzIHRoZSBlcnJvciBuYXRpdmVseS5cbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgUG9zc2libHlXZWFrTWFwJDEgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIGxhbmUpOyAvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxuXG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBudWxsXG4gIH07XG4gIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgb25VbmNhdWdodEVycm9yKGVycm9yKTtcbiAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICB9O1xuXG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgbGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBlcnJvciQxID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgdXBkYXRlLnBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuICAgIH07XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgaWYgKGluc3QgIT09IG51bGwgJiYgdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIHtcbiAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgfVxuXG4gICAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuXG4gICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbiAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvZiB3aGljaCBvbmVzIGFscmVhZHkgZmFpbGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgICAgICAvLyBUaGlzIGdldHMgcmVzZXQgYmVmb3JlIHdlIHlpZWxkIGJhY2sgdG8gdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzXG4gICAgICAgIC8vIG5vdCBkZWZpbmVkLlxuICAgICAgICBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudERpZENhdGNoIGlzIHRoZSBvbmx5IGVycm9yIGJvdW5kYXJ5IG1ldGhvZCBkZWZpbmVkLFxuICAgICAgICAgIC8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsIFN5bmNMYW5lKSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgKyAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAvLyBBdHRhY2ggYSBwaW5nIGxpc3RlbmVyXG4gIC8vXG4gIC8vIFRoZSBkYXRhIG1pZ2h0IHJlc29sdmUgYmVmb3JlIHdlIGhhdmUgYSBjaGFuY2UgdG8gY29tbWl0IHRoZSBmYWxsYmFjay4gT3IsXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgcmVmcmVzaCwgd2UnbGwgbmV2ZXIgY29tbWl0IGEgZmFsbGJhY2suIFNvIHdlIG5lZWQgdG9cbiAgLy8gYXR0YWNoIGEgbGlzdGVuZXIgbm93LiBXaGVuIGl0IHJlc29sdmVzIChcInBpbmdzXCIpLCB3ZSBjYW4gZGVjaWRlIHdoZXRoZXIgdG9cbiAgLy8gdHJ5IHJlbmRlcmluZyB0aGUgdHJlZSBhZ2Fpbi5cbiAgLy9cbiAgLy8gT25seSBhdHRhY2ggYSBsaXN0ZW5lciBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIGxhbmVzXG4gIC8vIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgKHdoaWNoIGFjdHMgbGlrZSBhIFwidGhyZWFkIElEXCIgaGVyZSkuXG4gIC8vXG4gIC8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuICAvLyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmUgbm8gcGluZ3MuXG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgdmFyIHRocmVhZElEcztcblxuICBpZiAocGluZ0NhY2hlID09PSBudWxsKSB7XG4gICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwJDEoKTtcbiAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtcblxuICAgIGlmICh0aHJlYWRJRHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRocmVhZElEcy5oYXMobGFuZXMpKSB7XG4gICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgdGhyZWFkIElEIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKTtcbiAgICB2YXIgcGluZyA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2FrZWFibGUudGhlbihwaW5nLCBwaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnksIHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAvLyBSZXRyeSBsaXN0ZW5lclxuICAvL1xuICAvLyBJZiB0aGUgZmFsbGJhY2sgZG9lcyBjb21taXQsIHdlIG5lZWQgdG8gYXR0YWNoIGEgZGlmZmVyZW50IHR5cGUgb2ZcbiAgLy8gbGlzdGVuZXIuIFRoaXMgb25lIHNjaGVkdWxlcyBhbiB1cGRhdGUgb24gdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IHRvIHR1cm5cbiAgLy8gdGhlIGZhbGxiYWNrIHN0YXRlIG9mZi5cbiAgLy9cbiAgLy8gU3Rhc2ggdGhlIHdha2VhYmxlIG9uIHRoZSBib3VuZGFyeSBmaWJlciBzbyB3ZSBjYW4gYWNjZXNzIGl0IGluIHRoZVxuICAvLyBjb21taXQgcGhhc2UuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIHdha2VhYmxlIHJlc29sdmVzLCB3ZSdsbCBhdHRlbXB0IHRvIHJlbmRlciB0aGUgYm91bmRhcnlcbiAgLy8gYWdhaW4gKFwicmV0cnlcIikuXG4gIHZhciB3YWtlYWJsZXMgPSBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh3YWtlYWJsZXMgPT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG4gICAgdXBkYXRlUXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWU7XG4gIH0gZWxzZSB7XG4gICAgd2FrZWFibGVzLmFkZCh3YWtlYWJsZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyBBIGxlZ2FjeSBtb2RlIFN1c3BlbnNlIHF1aXJrLCBvbmx5IHJlbGV2YW50IHRvIGhvb2sgY29tcG9uZW50cy5cblxuXG4gIHZhciB0YWcgPSBzb3VyY2VGaWJlci50YWc7XG5cbiAgaWYgKChzb3VyY2VGaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgKHRhZyA9PT0gRnVuY3Rpb25Db21wb25lbnQgfHwgdGFnID09PSBGb3J3YXJkUmVmIHx8IHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudCkpIHtcbiAgICB2YXIgY3VycmVudFNvdXJjZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50U291cmNlKSB7XG4gICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IGN1cnJlbnRTb3VyY2UudXBkYXRlUXVldWU7XG4gICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gY3VycmVudFNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICAgICAgc291cmNlRmliZXIubGFuZXMgPSBjdXJyZW50U291cmNlLmxhbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUocmV0dXJuRmliZXIpIHtcbiAgdmFyIG5vZGUgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gLy8gVGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGR1cmluZyB0aGlzIHJlbmRlci4gQ29udGludWUgdG8gdGhlIG5leHRcbiAgICAvLyBib3VuZGFyeS5cblxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgbWFya3MgYSBTdXNwZW5zZSBib3VuZGFyeSBzbyB0aGF0IHdoZW4gd2UncmUgdW53aW5kaW5nIHRoZSBzdGFjayxcbiAgLy8gaXQgY2FwdHVyZXMgdGhlIHN1c3BlbmRlZCBcImV4Y2VwdGlvblwiIGFuZCBkb2VzIGEgc2Vjb25kIChmYWxsYmFjaykgcGFzcy5cbiAgaWYgKChzdXNwZW5zZUJvdW5kYXJ5Lm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIC8vIExlZ2FjeSBNb2RlIFN1c3BlbnNlXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYm91bmRhcnkgaXMgaW4gbGVnYWN5IG1vZGUsIHdlIHNob3VsZCAqbm90KlxuICAgIC8vIHN1c3BlbmQgdGhlIGNvbW1pdC4gUHJldGVuZCBhcyBpZiB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCByZW5kZXJlZFxuICAgIC8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBXaGVuIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBjb21wbGV0ZXMsXG4gICAgLy8gd2UnbGwgZG8gYSBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLlxuICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5ID09PSByZXR1cm5GaWJlcikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZXJlIHdlIHN1c3BlbmRlZCB3aGlsZSByZWNvbmNpbGluZyB0aGUgY2hpbGRyZW4gb2ZcbiAgICAgIC8vIGEgU3VzcGVuc2UgYm91bmRhcnkncyBpbm5lciBPZmZzY3JlZW4gd3JhcHBlciBmaWJlci4gVGhpcyBoYXBwZW5zXG4gICAgICAvLyB3aGVuIGEgUmVhY3QubGF6eSBjb21wb25lbnQgaXMgYSBkaXJlY3QgY2hpbGQgb2YgYVxuICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcnkuXG4gICAgICAvL1xuICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcmllcyBhcmUgaW1wbGVtZW50ZWQgYXMgbXVsdGlwbGUgZmliZXJzLCBidXQgdGhleVxuICAgICAgLy8gYXJlIGEgc2luZ2xlIGNvbmNlcHR1YWwgdW5pdC4gVGhlIGxlZ2FjeSBtb2RlIGJlaGF2aW9yIHdoZXJlIHdlXG4gICAgICAvLyBwcmV0ZW5kIHRoZSBzdXNwZW5kZWQgZmliZXIgY29tbWl0dGVkIGFzIGBudWxsYCB3b24ndCB3b3JrLFxuICAgICAgLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UgdGhlIFwic3VzcGVuZGVkXCIgZmliZXIgaXMgdGhlIGlubmVyXG4gICAgICAvLyBPZmZzY3JlZW4gd3JhcHBlci5cbiAgICAgIC8vXG4gICAgICAvLyBCZWNhdXNlIHRoZSBjb250ZW50cyBvZiB0aGUgYm91bmRhcnkgaGF2ZW4ndCBzdGFydGVkIHJlbmRlcmluZ1xuICAgICAgLy8geWV0IChpLmUuIG5vdGhpbmcgaW4gdGhlIHRyZWUgaGFzIHBhcnRpYWxseSByZW5kZXJlZCkgd2UgY2FuXG4gICAgICAvLyBzd2l0Y2ggdG8gdGhlIHJlZ3VsYXIsIGNvbmN1cnJlbnQgbW9kZSBiZWhhdmlvcjogbWFyayB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHdpdGggU2hvdWxkQ2FwdHVyZSBhbmQgZW50ZXIgdGhlIHVud2luZCBwaGFzZS5cbiAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgc291cmNlRmliZXIuZmxhZ3MgfD0gRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZTsgLy8gV2UncmUgZ29pbmcgdG8gY29tbWl0IHRoaXMgZmliZXIgZXZlbiB0aG91Z2ggaXQgZGlkbid0IGNvbXBsZXRlLlxuICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuICAgICAgLy8gYWxsIGxpZmVjeWNsZSBlZmZlY3QgdGFncy5cblxuICAgICAgc291cmNlRmliZXIuZmxhZ3MgJj0gfihMaWZlY3ljbGVFZmZlY3RNYXNrIHwgSW5jb21wbGV0ZSk7XG5cbiAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlICYmIGVuYWJsZVBlcnNpc3RlbnRPZmZzY3JlZW5Ib3N0Q29udGFpbmVyKSB7XG4gICAgICAgIC8vIEFub3RoZXIgbGVnYWN5IFN1c3BlbnNlIHF1aXJrLiBJbiBwZXJzaXN0ZW50IG1vZGUsIGlmIHRoaXMgaXMgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgbW91bnQsIG92ZXJyaWRlIHRoZSBwcm9wcyBvZiB0aGUgaG9zdCBjb250YWluZXIgdG8gaGlkZVxuICAgICAgICAvLyBpdHMgY29udGVudHMuXG4gICAgICAgIHZhciBjdXJyZW50U3VzcGVuc2VCb3VuZGFyeSA9IHN1c3BlbnNlQm91bmRhcnkuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChjdXJyZW50U3VzcGVuc2VCb3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBvZmZzY3JlZW5GaWJlciA9IHN1c3BlbnNlQm91bmRhcnkuY2hpbGQ7XG4gICAgICAgICAgdmFyIG9mZnNjcmVlbkNvbnRhaW5lciA9IG9mZnNjcmVlbkZpYmVyLmNoaWxkO1xuXG4gICAgICAgICAgaWYgKG9mZnNjcmVlbkNvbnRhaW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gb2Zmc2NyZWVuQ29udGFpbmVyLm1lbW9pemVkUHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUHJvcHMgPSBnZXRPZmZzY3JlZW5Db250YWluZXJQcm9wcygnaGlkZGVuJywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGFpbmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRhaW5lclByb3BzO1xuICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGFpbmVyLm1lbW9pemVkUHJvcHMgPSBjb250YWluZXJQcm9wcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTb3VyY2VGaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICBpZiAoY3VycmVudFNvdXJjZUZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudC4gQ2hhbmdlIHRoZSB0YWcgc28gaXQncyBub3QgbWlzdGFrZW4gZm9yIGFcbiAgICAgICAgICAvLyBjb21wbGV0ZWQgY2xhc3MgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgd2Ugc2hvdWxkIG5vdCBjYWxsXG4gICAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgaWYgaXQgaXMgZGVsZXRlZC5cbiAgICAgICAgICBzb3VyY2VGaWJlci50YWcgPSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSB0cnkgcmVuZGVyaW5nIGFnYWluLCB3ZSBzaG91bGQgbm90IHJldXNlIHRoZSBjdXJyZW50IGZpYmVyLFxuICAgICAgICAgIC8vIHNpbmNlIGl0J3Mga25vd24gdG8gYmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBVc2UgYSBmb3JjZSB1cGRhdGUgdG9cbiAgICAgICAgICAvLyBwcmV2ZW50IGEgYmFpbCBvdXQuXG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgU3luY0xhbmUpO1xuICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcbiAgICAgICAgICBlbnF1ZXVlVXBkYXRlKHNvdXJjZUZpYmVyLCB1cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbiAgICAgIC8vIGluZGljYXRlIHRoYXQgaXQgc3RpbGwgaGFzIHBlbmRpbmcgd29yay5cblxuXG4gICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbiAgfSAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBjb25jdXJyZW50IG1vZGUgdHJlZS4gQ29udGludWVcbiAgLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbiAgLy9cbiAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gIC8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuICAvLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbiAgLy9cbiAgLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbiAgLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbiAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcbiAgLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbiAgLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbiAgLy9cbiAgLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbiAgLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG4gIC8vXG4gIC8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbiAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG4gIC8vXG4gIC8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgLy9cbiAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cbiAgLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbiAgLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4gIC8vXG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4gIC8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuICAvLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbiAgLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuICAvL1xuICAvLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG4gIC8vXG4gIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbiAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTaG91bGRDYXB0dXJlOyAvLyBUT0RPOiBJIHRoaW5rIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2Ugbm93IHVzZSBgRGlkQ2FwdHVyZWAgaW5cbiAgLy8gdGhlIGJlZ2luIHBoYXNlIHRvIHByZXZlbnQgYW4gZWFybHkgYmFpbG91dC5cblxuICBzdXNwZW5zZUJvdW5kYXJ5LmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZmxhZ3MgfD0gSW5jb21wbGV0ZTtcblxuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSB3YWtlYWJsZS4gVGhlIGNvbXBvbmVudCBzdXNwZW5kZWQuXG4gICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG4gICAgcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIpO1xuXG5cbiAgICB2YXIgc3VzcGVuc2VCb3VuZGFyeSA9IGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKTtcblxuICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIFdlIG9ubHkgYXR0YWNoIHBpbmcgbGlzdGVuZXJzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuICAgICAgLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuXG4gICAgICBpZiAoc3VzcGVuc2VCb3VuZGFyeS5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnksIHJvb3QsIHdha2VhYmxlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gYm91bmRhcnkgd2FzIGZvdW5kLiBVbmxlc3MgdGhpcyBpcyBhIHN5bmMgdXBkYXRlLCB0aGlzIGlzIE9LLlxuICAgICAgLy8gV2UgY2FuIHN1c3BlbmQgYW5kIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG4gICAgICBpZiAoIWluY2x1ZGVzU3luY0xhbmUocm9vdFJlbmRlckxhbmVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIG5vdCBhIHN5bmMgdXBkYXRlLiBTdXNwZW5kLiBTaW5jZSB3ZSdyZSBub3QgYWN0aXZhdGluZyBhXG4gICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGlzIHdpbGwgdW53aW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290IHdpdGhvdXRcbiAgICAgICAgLy8gcGVyZm9ybWluZyBhIHNlY29uZCBwYXNzIHRvIHJlbmRlciBhIGZhbGxiYWNrLiAoVGhpcyBpcyBhcmd1YWJseSBob3dcbiAgICAgICAgLy8gcmVmcmVzaCB0cmFuc2l0aW9ucyBzaG91bGQgd29yaywgdG9vLCBzaW5jZSB3ZSdyZSBub3QgZ29pbmcgdG8gY29tbWl0XG4gICAgICAgIC8vIHRoZSBmYWxsYmFja3MgYW55d2F5LilcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBjYXNlIGFsc28gYXBwbGllcyB0byBpbml0aWFsIGh5ZHJhdGlvbi5cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVGhpcyBpcyBhIHN5bmMvZGlzY3JldGUgdXBkYXRlLiBXZSB0cmVhdCB0aGlzIGNhc2UgbGlrZSBhbiBlcnJvclxuICAgICAgLy8gYmVjYXVzZSBkaXNjcmV0ZSByZW5kZXJzIGFyZSBleHBlY3RlZCB0byBwcm9kdWNlIGEgY29tcGxldGUgdHJlZVxuICAgICAgLy8gc3luY2hyb25vdXNseSB0byBtYWludGFpbiBjb25zaXN0ZW5jeSB3aXRoIGV4dGVybmFsIHN0YXRlLlxuXG5cbiAgICAgIHZhciB1bmNhdWdodFN1c3BlbnNlRXJyb3IgPSBuZXcgRXJyb3IoJ0EgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzICcgKyAnd2lsbCBjYXVzZSB0aGUgVUkgdG8gYmUgcmVwbGFjZWQgd2l0aCBhIGxvYWRpbmcgaW5kaWNhdG9yLiBUbyAnICsgJ2ZpeCwgdXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgJyArICd3aXRoIHN0YXJ0VHJhbnNpdGlvbi4nKTsgLy8gSWYgd2UncmUgb3V0c2lkZSBhIHRyYW5zaXRpb24sIGZhbGwgdGhyb3VnaCB0byB0aGUgcmVndWxhciBlcnJvciBwYXRoLlxuICAgICAgLy8gVGhlIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IHN1c3BlbnNlIGJvdW5kYXJ5LlxuXG4gICAgICB2YWx1ZSA9IHVuY2F1Z2h0U3VzcGVuc2VFcnJvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IsIG5vdCBhIFN1c3BlbnNlIHdha2VhYmxlLlxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIHNvdXJjZUZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgbWFya0RpZFN1c3BlbmRXaGlsZUh5ZHJhdGluZ0RFVigpO1xuXG4gICAgICB2YXIgX3N1c3BlbnNlQm91bmRhcnkgPSBnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZShyZXR1cm5GaWJlcik7IC8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGR1cmluZyBoeWRyYXRpb24sIHdlIG1heSBiZSBhYmxlIHRvIHJlY292ZXIgYnlcbiAgICAgIC8vIGRpc2NhcmRpbmcgdGhlIGRlaHlkcmF0ZWQgY29udGVudCBhbmQgc3dpdGNoaW5nIHRvIGEgY2xpZW50IHJlbmRlci5cbiAgICAgIC8vIEluc3RlYWQgb2Ygc3VyZmFjaW5nIHRoZSBlcnJvciwgZmluZCB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeVxuICAgICAgLy8gYW5kIHJlbmRlciBpdCBhZ2FpbiB3aXRob3V0IGh5ZHJhdGlvbi5cblxuXG4gICAgICBpZiAoX3N1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKChfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmIFNob3VsZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgLy8gU2V0IGEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHdlIHNob3VsZCB0cnkgcmVuZGVyaW5nIHRoZSBub3JtYWxcbiAgICAgICAgICAvLyBjaGlsZHJlbiBhZ2Fpbiwgbm90IHRoZSBmYWxsYmFjay5cbiAgICAgICAgICBfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShfc3VzcGVuc2VCb3VuZGFyeSwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByb290LCByb290UmVuZGVyTGFuZXMpOyAvLyBFdmVuIHRob3VnaCB0aGUgdXNlciBtYXkgbm90IGJlIGFmZmVjdGVkIGJ5IHRoaXMgZXJyb3IsIHdlIHNob3VsZFxuICAgICAgICAvLyBzdGlsbCBsb2cgaXQgc28gaXQgY2FuIGJlIGZpeGVkLlxuXG4gICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG5cbiAgcmVuZGVyRGlkRXJyb3IodmFsdWUpO1xuICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG5cbiAgZG8ge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF9lcnJvckluZm8sIGxhbmUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cbiAgICAgICAgICB2YXIgX2xhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBfbGFuZSk7IC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuXG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgc3VzcGVuZHMuIEl0IHJldHVybnMgdGhlXG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICAvLyBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmU3RhdGljO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhZE5vTXV0YXRpb25zRWZmZWN0cyhjdXJyZW50LCBjb21wbGV0ZWRXb3JrKSB7XG4gIHZhciBkaWRCYWlsb3V0ID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gIGlmIChkaWRCYWlsb3V0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUT0RPOiBJZiB3ZSBtb3ZlIHRoZSBgaGFkTm9NdXRhdGlvbnNFZmZlY3RzYCBjYWxsIGFmdGVyIGBidWJibGVQcm9wZXJ0aWVzYFxuICAvLyB0aGVuIHdlIG9ubHkgaGF2ZSB0byBjaGVjayB0aGUgYGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzYC5cblxuXG4gIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgaWYgKChjaGlsZC5mbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MgfHwgKGNoaWxkLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGFwcGVuZEFsbENoaWxkcmVuO1xudmFyIHVwZGF0ZUhvc3RDb250YWluZXI7XG52YXIgdXBkYXRlSG9zdENvbXBvbmVudDtcbnZhciB1cGRhdGVIb3N0VGV4dDtcblxuaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgLy8gTXV0YXRpb24gbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykgey8vIE5vb3BcbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgLy8gUGVyc2lzdGVudCBob3N0IHRyZWUgbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgcHJvcHMgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHRleHQgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgX2luc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoX2luc3RhbmNlLCB0ZXh0LCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIF9pbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIG5vZGUsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vICRGbG93Rml4TWUgVGhpcyBpcyBjb3JyZWN0IGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBsYWJlbGVkIGJyZWFrLlxuXG5cbiAgICAgIG5vZGUgPSBub2RlO1xuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9OyAvLyBBbiB1bmZvcnR1bmF0ZSBmb3JrIG9mIGFwcGVuZEFsbENoaWxkcmVuIGJlY2F1c2Ugd2UgaGF2ZSB0d28gZGlmZmVyZW50IHBhcmVudCB0eXBlcy5cblxuXG4gIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHByb3BzID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMiA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcbiAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBIaWRlIGl0LlxuICAgICAgICAgIHZhciB0ZXh0ID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIF9pbnN0YW5jZTIgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShfaW5zdGFuY2UyLCB0ZXh0LCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgX2luc3RhbmNlMik7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKGNvbnRhaW5lckNoaWxkU2V0LCBub2RlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgY29ycmVjdCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgbGFiZWxlZCBicmVhay5cblxuXG4gICAgICBub2RlID0gbm9kZTtcblxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHBvcnRhbE9yUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSBoYWROb011dGF0aW9uc0VmZmVjdHMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSA7IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTsgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuXG4gICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDsgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjb250YWluZXIgdG8gc3dhcCBvdXQgdGhlIGNvbnRhaW5lci5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wczsgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuXG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gaGFkTm9NdXRhdGlvbnNFZmZlY3RzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiBvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUocmVjeWNsYWJsZUluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuXG4gICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcblxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7IC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7Ly8gTm9vcFxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb21wb25lbnQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHsvLyBOb29wXG4gIH07XG5cbiAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHsvLyBOb29wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgLy8gSWYgd2UncmUgaHlkcmF0aW5nLCB3ZSBzaG91bGQgY29uc3VtZSBhcyBtYW55IGl0ZW1zIGFzIHdlIGNhblxuICAgIC8vIHNvIHdlIGRvbid0IGxlYXZlIGFueSBiZWhpbmQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAodGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsYXN0VGFpbE5vZGUgPSB0YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAobGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbGxhcHNlZCc6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgX3RhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChfdGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoX3RhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2xhc3RUYWlsTm9kZSA9IF90YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGFpbE5vZGUgPSBfdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChfbGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICBpZiAoIWhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayAmJiByZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBzdXNwZW5kZWQgZHVyaW5nIHRoZSBoZWFkLiBXZSB3YW50IHRvIHNob3cgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgICAvLyByb3cgYXQgdGhlIHRhaWwuIFNvIHdlJ2xsIGtlZXAgb24gYW5kIGN1dCBvZmYgdGhlIHJlc3QuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgX2xhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICB2YXIgZGlkQmFpbG91dCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuXG4gIGlmICghZGlkQmFpbG91dCkge1xuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoY2hpbGQubGFuZXMsIGNoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzOyAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4gICAgICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgICAgIC8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi4gSWZcbiAgICAgICAgLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuICAgICAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLiBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXNcbiAgICAgICAgLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cblxuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLCBfY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZC5mbGFnczsgLy8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuICAgICAgICAvLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbiAgICAgICAgLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5cbiAgICAgICAgX2NoaWxkLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgfSBlbHNlIHtcbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHZhciBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZDIgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQyLmxhbmVzLCBfY2hpbGQyLmNoaWxkTGFuZXMpKTsgLy8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGVtLlxuXG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jaGlsZDMgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkMyAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZDMubGFuZXMsIF9jaGlsZDMuY2hpbGRMYW5lcykpOyAvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbiAgICAgICAgLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaWdub3JlIHRoZW0uXG5cbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuZmxhZ3MgJiBTdGF0aWNNYXNrOyAvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4gICAgICAgIC8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuICAgICAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cblxuICAgICAgICBfY2hpbGQzLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZDMgPSBfY2hpbGQzLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICB9XG5cbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgcmV0dXJuIGRpZEJhaWxvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cblxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG5cbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2NoZWR1bGUgYW4gdXBkYXRlIGZvclxuICAgICAgICAgICAgLy8gdGhlIGNvbW1pdCBzaWRlLWVmZmVjdHMgb24gdGhlIHJvb3QuXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjbGllbnQgcm9vdFxuICAgICAgICAgICAgICAhcHJldlN0YXRlLmlzRGVoeWRyYXRlZCB8fCAvLyBDaGVjayBpZiB3ZSByZXZlcnRlZCB0byBjbGllbnQgcmVuZGVyaW5nIChlLmcuIGR1ZSB0byBhbiBlcnJvcilcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGNsZWFyIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGNvbW1pdC4gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGFcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXIgd2l0aCBwcmV2aW91cyBjaGlsZHJlbi4gSXQncyBhbHNvIHNhZmUgdG8gZG8gZm9yXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGwgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgcmVuZGVyIHdhcyBudWxsIChzbyB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBiZSBlbXB0eSkuXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7IC8vIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsIHRoZXJlIG1heSBoYXZlIGJlZW5cbiAgICAgICAgICAgICAgICAvLyByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvbiBhdHRlbXB0LiBJZiBzbywgYWRkXG4gICAgICAgICAgICAgICAgLy8gdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGUgY29tbWl0IHBoYXNlLlxuXG4gICAgICAgICAgICAgICAgdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBhZGQgdGhlbSB0b3AtPmRvd24gb3JcbiAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWQgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWYgb24gYSBob3N0IG5vZGUgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBoYXNVbmh5ZHJhdGVkVGFpbE5vZGVzKCkgJiYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2Rlcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlciB8IEluY29tcGxldGUgfCBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0U3RhdGUgIT09IG51bGwgJiYgbmV4dFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIGluc2lkZSBhIGh5ZHJhdGlvbiBzdGF0ZSB0aGUgZmlyc3QgdGltZSB3ZSdyZSBwaWNraW5nIHVwIHRoaXNcbiAgICAgICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCBhbmQgYWxzbyBhZnRlciB3ZSd2ZSByZWVudGVyZWQgaXQgZm9yIGZ1cnRoZXIgaHlkcmF0aW9uLlxuICAgICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDMgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICghX3dhc0h5ZHJhdGVkMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudCB3YXMgY29tcGxldGVkIHdpdGhvdXQgYSBoeWRyYXRlZCBub2RlLiAnICsgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHJlZW50ZXJlZCB0aGlzIGJvdW5kYXJ5IHRvIGh5ZHJhdGUgaXQuIElmIHNvLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBoeWRyYXRpb25cbiAgICAgICAgICAgICAgLy8gc3RhdGUgc2luY2Ugd2UncmUgbm93IGV4aXRpbmcgb3V0IG9mIGl0LiBwb3BIeWRyYXRpb25TdGF0ZSBkb2Vzbid0IGRvIHRoYXQgZm9yIHVzLlxuICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBib3VuZGFyeSBkaWQgbm90IHN1c3BlbmQgc28gaXQncyBub3cgaHlkcmF0ZWQgYW5kIHVuc3VzcGVuZGVkLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBtYXJrIHRoaXMgYm91bmRhcnlcbiAgICAgICAgICAgICAgLy8gYXMgaGF2aW5nIGh5ZHJhdGVkIHNvIGV2ZW50cyBrbm93IHRoYXQgdGhleSdyZSBmcmVlIHRvIGJlIGludm9rZWQuXG4gICAgICAgICAgICAgIC8vIEl0J3MgYWxzbyBhIHNpZ25hbCB0byByZXBsYXkgZXZlbnRzIGFuZCB0aGUgc3VzcGVuc2UgY2FsbGJhY2suXG4gICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggcmV0cnkgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSBtaWdodCBhcyB3ZWxsIGFsd2F5cyBtYXJrIHRoaXMuXG5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9pc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChfaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9wcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBfcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB0aGlzIHRyZWUuIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsXG4gICAgICAgICAgLy8gdGhlcmUgbWF5IGhhdmUgYmVlbiByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvblxuICAgICAgICAgIC8vIGF0dGVtcHQuIElmIHNvLCBhZGQgdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuXG5cblxuICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLiBSZS1yZW5kZXIgd2l0aCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lczsgLy8gRG8gbm90IHJlc2V0IHRoZSBlZmZlY3QgbGlzdC5cblxuICAgICAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcHJldkRpZFRpbWVvdXQgPSBfcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuIGVmZmVjdCB0byB0b2dnbGUgdGhlIHN1YnRyZWUncyB2aXNpYmlsaXR5LiBXaGVuIHdlIHN3aXRjaCBmcm9tXG4gICAgICAgIC8vIGZhbGxiYWNrIC0+IHByaW1hcnksIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgc2NoZWR1bGVzIHRoaXMgZWZmZWN0XG4gICAgICAgIC8vIGFzIHBhcnQgb2YgaXRzIG5vcm1hbCBjb21wbGV0ZSBwaGFzZS4gQnV0IHdoZW4gd2Ugc3dpdGNoIGZyb21cbiAgICAgICAgLy8gcHJpbWFyeSAtPiBmYWxsYmFjaywgdGhlIGlubmVyIE9mZnNjcmVlbiBmaWJlciBkb2VzIG5vdCBoYXZlIGEgY29tcGxldGVcbiAgICAgICAgLy8gcGhhc2UuIFNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgaXRzIGVmZmVjdCBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBhbHNvIHVzZSB0aGlzIGZsYWcgdG8gY29ubmVjdC9kaXNjb25uZWN0IHRoZSBlZmZlY3RzLCBidXQgdGhlIHNhbWVcbiAgICAgICAgLy8gbG9naWMgYXBwbGllczogd2hlbiByZS1jb25uZWN0aW5nLCB0aGUgT2Zmc2NyZWVuIGZpYmVyJ3MgY29tcGxldGVcbiAgICAgICAgLy8gcGhhc2Ugd2lsbCBoYW5kbGUgc2NoZWR1bGluZyB0aGUgZWZmZWN0LiBJdCdzIG9ubHkgd2hlbiB0aGUgZmFsbGJhY2tcbiAgICAgICAgLy8gaXMgYWN0aXZlIHRoYXQgd2UgaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsLlxuXG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICYmICFwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgIHZhciBfb2Zmc2NyZWVuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBfb2Zmc2NyZWVuRmliZXIuZmxhZ3MgfD0gVmlzaWJpbGl0eTsgLy8gVE9ETzogVGhpcyB3aWxsIHN0aWxsIHN1c3BlbmQgYSBzeW5jaHJvbm91cyB0cmVlIGlmIGFueXRoaW5nXG4gICAgICAgICAgLy8gaW4gdGhlIGNvbmN1cnJlbnQgdHJlZSBhbHJlYWR5IHN1c3BlbmRlZCBkdXJpbmcgdGhpcyByZW5kZXIuXG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGtub3duIGJ1Zy5cblxuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYmFjayB0byB0aHJvd0V4Y2VwdGlvbiBiZWNhdXNlIHRoaXMgaXMgdG9vIGxhdGVcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2VcbiAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuICAgICAgICAgICAgLy8gdGhpcyBtYXJrZXIsIGFuZCB0aGlzIGlzIHRvbyBsYXRlLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBpbW1lZGlhdGVseSByZXN0YXJ0IGZyb20gd2l0aGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgICAgICAgdmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCA9IGN1cnJlbnQgPT09IG51bGwgJiYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUgfHwgIWVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2spO1xuXG4gICAgICAgICAgICBpZiAoaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0IHx8IGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgaW4gYW4gaW52aXNpYmxlIHRyZWUgb3IgYSBuZXcgcmVuZGVyLCB0aGVuIHNob3dpbmdcbiAgICAgICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBpcyBvay5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIGhpZGUgY29udGVudCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZCBmb3IgbG9uZ2VyIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdha2VhYmxlcyA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh3YWtlYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gYXR0YWNoIGEgcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuXG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgaWYgKF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gU2FtZSBhcyBjbGFzcyBjb21wb25lbnQgY2FzZS4gSSBwdXQgaXQgZG93biBoZXJlIHNvIHRoYXQgdGhlIHRhZ3MgYXJlXG4gICAgICAgIC8vIHNlcXVlbnRpYWwgdG8gZW5zdXJlIHRoaXMgc3dpdGNoIGlzIGNvbXBpbGVkIHRvIGEganVtcCB0YWJsZS5cbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiB0aGUgZGVmYXVsdCwgXCJpbmRlcGVuZGVudFwiIG1vZGUuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZFN1c3BlbmRBbHJlYWR5ID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG4gICAgICAgIHZhciByZW5kZXJlZFRhaWwgPSByZW5kZXJTdGF0ZS5yZW5kZXJpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4gICAgICAgICAgICAvLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3JcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbiAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbm5vdEJlU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBJZiB0aGlzIGlzIGEgbmV3bHkgc3VzcGVuZGVkIHRyZWUsIGl0IG1pZ2h0IG5vdCBnZXQgY29tbWl0dGVkIGFzXG4gICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGl0cyB0aGVuYWJsZXMuIEluc3RlYWQsIHdlJ2xsIHRyYW5zZmVyIGl0cyB0aGVuYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VGhlbmFibGVzID0gc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3VGhlbmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbmV3VGhlbmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJlZm9yZSBkb2luZyB0aGUgc2Vjb25kIHBhc3Mgc2luY2UgdGhhdCdzIG5vdyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTsgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwgJiYgbm93JDEoKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuICAgICAgICAgICAgICAvLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICB9IC8vIE5leHQgd2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZSB0YWlsLlxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSByZW5kZXJlZCByb3cgdG8gdGhlIGNoaWxkIGxpc3QuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgdmFyIF9zdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocmVuZGVyZWRUYWlsKTtcblxuICAgICAgICAgICAgaWYgKF9zdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlOyAvLyBFbnN1cmUgd2UgdHJhbnNmZXIgdGhlIHVwZGF0ZSBxdWV1ZSB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBnZXQgbG9zdCBpZiB0aGlzIHJvdyBlbmRzIHVwIGRyb3BwZWQgZHVyaW5nIGEgc2Vjb25kIHBhc3MuXG5cbiAgICAgICAgICAgICAgdmFyIF9uZXdUaGVuYWJsZXMgPSBfc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgIGlmIChfbmV3VGhlbmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfbmV3VGhlbmFibGVzO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgdHJ1ZSk7IC8vIFRoaXMgbWlnaHQgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuXG4gICAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsID09PSBudWxsICYmIHJlbmRlclN0YXRlLnRhaWxNb2RlID09PSAnaGlkZGVuJyAmJiAhcmVuZGVyZWRUYWlsLmFsdGVybmF0ZSAmJiAhZ2V0SXNIeWRyYXRpbmcoKSAvLyBXZSBkb24ndCBjdXQgaXQgaWYgd2UncmUgaHlkcmF0aW5nLlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuICAgICAgICAgICAgLy8gZXhjZWVkIGl0LlxuICAgICAgICAgICAgbm93JDEoKSAqIDIgLSByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkgJiYgcmVuZGVyTGFuZXMgIT09IE9mZnNjcmVlbkxhbmUpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG4gICAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBpcyB1c3VhbGx5IGZhc3Rlci5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBvZiB0aGUgYmFja3dhcmRzIHRhaWwgd2lsbCBoYXZlIGJlZW4gYWRkZWRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBlbmQuIFRoaXMgYnJlYWtzIHRoZSBndWFyYW50ZWUgdGhhdCBsaWZlLWN5Y2xlcyBmaXJlIGluXG4gICAgICAgICAgICAvLyBzaWJsaW5nIG9yZGVyIGJ1dCB0aGF0IGlzbid0IGEgc3Ryb25nIGd1YXJhbnRlZSBwcm9taXNlZCBieSBSZWFjdC5cbiAgICAgICAgICAgIC8vIEVzcGVjaWFsbHkgc2luY2UgdGhlc2UgbWlnaHQgYWxzbyBqdXN0IHBvcCBpbiBkdXJpbmcgZnV0dXJlIGNvbW1pdHMuXG4gICAgICAgICAgICAvLyBBcHBlbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJlbmRlcmVkVGFpbC5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHJlbmRlclN0YXRlLmxhc3Q7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyU3RhdGUubGFzdCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIHN0aWxsIGhhdmUgdGFpbCByb3dzIHRvIHJlbmRlci5cbiAgICAgICAgICAvLyBQb3AgYSByb3cuXG4gICAgICAgICAgdmFyIG5leHQgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG5leHQ7XG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG5leHQuc2libGluZztcbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3ckMSgpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIG5leHRJc0hpZGRlbiA9IF9uZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX3ByZXZTdGF0ZTIgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUyICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuICYmICggLy8gTGVnYWN5SGlkZGVuIGRvZXNuJ3QgZG8gYW55IGhpZGluZyDigJQgaXQgb25seSBwcmUtcmVuZGVycy5cbiAgICAgICAgICAhZW5hYmxlTGVnYWN5SGlkZGVuICkpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXh0SXNIaWRkZW4gfHwgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGZvciBoaWRkZW4gY2hpbGRyZW4gdW5sZXNzIHdlJ3JlIHJlbmRlcmluZ1xuICAgICAgICAgIC8vIGF0IG9mZnNjcmVlbiBwcmlvcml0eS5cbiAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGFuIGluc2VydGlvbiBvciB1cGRhdGUgaW4gdGhlIGhpZGRlbiBzdWJ0cmVlLlxuICAgICAgICAgICAgICAvLyBJZiBzbywgd2UgbmVlZCB0byBoaWRlIHRob3NlIG5vZGVzIGluIHRoZSBjb21taXQgcGhhc2UsIHNvXG4gICAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgdmlzaWJpbGl0eSBlZmZlY3QuXG4gICAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHZhciBoYXNJZDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhDb21wb25lbnQudHlwZSwgbnVsbCwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MubW9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIGNoaWxkLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBjaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNoaWxkO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHtcbiAgICB2YXIgX3R5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICB2YXIgX2lubmVyUHJvcFR5cGVzID0gX3R5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKF9pbm5lclByb3BUeXBlcykge1xuICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICBjaGVja1Byb3BUeXBlcyhfaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBvdXRlck1lbW9UeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG5cbiAgICAgIGlmIChvdXRlck1lbW9UeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgLy8gV2Ugd2FybiB3aGVuIHlvdSBkZWZpbmUgcHJvcFR5cGVzIG9uIGxhenkoKVxuICAgICAgICAvLyBzbyBsZXQncyBqdXN0IHNraXAgb3ZlciBpdCB0byBmaW5kIG1lbW8oKSBvdXRlciB3cmFwcGVyLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBmb3IgbWVtbyBhcmUgdmFsaWRhdGVkIGxhdGVyLlxuICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IG91dGVyTWVtb1R5cGU7XG4gICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gbnVsbDtcbiAgICAgICAgfSAvLyBJbm5lciBwcm9wVHlwZXMgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBwYXRoLlxuXG5cbiAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gb3V0ZXJNZW1vVHlwZSAmJiBvdXRlck1lbW9UeXBlLnByb3BUeXBlcztcblxuICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCAoU2ltcGxlTWVtb0NvbXBvbmVudCBoYXMgbm8gZGVmYXVsdFByb3BzKVxuICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtdWxhdGVkIGR1cmluZyB0aGUgZXZhbHVhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IChpLmUuIHdoZW4gcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlKS4gQnV0IHNpbmNlIHNpbmNlXG4gICAgICAgIC8vIHdlJ3JlIGJhaWxpbmcgb3V0IGVhcmx5ICp3aXRob3V0KiBldmFsdWF0aW5nIHRoZSBjb21wb25lbnQsIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYWNjb3VudCBmb3IgaXQgaGVyZSwgdG9vLiBSZXNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgZmliZXIuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgb25seSBhcHBsaWVzIHRvIFNpbXBsZU1lbW9Db21wb25lbnQsIG5vdCBNZW1vQ29tcG9uZW50LFxuICAgICAgICAvLyBiZWNhdXNlIGEgTWVtb0NvbXBvbmVudCBmaWJlciBkb2VzIG5vdCBoYXZlIGhvb2tzIG9yIGFuIHVwZGF0ZSBxdWV1ZTtcbiAgICAgICAgLy8gcmF0aGVyLCBpdCB3cmFwcyBhcm91bmQgYW4gaW5uZXIgY29tcG9uZW50LCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICAgICAgICAvLyBjb250YWlucyBob29rcy5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGUgcmVzZXQgYXQgaW4gYmVnaW5Xb3JrIG91dCBvZiB0aGUgY29tbW9uIHBhdGggc28gdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJldlN0YXRlID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG5cbiAgaWYgKG5leHRQcm9wcy5tb2RlID09PSAnaGlkZGVuJyB8fCBlbmFibGVMZWdhY3lIaWRkZW4gKSB7XG4gICAgLy8gUmVuZGVyaW5nIGEgaGlkZGVuIHRyZWUuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIGxlZ2FjeSBzeW5jIG1vZGUsIGRvbid0IGRlZmVyIHRoZSBzdWJ0cmVlLiBSZW5kZXIgaXQgbm93LlxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IG51bGxcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2UgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSkge1xuICAgICAgdmFyIHNwYXduZWRDYWNoZVBvb2wgPSBudWxsOyAvLyBXZSdyZSBoaWRkZW4sIGFuZCB3ZSdyZSBub3QgcmVuZGVyaW5nIGF0IE9mZnNjcmVlbi4gV2Ugd2lsbCBiYWlsIG91dFxuICAgICAgLy8gYW5kIHJlc3VtZSB0aGlzIHRyZWUgbGF0ZXIuXG5cbiAgICAgIHZhciBuZXh0QmFzZUxhbmVzO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2QmFzZUxhbmVzID0gcHJldlN0YXRlLmJhc2VMYW5lcztcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IG1lcmdlTGFuZXMocHJldkJhc2VMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgICAgfSAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cblxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTtcbiAgICAgIHZhciBfbmV4dFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogc3Bhd25lZENhY2hlUG9vbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgLy8gdG8gYXZvaWQgYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5cblxuICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBuZXh0QmFzZUxhbmVzKTtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIuIFRoZSBzdXJyb3VuZGluZyB2aXNpYmxlIGNvbnRlbnQgaGFzIGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gTm93IHdlIHJlc3VtZSByZW5kZXJpbmcgdGhlIGhpZGRlbiB0cmVlLlxuICAgICAgLy8gUmVuZGVyaW5nIGF0IG9mZnNjcmVlbiwgc28gd2UgY2FuIGNsZWFyIHRoZSBiYXNlIGxhbmVzLlxuICAgICAgdmFyIF9uZXh0U3RhdGUyID0ge1xuICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogbnVsbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlMjsgLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG4gICAgICB2YXIgc3VidHJlZVJlbmRlckxhbmVzID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmJhc2VMYW5lcyA6IHJlbmRlckxhbmVzO1xuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlcmluZyBhIHZpc2libGUgdHJlZS5cbiAgICB2YXIgX3N1YnRyZWVSZW5kZXJMYW5lcztcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcyk7XG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHdlcmVuJ3QgcHJldmlvdXNseSBoaWRkZW4sIGFuZCB3ZSBzdGlsbCBhcmVuJ3QsIHNvIHRoZXJlJ3Mgbm90aGluZ1xuICAgICAgLy8gc3BlY2lhbCB0byBkby4gTmVlZCB0byBwdXNoIHRvIHRoZSBzdGFjayByZWdhcmRsZXNzLCB0aG91Z2gsIHRvIGF2b2lkXG4gICAgICAvLyBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cbiAgICAgIF9zdWJ0cmVlUmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICB9XG5cbiAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIF9zdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICB9XG5cbiAge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG5cbiAgICB7XG4gICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1JlZiQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcblxuICAgIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZlN0YXRpYztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgdmFyIGhhc0lkO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIGVycm9yLlxuICAgIHN3aXRjaCAoc2hvdWxkRXJyb3Iod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7IC8vIFRPRE8gVGhpcyB3YXkgb2YgcmVzZXR0aW5nIHRoZSBlcnJvciBib3VuZGFyeSBzdGF0ZSBpcyBhIGhhY2suXG4gICAgICAgICAgLy8gSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXM/XG5cbiAgICAgICAgICB2YXIgdGVtcEluc3RhbmNlID0gbmV3IGN0b3Iod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcywgX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRlbXBJbnN0YW5jZS5zdGF0ZTtcblxuICAgICAgICAgIF9pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShfaW5zdGFuY2UsIHN0YXRlLCBudWxsKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblxuICAgICAgICAgIHZhciBlcnJvciQxID0gbmV3IEVycm9yKCdTaW11bGF0ZWQgZXJyb3IgY29taW5nIGZyb20gRGV2VG9vbHMnKTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yJDEsIHdvcmtJblByb2dyZXNzKSwgbGFuZSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCB1cGRhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlO1xuXG4gIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGNsYXNzIGNvbXBvbmVudCB3aXRob3V0IGFuIGluc3RhbmNlIG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZFxuICAgICAgLy8gaW5zaWRlIGEgbm9uLWNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvXG4gICAgICAvLyB0cmVhdCBpdCBsaWtlIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gICAgfSAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cblxuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUgJiYgaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ2EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0VW5pdE9mV29yaztcbn1cblxuZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcykge1xuICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICBtYXJrUmVmJDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlOyAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cblxuICBpZiAoaGFzQ29udGV4dCkge1xuICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gIH1cblxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZS5lbGVtZW50O1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uICYmIHByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAvLyBUaGlzIGlzIGEgaHlkcmF0aW9uIHJvb3Qgd2hvc2Ugc2hlbGwgaGFzIG5vdCB5ZXQgaHlkcmF0ZWQuIFdlIHNob3VsZFxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZS5cbiAgICAvLyBGbGlwIGlzRGVoeWRyYXRlZCB0byBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gdGhpcyByZW5kZXJcbiAgICAvLyBmaW5pc2hlcywgdGhlIHJvb3Qgd2lsbCBubyBsb25nZXIgYmUgZGVoeWRyYXRlZC5cbiAgICB2YXIgb3ZlcnJpZGVTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IG5leHRDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogZmFsc2UsXG4gICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlLFxuICAgICAgdHJhbnNpdGlvbnM6IG5leHRTdGF0ZS50cmFuc2l0aW9uc1xuICAgIH07XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIGBiYXNlU3RhdGVgIGNhbiBhbHdheXMgYmUgdGhlIGxhc3Qgc3RhdGUgYmVjYXVzZSB0aGUgcm9vdCBkb2Vzbid0XG4gICAgLy8gaGF2ZSByZWR1Y2VyIGZ1bmN0aW9ucyBzbyBpdCBkb2Vzbid0IG5lZWQgcmViYXNpbmcuXG5cbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBhIHByZXZpb3VzIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgc2hlbGwsIHNvIHdlXG4gICAgICAvLyBmb3JjZWQgYSBjbGllbnQgcmVuZGVyLlxuICAgICAgdmFyIHJlY292ZXJhYmxlRXJyb3IgPSBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcuIEJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbmVkIG91dHNpZGUgJyArICdvZiBhIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGUgZW50aXJlIHJvb3Qgd2lsbCBzd2l0Y2ggdG8gJyArICdjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgICAgcmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzLCByZWNvdmVyYWJsZUVycm9yKTtcbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPT0gcHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIgX3JlY292ZXJhYmxlRXJyb3IgPSBuZXcgRXJyb3IoJ1RoaXMgcm9vdCByZWNlaXZlZCBhbiBlYXJseSB1cGRhdGUsIGJlZm9yZSBhbnl0aGluZyB3YXMgYWJsZSAnICsgJ2h5ZHJhdGUuIFN3aXRjaGVkIHRoZSBlbnRpcmUgcm9vdCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuXG4gICAgICByZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMsIF9yZWNvdmVyYWJsZUVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG91dGVybW9zdCBzaGVsbCBoYXMgbm90IGh5ZHJhdGVkIHlldC4gU3RhcnQgaHlkcmF0aW5nLlxuICAgICAgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHZhciBjaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICAgIHZhciBub2RlID0gY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIC8vIE1hcmsgZWFjaCBjaGlsZCBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAgICAgLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuICAgICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgICAgIC8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuICAgICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgJiB+UGxhY2VtZW50IHwgSHlkcmF0aW5nO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSb290IGlzIG5vdCBkZWh5ZHJhdGVkLiBFaXRoZXIgdGhpcyBpcyBhIGNsaWVudC1vbmx5IHJvb3QsIG9yIGl0XG4gICAgLy8gYWxyZWFkeSBoeWRyYXRlZC5cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcywgcmVjb3ZlcmFibGVFcnJvcikge1xuICAvLyBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cbiAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhcyBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcyAhPT0gbnVsbCAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQSBsYXp5IGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBsYXp5Q29tcG9uZW50ID0gZWxlbWVudFR5cGU7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTsgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG5cbiAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudDtcbiAgdmFyIHJlc29sdmVkVGFnID0gd29ya0luUHJvZ3Jlc3MudGFnID0gcmVzb2x2ZUxhenlDb21wb25lbnRUYWcoQ29tcG9uZW50KTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICB2YXIgY2hpbGQ7XG5cbiAgc3dpdGNoIChyZXNvbHZlZFRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUZvcndhcmRSZWYobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgcmVzb2x2ZWRQcm9wcywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVNZW1vQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LnR5cGUsIHJlc29sdmVkUHJvcHMpLCAvLyBUaGUgaW5uZXIgdHlwZSBjYW4gaGF2ZSBkZWZhdWx0cyB0b29cbiAgICAgICAgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gIH1cblxuICB2YXIgaGludCA9ICcnO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgfVxuICB9IC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgLy8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW5cbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiBcIiArIENvbXBvbmVudCArIFwiLiBcIiArIChcIkxhenkgZWxlbWVudCB0eXBlIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLlwiICsgaGludCkpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBpbmNvbXBsZXRlIGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH0gLy8gUHJvbW90ZSB0aGUgZmliZXIgdG8gYSBjbGFzcyBhbmQgdHJ5IHJlbmRlcmluZyBhZ2Fpbi5cblxuXG4gIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50OyAvLyBUaGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgZm9yayBvZiBgdXBkYXRlQ2xhc3NDb21wb25lbnRgXG4gIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgY29udGV4dDtcblxuICB7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBmYWxzZSk7XG4gICAgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciBoYXNJZDtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG5cblxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50OyAvLyBUaHJvdyBvdXQgYW55IGhvb2tzIHRoYXQgd2VyZSB1c2VkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsOyAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cbiAgICB2YXIgaGFzQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gdmFsdWUuc3RhdGUgIT09IG51bGwgJiYgdmFsdWUuc3RhdGUgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnN0YXRlIDogbnVsbDtcbiAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGdW5jdGlvbkNvbXBvbmVudDtcblxuICAgIHtcblxuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihudWxsLCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUsIHJlbmRlckxhbmVzKTtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAge1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIGlmIChDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuXG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cblxuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgJyc7XG4gICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG5cbiAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHVzZSBSZWFjdC5mb3J3YXJkUmVmKCk/JXMnLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgdHJlZUNvbnRleHQ6IG51bGwsXG4gIHJldHJ5TGFuZTogTm9MYW5lXG59O1xuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLFxuICAgIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNhY2hlUG9vbCA9IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IG1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpLFxuICAgIGNhY2hlUG9vbDogY2FjaGVQb29sXG4gIH07XG59IC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCBpbmxpbmUgdGhpcyBiYWNrXG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG9cbiAgLy8gcmVtYWluIG9uIHRoYXQgZmFsbGJhY2sgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb250ZW50IGhhcyByZXNvbHZlZC5cbiAgLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgcmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxuICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuICAgICAgLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbiAgICAgIC8vIEF2b2lkZWQgYm91bmRhcmllcyBhcmUgbm90IGNvbnNpZGVyZWQgc2luY2UgdGhleSBjYW5ub3QgaGFuZGxlIHByZWZlcnJlZCBmYWxsYmFjayBzdGF0ZXMuXG4gICAgICB7XG4gICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7IC8vIE9LLCB0aGUgbmV4dCBwYXJ0IGlzIGNvbmZ1c2luZy4gV2UncmUgYWJvdXQgdG8gcmVjb25jaWxlIHRoZSBTdXNwZW5zZVxuICAvLyBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGlzIGludm9sdmVzIHNvbWUgY3VzdG9tIHJlY29uY2lsaWF0aW9uIGxvZ2ljLiBUd29cbiAgLy8gbWFpbiByZWFzb25zIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQuXG4gIC8vXG4gIC8vIEZpcnN0LCBMZWdhY3kgTW9kZSBoYXMgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZVxuICAvLyBwcmltYXJ5IHRyZWUgd2lsbCBjb21taXQgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLCBzbyB3aGVuIHdlIGRvIHRoZVxuICAvLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG4gIC8vIGhhY2tzIHRvIG1ha2UgdGhhdCBub3QgdG90YWxseSBicmVhay4gTGlrZSB0cmFuc2ZlcnJpbmcgZWZmZWN0cyBhbmRcbiAgLy8gZGVsZXRpb25zIGZyb20gaGlkZGVuIHRyZWUuIEluIENvbmN1cnJlbnQgTW9kZSwgaXQncyBtdWNoIHNpbXBsZXIsXG4gIC8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcbiAgLy8gc3RhdGUsIG5vIGVmZmVjdHMuIFNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgT2Zmc2NyZWVuIChleGNlcHQgdGhhdFxuICAvLyBPZmZzY3JlZW4gZG9lc24ndCBoYXZlIHRoZSBmaXJzdCByZW5kZXIgcGFzcykuXG4gIC8vXG4gIC8vIFNlY29uZCBpcyBoeWRyYXRpb24uIER1cmluZyBoeWRyYXRpb24sIHRoZSBTdXNwZW5zZSBmaWJlciBoYXMgYSBzbGlnaHRseVxuICAvLyBkaWZmZXJlbnQgbGF5b3V0LCB3aGVyZSB0aGUgY2hpbGQgcG9pbnRzIHRvIGEgZGVoeWRyYXRlZCBmcmFnbWVudCwgd2hpY2hcbiAgLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuICAvL1xuICAvLyBUaGlyZCwgZXZlbiBpZiB5b3Ugc2V0IGFsbCB0aGF0IGFzaWRlLCBTdXNwZW5zZSBpcyBsaWtlIGVycm9yIGJvdW5kYXJpZXMgaW5cbiAgLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG4gIC8vIGFuZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHJlZS4gTGlrZSBhIHRyeS9jYXRjaCBibG9jay4gU28gd2UgaGF2ZSB0byB0cmFja1xuICAvLyB3aGljaCBicmFuY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZy4gSWRlYWxseSB3ZSB3b3VsZCBtb2RlbCB0aGlzIHVzaW5nXG4gIC8vIGEgc3RhY2suXG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgY291bGQndmUgYmVlbiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuXG4gICAge1xuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVoeWRyYXRlZCA9IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcywgZGVoeWRyYXRlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICB2YXIgZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrRnJhZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgZmliZXIgaGFzIGEgU3VzcGVuc2VTdGF0ZSwgdGhhdCBtZWFucyBpdCdzIGFscmVhZHkgc2hvd2luZ1xuICAgIC8vIGEgZmFsbGJhY2suXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2tcbiAgICAgIC8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG4gICAgICB7XG4gICAgICAgIHZhciBfZGVoeWRyYXRlZCA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChfZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZGlkU3VzcGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX2RlaHlkcmF0ZWQsIHByZXZTdGF0ZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVHJ5IGFnYWluIHdpdGhvdXQgaHlkcmF0aW5nLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkZvcmNlQ2xpZW50UmVuZGVyO1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIHRoaXMgU3VzcGVuc2UgYm91bmRhcnkuICcgKyAnU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy4nKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFuZCB3ZSBzaG91bGQgc3RpbGwgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgICAgICAgLy8gTGVhdmUgdGhlIGV4aXN0aW5nIGNoaWxkIGluIHBsYWNlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBUaGUgZGVoeWRyYXRlZCBjb21wbGV0aW9uIHBhc3MgZXhwZWN0cyB0aGlzIGZsYWcgdG8gYmUgdGhlcmVcbiAgICAgICAgICAgIC8vIGJ1dCB0aGUgbm9ybWFsIHN1c3BlbnNlIHBhc3MgZG9lc24ndC5cblxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdXNwZW5kZWQgYnV0IHdlIHNob3VsZCBubyBsb25nZXIgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5vdyBoYXZlIHRvIHJlbmRlciB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbiwgX25leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MiA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuMiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4yLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICAvLyBUaW1lZCBvdXQuXG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW40ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW40LCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIF9wcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUubWVtb2l6ZWRTdGF0ZSA9IF9wcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShfcHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTsgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICByZXR1cm4gX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBoYXZlbid0IHRpbWVkIG91dC4gQ29udGludWUgcmVuZGVyaW5nIHRoZSBjaGlsZHJlbiwgbGlrZSB3ZVxuICAgICAgICAvLyBub3JtYWxseSBkby5cbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NiA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjUsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDY7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlKTtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKChtb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIC8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBjb21taXQgdGhlIHByaW1hcnkgdHJlZSBhcyBpZiBpdCBzdWNjZXNzZnVsbHlcbiAgICAvLyBjb21wbGV0ZWQsIGV2ZW4gdGhvdWdoIGl0J3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLlxuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbiAgICAgIC8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4gICAgICAvLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlKTtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIH1cblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlXG4gIC8vIHRoaXMgd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIE5vTGFuZXMsIG51bGwpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKSB7XG4gIC8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlV29ya0luUHJvZ3Jlc3NgIGlzIGBhbnlgIHR5cGVkLCBzbyB3ZSB1c2UgdGhpc1xuICAvLyB3cmFwcGVyIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiBpdC5cbiAgcmV0dXJuIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfSk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBudWxsO1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuICAgIHZhciBkZWxldGlvbnMgPSB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM7XG5cbiAgICBpZiAoZGVsZXRpb25zID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBbY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudF07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDaGlsZERlbGV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGlvbnMucHVzaChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50KTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKCAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gIChtb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgLy8gTWFrZSBzdXJlIHdlJ3JlIG9uIHRoZSBzZWNvbmQgcGFzcywgaS5lLiB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCB3YXNcbiAgLy8gYWxyZWFkeSBjbG9uZWQuIEluIGxlZ2FjeSBtb2RlLCB0aGUgb25seSBjYXNlIHdoZXJlIHRoaXMgaXNuJ3QgdHJ1ZSBpc1xuICAvLyB3aGVuIERldlRvb2xzIGZvcmNlcyB1cyB0byBkaXNwbGF5IGEgZmFsbGJhY2s7IHdlIHNraXAgdGhlIGZpcnN0IHJlbmRlclxuICAvLyBwYXNzIGVudGlyZWx5IGFuZCBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgdGhlIGZhbGxiYWNrLiAoSW4gQ29uY3VycmVudFxuICAvLyBNb2RlLCBTdXNwZW5zZUxpc3QgY2FuIGFsc28gdHJpZ2dlciB0aGlzIHNjZW5hcmlvLCBidXQgdGhpcyBpcyBhIGxlZ2FjeS1cbiAgLy8gb25seSBjb2RlcGF0aC4pXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQpIHtcbiAgICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbiAgICAgIC8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4gICAgICAvLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG4gICAgLy8gSG93ZXZlciwgc2luY2Ugd2UncmUgZ29pbmcgdG8gcmVtYWluIG9uIHRoZSBmYWxsYmFjaywgd2Ugbm8gbG9uZ2VyIHdhbnRcbiAgICAvLyB0byBkZWxldGUgaXQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwgcHJpbWFyeUNoaWxkUHJvcHMpO1xuICAgIC8vIChXZSBkb24ndCBkbyB0aGlzIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGluIGxlZ2FjeSBtb2RlIHdlIGRvbid0IHJlLXVzZVxuICAgIC8vIHRoZSBjdXJyZW50IHRyZWU7IHNlZSBwcmV2aW91cyBicmFuY2guKVxuXG5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3MgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LCBmYWxsYmFja0NoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAgIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCByZWNvdmVyYWJsZUVycm9yKSB7XG4gIC8vIEZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLiBCZWNhdXNlIHRoaXMgaGFzIHBlcmZvcm1hbmNlXG4gIC8vIGltcGxpY2F0aW9ucywgaXQncyBjb25zaWRlcmVkIGEgcmVjb3ZlcmFibGUgZXJyb3IsIGV2ZW4gdGhvdWdoIHRoZSB1c2VyXG4gIC8vIGxpa2VseSB3b24ndCBvYnNlcnZlIGFueXRoaW5nIHdyb25nIHdpdGggdGhlIFVJLlxuICAvL1xuICAvLyBUaGUgZXJyb3IgaXMgcGFzc2VkIGluIGFzIGFuIGFyZ3VtZW50IHRvIGVuZm9yY2UgdGhhdCBldmVyeSBjYWxsZXIgcHJvdmlkZVxuICAvLyBhIGN1c3RvbSBtZXNzYWdlLCBvciBleHBsaWNpdGx5IG9wdCBvdXQgKGN1cnJlbnRseSB0aGUgb25seSBwYXRoIHRoYXQgb3B0c1xuICAvLyBvdXQgaXMgbGVnYWN5IG1vZGU7IGV2ZXJ5IGNvbmN1cnJlbnQgcGF0aCBwcm92aWRlcyBhbiBlcnJvcikuXG4gIGlmIChyZWNvdmVyYWJsZUVycm9yICE9PSBudWxsKSB7XG4gICAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcbiAgfSAvLyBUaGlzIHdpbGwgYWRkIHRoZSBvbGQgZmliZXIgdG8gdGhlIGRlbGV0aW9uIGxpc3RcblxuXG4gIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7IC8vIFdlJ3JlIG5vdyBub3Qgc3VzcGVuZGVkIG5vciBkZWh5ZHJhdGVkLlxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbik7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGZpYmVyTW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsIGZpYmVyTW9kZSk7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBmaWJlck1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5KSBhbHJlYWR5IG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSkge1xuICAgIC8vIFdlIHdpbGwgaGF2ZSBkcm9wcGVkIHRoZSBlZmZlY3QgbGlzdCB3aGljaCBjb250YWlucyB0aGVcbiAgICAvLyBkZWxldGlvbi4gV2UgbmVlZCB0byByZWNvbmNpbGUgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VJbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gRHVyaW5nIHRoZSBmaXJzdCBwYXNzLCB3ZSdsbCBiYWlsIG91dCBhbmQgbm90IGRyaWxsIGludG8gdGhlIGNoaWxkcmVuLlxuICAvLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB0aGUgY29udGVudCBpbiBwbGFjZSBhbmQgdHJ5IHRvIGh5ZHJhdGUgaXQgbGF0ZXIuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ0Nhbm5vdCBoeWRyYXRlIFN1c3BlbnNlIGluIGxlZ2FjeSBtb2RlLiBTd2l0Y2ggZnJvbSAnICsgJ1JlYWN0RE9NLmh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyKSB0byAnICsgJ1JlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGNvbnRhaW5lciwgPEFwcCAvPiknICsgJy5yZW5kZXIoZWxlbWVudCkgb3IgcmVtb3ZlIHRoZSBTdXNwZW5zZSBjb21wb25lbnRzIGZyb20gJyArICd0aGUgc2VydmVyIHJlbmRlcmVkIGNvbXBvbmVudHMuJyk7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhTeW5jTGFuZSk7XG4gIH0gZWxzZSBpZiAoaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAvLyBUaGlzIGlzIGEgY2xpZW50LW9ubHkgYm91bmRhcnkuIFNpbmNlIHdlIHdvbid0IGdldCBhbnkgY29udGVudCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAvLyBmb3IgdGhpcywgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGF0IGF0IGEgaGlnaGVyIHByaW9yaXR5IGJhc2VkIG9uIHdoZW4gaXQgd291bGRcbiAgICAvLyBoYXZlIHRpbWVkIG91dC4gSW4gdGhlb3J5IHdlIGNvdWxkIHJlbmRlciBpdCBpbiB0aGlzIHBhc3MgYnV0IGl0IHdvdWxkIGhhdmUgdGhlXG4gICAgLy8gd3JvbmcgcHJpb3JpdHkgYXNzb2NpYXRlZCB3aXRoIGl0IGFuZCB3aWxsIHByZXZlbnQgaHlkcmF0aW9uIG9mIHBhcmVudCBwYXRoLlxuICAgIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHdvcmsgbGVmdCBvbiBpdCB0byByZW5kZXIgaXQgaW4gYSBzZXBhcmF0ZSBjb21taXQuXG4gICAgLy8gVE9ETyBUaGlzIHRpbWUgc2hvdWxkIGJlIHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgcmVzcG9uc2UgdGhhdCBpc1xuICAgIC8vIGEgcGFyZW50IHRvIHRoaXMgYm91bmRhcnkgd2FzIGRpc3BsYXllZC4gSG93ZXZlciwgc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IGhhdmVcbiAgICAvLyBhIHByb3RvY29sIHRvIHRyYW5zZmVyIHRoYXQgdGltZSwgd2UnbGwganVzdCBlc3RpbWF0ZSBpdCBieSB1c2luZyB0aGUgY3VycmVudFxuICAgIC8vIHRpbWUuIFRoaXMgd2lsbCBtZWFuIHRoYXQgU3VzcGVuc2UgdGltZW91dHMgYXJlIHNsaWdodGx5IHNoaWZ0ZWQgdG8gbGF0ZXIgdGhhblxuICAgIC8vIHRoZXkgc2hvdWxkIGJlLlxuICAgIC8vIFNjaGVkdWxlIGEgbm9ybWFsIHByaSB1cGRhdGUgdG8gcmVuZGVyIHRoaXMgY29udGVudC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhbmVUb0xhbmVzKERlZmF1bHRIeWRyYXRpb25MYW5lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSdsbCBjb250aW51ZSBoeWRyYXRpbmcgdGhlIHJlc3QgYXQgb2Zmc2NyZWVuIHByaW9yaXR5IHNpbmNlIHdlJ2xsIGFscmVhZHlcbiAgICAvLyBiZSBzaG93aW5nIHRoZSByaWdodCBjb250ZW50IGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXIsIGl0IGlzIG5vIHJ1c2guXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFdlIHNob3VsZCBuZXZlciBiZSBoeWRyYXRpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IGlzIHRoZSBmaXJzdCBwYXNzLFxuICAvLyBidXQgYWZ0ZXIgd2UndmUgYWxyZWFkeSBjb21taXR0ZWQgb25jZS5cbiAgd2FybklmSHlkcmF0aW5nKCk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCAvLyBUT0RPOiBXaGVuIHdlIGRlbGV0ZSBsZWdhY3kgbW9kZSwgd2Ugc2hvdWxkIG1ha2UgdGhpcyBlcnJvciBhcmd1bWVudFxuICAgIC8vIHJlcXVpcmVkIOKAlCBldmVyeSBjb25jdXJyZW50IG1vZGUgcGF0aCB0aGF0IGNhdXNlcyBoeWRyYXRpb24gdG9cbiAgICAvLyBkZS1vcHQgdG8gY2xpZW50IHJlbmRlcmluZyBzaG91bGQgaGF2ZSBhbiBlcnJvciBtZXNzYWdlLlxuICAgIG51bGwpO1xuICB9XG5cbiAgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgLy8gVGhpcyBib3VuZGFyeSBpcyBpbiBhIHBlcm1hbmVudCBmYWxsYmFjayBzdGF0ZS4gSW4gdGhpcyBjYXNlLCB3ZSdsbCBuZXZlclxuICAgIC8vIGdldCBhbiB1cGRhdGUgYW5kIHdlJ2xsIG5ldmVyIGJlIGFibGUgdG8gaHlkcmF0ZSB0aGUgZmluYWwgY29udGVudC4gTGV0J3MganVzdCB0cnkgdGhlXG4gICAgLy8gY2xpZW50IHNpZGUgcmVuZGVyIGluc3RlYWQuXG4gICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgLy8gVE9ETzogVGhlIHNlcnZlciBzaG91bGQgc2VyaWFsaXplIHRoZSBlcnJvciBtZXNzYWdlIHNvIHdlIGNhbiBsb2cgaXRcbiAgICAvLyBoZXJlIG9uIHRoZSBjbGllbnQuIE9yLCBpbiBwcm9kdWN0aW9uLCBhIGhhc2gvaWQgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAgIC8vIHRoZSBlcnJvci5cbiAgICBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgY291bGQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LCBsaWtlbHkgJyArICdkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuIFN3aXRjaGVkIHRvICcgKyAnY2xpZW50IHJlbmRlcmluZy4nKSk7XG4gIH1cbiAgLy8gYW55IGNvbnRleHQgaGFzIGNoYW5nZWQsIHdlIG5lZWQgdG8gdHJlYXQgaXMgYXMgaWYgdGhlIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZC5cblxuXG4gIHZhciBoYXNDb250ZXh0Q2hhbmdlZCA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIGN1cnJlbnQuY2hpbGRMYW5lcyk7XG5cbiAgaWYgKGRpZFJlY2VpdmVVcGRhdGUgfHwgaGFzQ29udGV4dENoYW5nZWQpIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBmaXJzdCByZW5kZXIuIFRoaXMgbWVhbnMgdGhhdCB3ZSBhcmUgbm93IHVuYWJsZSB0b1xuICAgIC8vIGh5ZHJhdGUgaXQuIFdlIG1pZ2h0IHN0aWxsIGJlIGFibGUgdG8gaHlkcmF0ZSBpdCB1c2luZyBhIGhpZ2hlciBwcmlvcml0eSBsYW5lLlxuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKGF0dGVtcHRIeWRyYXRpb25BdExhbmUgIT09IE5vTGFuZSAmJiBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lICE9PSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IG11dGF0aW5nIHNpbmNlIHRoaXMgcmVuZGVyIHdpbGwgZ2V0IGludGVycnVwdGVkLiBUaGlzXG4gICAgICAgIC8vIGlzIG9uZSBvZiB0aGUgdmVyeSByYXJlIHRpbWVzIHdoZXJlIHdlIG11dGF0ZSB0aGUgY3VycmVudCB0cmVlXG4gICAgICAgIC8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSA9IGF0dGVtcHRIeWRyYXRpb25BdExhbmU7IC8vIFRPRE86IElkZWFsbHkgdGhpcyB3b3VsZCBpbmhlcml0IHRoZSBldmVudCB0aW1lIG9mIHRoZSBjdXJyZW50IHJlbmRlclxuXG4gICAgICAgIHZhciBldmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGN1cnJlbnQsIGF0dGVtcHRIeWRyYXRpb25BdExhbmUsIGV2ZW50VGltZSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiB3ZSBoYXZlIHNjaGVkdWxlZCBoaWdoZXIgcHJpIHdvcmsgYWJvdmUsIHRoaXMgd2lsbCBwcm9iYWJseSBqdXN0IGFib3J0IHRoZSByZW5kZXJcbiAgICAvLyBzaW5jZSB3ZSBub3cgaGF2ZSBoaWdoZXIgcHJpb3JpdHkgd29yaywgYnV0IGluIGNhc2UgaXQgZG9lc24ndCwgd2UgbmVlZCB0byBwcmVwYXJlIHRvXG4gICAgLy8gcmVuZGVyIHNvbWV0aGluZywgaWYgd2UgdGltZSBvdXQuIEV2ZW4gaWYgdGhhdCByZXF1aXJlcyB1cyB0byBkZWxldGUgZXZlcnl0aGluZyBhbmRcbiAgICAvLyBza2lwIGh5ZHJhdGlvbi5cbiAgICAvLyBEZWxheSBoYXZpbmcgdG8gZG8gdGhpcyBhcyBsb25nIGFzIHRoZSBzdXNwZW5zZSB0aW1lb3V0IGFsbG93cyB1cy5cblxuXG4gICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIG5ldyBFcnJvcignVGhpcyBTdXNwZW5zZSBib3VuZGFyeSByZWNlaXZlZCBhbiB1cGRhdGUgYmVmb3JlIGl0IGZpbmlzaGVkICcgKyAnaHlkcmF0aW5nLiBUaGlzIGNhdXNlZCB0aGUgYm91bmRhcnkgdG8gc3dpdGNoIHRvIGNsaWVudCByZW5kZXJpbmcuICcgKyAnVGhlIHVzdWFsIHdheSB0byBmaXggdGhpcyBpcyB0byB3cmFwIHRoZSBvcmlnaW5hbCB1cGRhdGUgJyArICdpbiBzdGFydFRyYW5zaXRpb24uJykpO1xuICB9IGVsc2UgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyBzdGlsbCBwZW5kaW5nIG1vcmUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGNhbid0IGh5ZHJhdGUgaXRzXG4gICAgLy8gY29udGVudC4gV2UgdHJlYXQgaXQgYXMgaWYgdGhpcyBjb21wb25lbnQgc3VzcGVuZGVkIGl0c2VsZi4gSXQgbWlnaHQgc2VlbSBhcyBpZlxuICAgIC8vIHdlIGNvdWxkIGp1c3QgdHJ5IHRvIHJlbmRlciBpdCBjbGllbnQtc2lkZSBpbnN0ZWFkLiBIb3dldmVyLCB0aGlzIHdpbGwgcGVyZm9ybSBhXG4gICAgLy8gbG90IG9mIHVubmVjZXNzYXJ5IHdvcmsgYW5kIGlzIHVubGlrZWx5IHRvIGNvbXBsZXRlIHNpbmNlIGl0IG9mdGVuIHdpbGwgc3VzcGVuZFxuICAgIC8vIG9uIG1pc3NpbmcgZGF0YSBhbnl3YXkuIEFkZGl0aW9uYWxseSwgdGhlIHNlcnZlciBtaWdodCBiZSBhYmxlIHRvIHJlbmRlciBtb3JlXG4gICAgLy8gdGhhbiB3ZSBjYW4gb24gdGhlIGNsaWVudCB5ZXQuIEluIHRoYXQgY2FzZSB3ZSdkIGVuZCB1cCB3aXRoIG1vcmUgZmFsbGJhY2sgc3RhdGVzXG4gICAgLy8gb24gdGhlIGNsaWVudCB0aGFuIGlmIHdlIGp1c3QgbGVhdmUgaXQgYWxvbmUuIElmIHRoZSBzZXJ2ZXIgdGltZXMgb3V0IG9yIGVycm9yc1xuICAgIC8vIHRoZXNlIHNob3VsZCB1cGRhdGUgdGhpcyBib3VuZGFyeSB0byB0aGUgcGVybWFuZW50IEZhbGxiYWNrIHN0YXRlIGluc3RlYWQuXG4gICAgLy8gTWFyayBpdCBhcyBoYXZpbmcgY2FwdHVyZWQgKGkuZS4gc3VzcGVuZGVkKS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlOyAvLyBMZWF2ZSB0aGUgY2hpbGQgaW4gcGxhY2UuIEkuZS4gdGhlIGRlaHlkcmF0ZWQgZnJhZ21lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gcmV0cnkgdGhpcyBib3VuZGFyeSBvbmNlIHRoZSBzZXJ2ZXIgaGFzIHNlbnQgdGhlIHJlc3VsdC5cblxuICAgIHZhciByZXRyeSA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChudWxsLCBjdXJyZW50KTtcbiAgICByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShzdXNwZW5zZUluc3RhbmNlLCByZXRyeSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAgICByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUudHJlZUNvbnRleHQpO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pOyAvLyBNYXJrIHRoZSBjaGlsZHJlbiBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4gICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFncyB8PSBIeWRyYXRpbmc7XG4gICAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KTtcbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBmaXJzdENoaWxkLCByZW5kZXJMYW5lcykge1xuICAvLyBNYXJrIGFueSBTdXNwZW5zZSBib3VuZGFyaWVzIHdpdGggZmFsbGJhY2tzIGFzIGhhdmluZyB3b3JrIHRvIGRvLlxuICAvLyBJZiB0aGV5IHdlcmUgcHJldmlvdXNseSBmb3JjZWQgaW50byBmYWxsYmFja3MsIHRoZXkgbWF5IG5vdyBiZSBhYmxlXG4gIC8vIHRvIHVuYmxvY2suXG4gIHZhciBub2RlID0gZmlyc3RDaGlsZDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCkge1xuICAgICAgLy8gSWYgdGhlIHRhaWwgaXMgaGlkZGVuIHRoZXJlIG1pZ2h0IG5vdCBiZSBhbiBTdXNwZW5zZSBib3VuZGFyaWVzXG4gICAgICAvLyB0byBzY2hlZHVsZSB3b3JrIG9uLiBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBvbiB0aGVcbiAgICAgIC8vIGxpc3QgaXRzZWxmLlxuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byB0cmF2ZXJzZSB0byB0aGUgY2hpbGRyZW4gb2YgdGhlIGxpc3Qgc2luY2VcbiAgICAgIC8vIHRoZSBsaXN0IHdpbGwgcHJvcGFnYXRlIHRoZSBjaGFuZ2Ugd2hlbiBpdCByZXJlbmRlcnMuXG4gICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTGFzdENvbnRlbnRSb3coZmlyc3RDaGlsZCkge1xuICAvLyBUaGlzIGlzIGdvaW5nIHRvIGZpbmQgdGhlIGxhc3Qgcm93IGFtb25nIHRoZXNlIGNoaWxkcmVuIHRoYXQgaXMgYWxyZWFkeVxuICAvLyBzaG93aW5nIGNvbnRlbnQgb24gdGhlIHNjcmVlbiwgYXMgb3Bwb3NlZCB0byBiZWluZyBpbiBmYWxsYmFjayBzdGF0ZSBvclxuICAvLyBuZXcuIElmIGEgcm93IGhhcyBtdWx0aXBsZSBTdXNwZW5zZSBib3VuZGFyaWVzLCBhbnkgb2YgdGhlbSBiZWluZyBpbiB0aGVcbiAgLy8gZmFsbGJhY2sgc3RhdGUsIGNvdW50cyBhcyB0aGUgd2hvbGUgcm93IGJlaW5nIGluIGEgZmFsbGJhY2sgc3RhdGUuXG4gIC8vIE5vdGUgdGhhdCB0aGUgXCJyb3dzXCIgd2lsbCBiZSB3b3JrSW5Qcm9ncmVzcywgYnV0IGFueSBuZXN0ZWQgY2hpbGRyZW5cbiAgLy8gd2lsbCBzdGlsbCBiZSBjdXJyZW50IHNpbmNlIHdlIGhhdmVuJ3QgcmVuZGVyZWQgdGhlbSB5ZXQuIFRoZSBtb3VudGVkXG4gIC8vIG9yZGVyIG1heSBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG5ldyBvcmRlci4gV2UgdXNlIHRoZSBuZXcgb3JkZXIuXG4gIHZhciByb3cgPSBmaXJzdENoaWxkO1xuICB2YXIgbGFzdENvbnRlbnRSb3cgPSBudWxsO1xuXG4gIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgbGFzdENvbnRlbnRSb3cgPSByb3c7XG4gICAgfVxuXG4gICAgcm93ID0gcm93LnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbGFzdENvbnRlbnRSb3c7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmIChyZXZlYWxPcmRlciAhPT0gdW5kZWZpbmVkICYmIHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ3RvZ2V0aGVyJyAmJiAhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdKSB7XG4gICAgICBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0gPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIHJldmVhbE9yZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICd0b2dldGhlcic6XG4gICAgICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnVXNlIGxvd2VyY2FzZSBcIiVzXCIgaW5zdGVhZC4nLCByZXZlYWxPcmRlciwgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnUmVhY3QgdXNlcyB0aGUgLXMgc3VmZml4IGluIHRoZSBzcGVsbGluZy4gVXNlIFwiJXNzXCIgaW5zdGVhZC4nLCByZXZlYWxPcmRlciwgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICh0YWlsTW9kZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0pIHtcbiAgICAgIGlmICh0YWlsTW9kZSAhPT0gJ2NvbGxhcHNlZCcgJiYgdGFpbE1vZGUgIT09ICdoaWRkZW4nKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJjb2xsYXBzZWRcIiBvciBcImhpZGRlblwiPycsIHRhaWxNb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAocmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJzxTdXNwZW5zZUxpc3QgdGFpbD1cIiVzXCIgLz4gaXMgb25seSB2YWxpZCBpZiByZXZlYWxPcmRlciBpcyAnICsgJ1wiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LCBpbmRleCkge1xuICB7XG4gICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXkoY2hpbGRTbG90KTtcbiAgICB2YXIgaXNJdGVyYWJsZSA9ICFpc0FuQXJyYXkgJiYgdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmIChpc0FuQXJyYXkgfHwgaXNJdGVyYWJsZSkge1xuICAgICAgdmFyIHR5cGUgPSBpc0FuQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuICAgICAgZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcgKyAnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJyArICc8L1N1c3BlbnNlTGlzdD4nLCB0eXBlLCBpbmRleCwgdHlwZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbiwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjaGlsZHJlbkl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIF9pID0gMDtcblxuICAgICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcgKyAnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaXNCYWNrd2FyZHMsIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSkge1xuICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWw6IHRhaWwsXG4gICAgICB0YWlsTW9kZTogdGFpbE1vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGNhbiByZXVzZSB0aGUgZXhpc3Rpbmcgb2JqZWN0IGZyb20gcHJldmlvdXMgcmVuZGVycy5cbiAgICByZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMDtcbiAgICByZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3c7XG4gICAgcmVuZGVyU3RhdGUudGFpbCA9IHRhaWw7XG4gICAgcmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZTtcbiAgfVxufSAvLyBUaGlzIGNhbiBlbmQgdXAgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IG11bHRpcGxlIHBhc3Nlcy5cbi8vIFRoZSBmaXJzdCBwYXNzIHNwbGl0cyB0aGUgY2hpbGRyZW4gZmliZXJzIGludG8gdHdvIHNldHMuIEEgaGVhZCBhbmQgdGFpbC5cbi8vIFdlIGZpcnN0IHJlbmRlciB0aGUgaGVhZC4gSWYgYW55dGhpbmcgaXMgaW4gZmFsbGJhY2sgc3RhdGUsIHdlIGRvIGFub3RoZXJcbi8vIHBhc3MgdGhyb3VnaCBiZWdpbldvcmsgdG8gcmVyZW5kZXIgYWxsIGNoaWxkcmVuIChpbmNsdWRpbmcgdGhlIHRhaWwpIHdpdGhcbi8vIHRoZSBmb3JjZSBzdXNwZW5kIGNvbnRleHQuIElmIHRoZSBmaXJzdCByZW5kZXIgZGlkbid0IGhhdmUgYW55dGhpbmcgaW5cbi8vIGluIGZhbGxiYWNrIHN0YXRlLiBUaGVuIHdlIHJlbmRlciBlYWNoIHJvdyBpbiB0aGUgdGFpbCBvbmUtYnktb25lLlxuLy8gVGhhdCBoYXBwZW5zIGluIHRoZSBjb21wbGV0ZVdvcmsgcGhhc2Ugd2l0aG91dCBnb2luZyBiYWNrIHRvIGJlZ2luV29yay5cblxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcjtcbiAgdmFyIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWw7XG4gIHZhciBuZXdDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKTtcbiAgdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihuZXdDaGlsZHJlbiwgcmV2ZWFsT3JkZXIpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3VsZEZvcmNlRmFsbGJhY2sgPSBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuXG4gIGlmIChzaG91bGRGb3JjZUZhbGxiYWNrKSB7XG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcbiAgICAgIC8vIG9uIGFueSBuZXN0ZWQgYm91bmRhcmllcyB0byBsZXQgdGhlbSBrbm93IHRvIHRyeSB0byByZW5kZXJcbiAgICAgIC8vIGFnYWluLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNvbnRleHQgdXBkYXRpbmcuXG4gICAgICBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgfVxuXG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAvLyBJbiBsZWdhY3kgbW9kZSwgU3VzcGVuc2VMaXN0IGRvZXNuJ3Qgd29yayBzbyB3ZSBqdXN0XG4gICAgLy8gdXNlIG1ha2UgaXQgYSBub29wIGJ5IHRyZWF0aW5nIGl0IGFzIHRoZSBkZWZhdWx0IHJldmVhbE9yZGVyLlxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIpIHtcbiAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXN0Q29udGVudFJvdyA9IGZpbmRMYXN0Q29udGVudFJvdyh3b3JrSW5Qcm9ncmVzcy5jaGlsZCk7XG4gICAgICAgICAgdmFyIHRhaWw7XG5cbiAgICAgICAgICBpZiAobGFzdENvbnRlbnRSb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBsaXN0IGlzIHBhcnQgb2YgdGhlIHRhaWwuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBjb3VsZCBmYXN0IHBhdGggYnkganVzdCByZW5kZXJpbmcgdGhlIHRhaWwgbm93LlxuICAgICAgICAgICAgdGFpbCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSB0YWlsIHJvd3MgYWZ0ZXIgdGhlIGNvbnRlbnQgcm93LlxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZW0gc2VwYXJhdGVseSBsYXRlci5cbiAgICAgICAgICAgIHRhaWwgPSBsYXN0Q29udGVudFJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgbGFzdENvbnRlbnRSb3cuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICB0YWlsLCBsYXN0Q29udGVudFJvdywgdGFpbE1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBmaW5kIHRoZSBmaXJzdCByb3cgdGhhdCBoYXMgZXhpc3RpbmcgY29udGVudC5cbiAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIGdvaW5nIHRvIHJldmVyc2UgdGhlIGxpc3Qgb2YgZXZlcnl0aGluZ1xuICAgICAgICAgIC8vIHdlIHBhc3MgaW4gdGhlIG1lYW50aW1lLiBUaGF0J3MgZ29pbmcgdG8gYmUgb3VyIHRhaWwgaW4gcmV2ZXJzZVxuICAgICAgICAgIC8vIG9yZGVyLlxuICAgICAgICAgIHZhciBfdGFpbCA9IG51bGw7XG4gICAgICAgICAgdmFyIHJvdyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcblxuICAgICAgICAgIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYWluIGNvbnRlbnQuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcm93O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHRSb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgIHJvdy5zaWJsaW5nID0gX3RhaWw7XG4gICAgICAgICAgICBfdGFpbCA9IHJvdztcbiAgICAgICAgICAgIHJvdyA9IG5leHRSb3c7XG4gICAgICAgICAgfSAvLyBUT0RPOiBJZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBpcyBudWxsLCB3ZSBjYW4gY29udGludWUgb24gdGhlIHRhaWwgaW1tZWRpYXRlbHkuXG5cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBfdGFpbCwgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHRhaWxNb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICd0b2dldGhlcic6XG4gICAgICAgIHtcbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIG51bGwsIC8vIHRhaWxcbiAgICAgICAgICBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGRlZmF1bHQgcmV2ZWFsIG9yZGVyIGlzIHRoZSBzYW1lIGFzIG5vdCBoYXZpbmdcbiAgICAgICAgICAvLyBhIGJvdW5kYXJ5LlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHByb3ZpZGVyVHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJUeXBlLl9jb250ZXh0O1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuXG4gIHtcbiAgICBpZiAoISgndmFsdWUnIGluIG5ld1Byb3BzKSkge1xuICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlcikge1xuICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1RoZSBgdmFsdWVgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgPENvbnRleHQuUHJvdmlkZXI+YC4gRGlkIHlvdSBtaXNzcGVsbCBpdCBvciBmb3JnZXQgdG8gcGFzcyBpdD8nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvdmlkZXJQcm9wVHlwZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3BUeXBlcztcblxuICAgIGlmIChwcm92aWRlclByb3BUeXBlcykge1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvdmlkZXJQcm9wVHlwZXMsIG5ld1Byb3BzLCAncHJvcCcsICdDb250ZXh0LlByb3ZpZGVyJyk7XG4gICAgfVxuICB9XG5cbiAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBuZXdWYWx1ZSk7XG5cbiAge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZFZhbHVlID0gb2xkUHJvcHMudmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgIC8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG4gICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgICAgLy8gdGhlbSB0byB1cGRhdGUuXG4gICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0KTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gVGhpcyBmaWJlciBkb2Vzbid0IGhhdmUgd29yaywgYnV0IGl0cyBzdWJ0cmVlIGRvZXMuIENsb25lIHRoZSBjaGlsZFxuICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuXG5cbiAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci4nKTtcbiAgICB9IC8vIERpc2Nvbm5lY3QgZnJvbSB0aGUgb2xkIGN1cnJlbnQuXG4gICAgLy8gSXQgd2lsbCBnZXQgZGVsZXRlZC5cblxuXG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIG9sZFdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIENvbm5lY3QgdG8gdGhlIG5ldyB0cmVlLlxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuaW5kZXggPSBvbGRXb3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gb2xkV29ya0luUHJvZ3Jlc3Muc2libGluZztcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZXR1cm4gPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmVmID0gb2xkV29ya0luUHJvZ3Jlc3MucmVmOyAvLyBSZXBsYWNlIHRoZSBjaGlsZC9zaWJsaW5nIHBvaW50ZXJzIGFib3ZlIGl0LlxuXG4gICAgaWYgKG9sZFdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZCkge1xuICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwcmV2U2libGluZy5zaWJsaW5nICE9PSBvbGRXb3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudCk7XG4gICAgfVxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50OyAvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxuXG4gICAgcmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIEJlZm9yZSBwZXJmb3JtaW5nIGFuIGVhcmx5IGJhaWxvdXQsIHdlIG11c3QgY2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmdcbiAgLy8gdXBkYXRlcyBvciBjb250ZXh0LlxuICB2YXIgdXBkYXRlTGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBObyBwZW5kaW5nIHVwZGF0ZSwgYnV0IGJlY2F1c2UgY29udGV4dCBpcyBwcm9wYWdhdGVkIGxhemlseSwgd2UgbmVlZFxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gIC8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7XG4gICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgbmV3VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIC8vIFByb2ZpbGVyIHNob3VsZCBvbmx5IGNhbGwgb25SZW5kZXIgd2hlbiBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgaWYgKGhhc0NoaWxkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbiAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpOyAvLyBXZSBrbm93IHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBzdXNwZW5kIGFnYWluIGJlY2F1c2UgaWYgaXQgaGFzXG4gICAgICAgICAgICAgIC8vIGJlZW4gdW5zdXNwZW5kZWQgaXQgaGFzIGNvbW1pdHRlZCBhcyBhIHJlc29sdmVkIFN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgLy8gSWYgaXQgbmVlZHMgdG8gYmUgcmV0cmllZCwgaXQgc2hvdWxkIGhhdmUgd29yayBzY2hlZHVsZWQgb24gaXQuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gV2Ugc2hvdWxkIG5ldmVyIHJlbmRlciB0aGUgY2hpbGRyZW4gb2YgYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IHVudGlsIHdlXG4gICAgICAgICAgICAgIC8vIHVwZ3JhZGUgaXQuIFdlIHJldHVybiBudWxsIGluc3RlYWQgb2YgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yay5cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgaXMgY3VycmVudGx5IHRpbWVkIG91dCwgd2UgbmVlZCB0byBkZWNpZGVcbiAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4gICAgICAgICAgLy8gZ28gc3RyYWlnaHQgdG8gdGhlIGZhbGxiYWNrLiBDaGVjayB0aGUgcHJpb3JpdHkgb2YgdGhlIHByaW1hcnlcbiAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZExhbmVzID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcztcblxuICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG4gICAgICAgICAgICAvLyB0byBhdHRlbXB0IHRvIHJlbmRlciB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhZ2Fpbi5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCBkb2VzIG5vdCBoYXZlIHBlbmRpbmcgd29yayBtYXJrZWRcbiAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuICAgICAgICAgICAgLy8gcHJpb3JpdHkuIEJhaWxvdXQuXG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBmYWxsYmFjayBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gU2tpcCBvdmVyIHRoZVxuICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBjYW4gcmV0dXJuIGBudWxsYCBoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgd2VyZSBuZXN0ZWQgY29udGV4dCBjb25zdW1lcnMsIHZpYSB0aGUgY2FsbCB0b1xuICAgICAgICAgICAgICAvLyBgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29ya2AgYWJvdmUuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGNoaWxkcmVuIHRoZW4gd2UncmUgc3RpbGwgaW4gcHJvZ3Jlc3NpdmUgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBtaWdodCBnZXQgdW5ibG9ja2VkIGJ5IHN0YXRlIHVwZGF0ZXMgb3IgcmV0cmllcyBpbiB0aGVcbiAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgIC8vIHBhdGggdG8gY29tcHV0ZSB0aGUgY29ycmVjdCB0YWlsLlxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG5cblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQgYmVmb3JlIGFuZCB3ZSdyZSByZW5kZXJpbmcgdGhlIHNhbWUgY2hpbGRyZW4sXG4gICAgICAgIC8vIHRoZW4gdGhlIHRhaWwgZG9lc24ndCBtYXR0ZXIuIEFueXRoaW5nIG5ldyB0aGF0IHN1c3BlbmRzIHdpbGwgd29ya1xuICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIHBhc3QgYnV0IGRpZG4ndCBjb21wbGV0ZSBpdC5cbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuICAgICAgICAvLyBhbG1vc3QgaWRlbnRpY2FsIHRvIHRoZSBsb2dpYyB1c2VkIGluIHRoZSBub3JtYWwgdXBkYXRlIHBhdGgsXG4gICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAvLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuICAgICAgICAvLyBoYXZlIG5vdCBjaGFuZ2VkLiBXaGljaCBpcyBmaW5lLlxuICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbiAgICAgICAgLy8gYnV0IEkgd29uJ3QgOilcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgcHJvcHMgbm9yIGxlZ2FjeSBjb250ZXh0IGNoYW5nZXMuIENoZWNrIGlmIHRoZXJlJ3MgYSBwZW5kaW5nXG4gICAgICAvLyB1cGRhdGUgb3IgY29udGV4dCBjaGFuZ2UuXG4gICAgICB2YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0ID0gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCAmJiAvLyBJZiB0aGlzIGlzIHRoZSBzZWNvbmQgcGFzcyBvZiBhbiBlcnJvciBvciBzdXNwZW5zZSBib3VuZGFyeSwgdGhlcmVcbiAgICAgIC8vIG1heSBub3QgYmUgd29yayBzY2hlZHVsZWQgb24gYGN1cnJlbnRgLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBmbGFnLlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gTm8gcGVuZGluZyB1cGRhdGVzIG9yIGNvbnRleHQuIEJhaWwgb3V0IG5vdy5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGNoaWxkIGJlbG9uZ3MgdG8gYSBsaXN0IG9mIG11bGlwbGUgY2hpbGRyZW4gaW5cbiAgICAgIC8vIGl0cyBwYXJlbnQuXG4gICAgICAvL1xuICAgICAgLy8gSW4gYSB0cnVlIG11bHRpLXRocmVhZGVkIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZCByZW5kZXIgY2hpbGRyZW4gb25cbiAgICAgIC8vIHBhcmFsbGVsIHRocmVhZHMuIFRoaXMgd291bGQgcmVwcmVzZW50IHRoZSBiZWdpbm5pbmcgb2YgYSBuZXcgcmVuZGVyXG4gICAgICAvLyB0aHJlYWQgZm9yIHRoaXMgc3VidHJlZS5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBvbmx5IHVzZSB0aGlzIGZvciBpZCBnZW5lcmF0aW9uIGR1cmluZyBoeWRyYXRpb24sIHdoaWNoIGlzIHdoeSB0aGVcbiAgICAgIC8vIGxvZ2ljIGlzIGxvY2F0ZWQgaW4gdGhpcyBzcGVjaWFsIGJyYW5jaC5cbiAgICAgIHZhciBzbG90SW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gZ2V0Rm9ya3NBdExldmVsKCk7XG4gICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzLCBzbG90SW5kZXgpO1xuICAgIH1cbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBDb21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQgPyBfdW5yZXNvbHZlZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50LCBfdW5yZXNvbHZlZFByb3BzKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IHR5cGUgPyBfdW5yZXNvbHZlZFByb3BzMiA6IHJlc29sdmVEZWZhdWx0UHJvcHModHlwZSwgX3VucmVzb2x2ZWRQcm9wczIpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBfcmVzb2x2ZWRQcm9wczIsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHJldHVybiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3R5cGUyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBSZXNvbHZlIG91dGVyIHByb3BzIGZpcnN0LCB0aGVuIHJlc29sdmUgaW5uZXIgcHJvcHMuXG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLCBfdW5yZXNvbHZlZFByb3BzMyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gX3R5cGUyLnByb3BUeXBlcztcblxuICAgICAgICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBfcmVzb2x2ZWRQcm9wczMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLnR5cGUsIF9yZXNvbHZlZFByb3BzMyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIF9yZXNvbHZlZFByb3BzMywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudDIgPyBfdW5yZXNvbHZlZFByb3BzNCA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsIF91bnJlc29sdmVkUHJvcHM0KTtcblxuICAgICAgICByZXR1cm4gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQyLCBfcmVzb2x2ZWRQcm9wczQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBcIiArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuICAvLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbiAgLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuICAvLyBmb3IgaHlkcmF0aW9uLlxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcblxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIHZhciBfZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoKF9mbGFncyAmIFNob3VsZENhcHR1cmUpICE9PSBOb0ZsYWdzICYmIChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgcmVuZGVyIHRoYXQgd2Fzbid0IGNhcHR1cmVkIGJ5IGEgc3VzcGVuc2VcbiAgICAgICAgICAvLyBib3VuZGFyeS4gRG8gYSBzZWNvbmQgcGFzcyBvbiB0aGUgcm9vdCB0byB1bm1vdW50IHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH0gLy8gV2UgdW53b3VuZCB0byB0aGUgcm9vdCB3aXRob3V0IGNvbXBsZXRpbmcgaXQuIEV4aXQuXG5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczIgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbiAgICAgICAgLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4gIC8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4gIC8vIGZvciBoeWRyYXRpb24uXG4gIHBvcFRyZWVDb250ZXh0KGludGVycnVwdGVkV29yayk7XG5cbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG5cbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBjb250ZXh0ID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuX2NvbnRleHQ7XG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFJlbmRlckxhbmVzKGludGVycnVwdGVkV29yayk7XG5cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2Q7XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW5pbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBmdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGRvY3VtZW50YCBnbG9iYWwgd2FzIGRlZmluZWQgd2hlbiBSZWFjdCB3YXMgaW5pdGlhbGl6ZWQsIGJ1dCBpcyBub3QgJyArICdkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgJyArICdzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgJyArICdmaW5pc2hlZCBydW5uaW5nLiBUbyBzb2x2ZSB0aGlzLCB5b3UgY2FuIGVpdGhlciB1bm1vdW50IHRoZSBjb21wb25lbnQgYXQgJyArICd0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgJyArICdjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmICcgKyAndG8gYmUgYXN5bmNocm9ub3VzLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICB2YXIgZGlkQ2FsbCA9IGZhbHNlOyAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVzZXQgaXRcbiAgICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2sgdG8gbGV0IHVzZXIgY29kZSBhY2Nlc3Mgd2luZG93LmV2ZW50IGluIHRoZVxuICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LlxuXG4gICAgICB2YXIgd2luZG93RXZlbnQgPSB3aW5kb3cuZXZlbnQ7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBkZXNjcmlwdG9yIG9mIHdpbmRvdy5ldmVudCB0byByZXN0b3JlIGl0IGFmdGVyIGV2ZW50XG4gICAgICAvLyBkaXNwYXRjaGluZzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzY4OFxuXG4gICAgICB2YXIgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3csICdldmVudCcpO1xuXG4gICAgICBmdW5jdGlvbiByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFdlIGNoZWNrIGZvciB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykgdG8gcHJldmVudCB0aGVcbiAgICAgICAgLy8gd2luZG93LmV2ZW50IGFzc2lnbm1lbnQgaW4gYm90aCBJRSA8PSAxMCBhcyB0aGV5IHRocm93IGFuIGVycm9yXG4gICAgICAgIC8vIFwiTWVtYmVyIG5vdCBmb3VuZFwiIGluIHN0cmljdCBtb2RlLCBhbmQgaW4gRmlyZWZveCB3aGljaCBkb2VzIG5vdFxuICAgICAgICAvLyBzdXBwb3J0IHdpbmRvdy5ldmVudC5cblxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5ldmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cblxuXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIGRpZENhbGwgPSB0cnVlO1xuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH0gLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cblxuXG4gICAgICB2YXIgZXJyb3I7IC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlV2luZG93RXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHsvLyBJZ25vcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cblxuXG4gICAgICB2YXIgZXZ0VHlwZSA9IFwicmVhY3QtXCIgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7IC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cblxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAod2luZG93RXZlbnREZXNjcmlwdG9yKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdldmVudCcsIHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWRDYWxsICYmIGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfSAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcblxuICAgICAgaWYgKCFkaWRDYWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHJlYWxseSB3cm9uZywgYW5kIG91ciBldmVudCB3YXMgbm90IGRpc3BhdGNoZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIHByb2R1Y3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIHJldHVybiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbDtcblxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsOyAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxudmFyIHJlcG9ydGVyID0ge1xuICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBoYXNDYXVnaHRFcnJvcigpIHtcbiAgcmV0dXJuIGhhc0Vycm9yO1xufVxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xuXG57XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xufSAvLyBVc2VkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHRvIHRyYWNrIHRoZSBzdGF0ZSBvZiB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCBzdGFjay5cbi8vIEFsbG93cyB1cyB0byBhdm9pZCB0cmF2ZXJzaW5nIHRoZSByZXR1cm4gcGF0aCB0byBmaW5kIHRoZSBuZWFyZXN0IE9mZnNjcmVlbiBhbmNlc3Rvci5cbi8vIE9ubHkgdXNlZCB3aGVuIGVuYWJsZVN1c3BlbnNlTGF5b3V0RWZmZWN0U2VtYW50aWNzIGlzIGVuYWJsZWQuXG5cblxudmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGZhbHNlO1xudmFyIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBmYWxzZTtcbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG52YXIgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFVzZWQgZm9yIFByb2ZpbGluZyBidWlsZHMgdG8gdHJhY2sgdXBkYXRlcnMuXG5cbnZhciBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xudmFyIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcblxuZnVuY3Rpb24gcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKSB7XG4gIC8vIFdyYXBwaW5nIGVhY2ggc21hbGwgcGFydCBvZiB0aGUgY29tbWl0IHBoYXNlIGludG8gYSBndWFyZGVkXG4gIC8vIGNhbGxiYWNrIGlzIGEgYml0IHRvbyBzbG93IChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMTY2NikuXG4gIC8vIEJ1dCB3ZSByZWx5IG9uIGl0IHRvIHN1cmZhY2UgZXJyb3JzIHRvIERFViB0b29scyBsaWtlIG92ZXJsYXlzXG4gIC8vIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNzEyKS5cbiAgLy8gQXMgYSBjb21wcm9taXNlLCByZXRocm93IG9ubHkgY2F1Z2h0IGVycm9ycyBpbiBhIGd1YXJkLlxuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQsIGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGluc3RhbmNlKSB7XG4gIHRyeSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyKGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufSAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpIHtcbiAgdHJ5IHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0QXR0YWNoUmVmKGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciByZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZXRWYWw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIGVuYWJsZVByb2ZpbGVyQ29tbWl0SG9va3MgJiYgY3VycmVudC5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgcmV0VmFsID0gcmVmKG51bGwpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0VmFsID0gcmVmKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXRWYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZXR1cm4gdmFsdWUgZnJvbSBhIGNhbGxiYWNrIHJlZiBpbiAlcy4gJyArICdBIGNhbGxiYWNrIHJlZiBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSkge1xuICB0cnkge1xuICAgIGRlc3Ryb3koKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuXG52YXIgZm9jdXNlZEluc3RhbmNlSGFuZGxlID0gbnVsbDtcbnZhciBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcbiAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cbiAgdmFyIHNob3VsZEZpcmUgPSBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuICBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuICByZXR1cm4gc2hvdWxkRmlyZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRoaXMgcGhhc2UgaXMgb25seSB1c2VkIGZvciBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIuXG5cbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgQmVmb3JlTXV0YXRpb25NYXNrKSAhPT0gTm9GbGFncyAmJiBjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoY2hpbGQsIGZpYmVyKTtcbiAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaWJlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgZmliZXIucmV0dXJuKTtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgIHNldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IHByZXZQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChmbGFncywgZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlJDEpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTW91bnRcblxuXG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG5cbiAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICgoZWZmZWN0LnRhZyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGVmZmVjdC50YWcgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VFZmZlY3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkZXN0cm95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiAnICsgJ3VwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdHJveS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlICcgKyBob29rTmFtZSArICcoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyBob29rTmFtZSArICcoKCkgPT4ge1xcbicgKyAnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJyArICcgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArICcgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJyArICcgICAgLy8gLi4uXFxuJyArICcgIH1cXG4nICsgJyAgZmV0Y2hEYXRhKCk7XFxuJyArIFwifSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuXCIgKyAnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ob29rcy1kYXRhLWZldGNoaW5nJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQ6ICcgKyBkZXN0cm95O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcignJXMgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgJyArICd3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lcycsIGhvb2tOYW1lLCBhZGRlbmR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAge1xuICAgIC8vIE9ubHkgUHJvZmlsZXJzIHdpdGggd29yayBpbiB0aGVpciBzdWJ0cmVlIHdpbGwgaGF2ZSBhbiBVcGRhdGUgZWZmZWN0IHNjaGVkdWxlZC5cbiAgICBpZiAoKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICBpZCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxcbiAgICAgICAgICAgICAgICBvblBvc3RDb21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25Qb3N0Q29tbWl0OyAvLyBUaGlzIHZhbHVlIHdpbGwgc3RpbGwgcmVmbGVjdCB0aGUgcHJldmlvdXMgY29tbWl0IHBoYXNlLlxuICAgICAgICAgICAgLy8gSXQgZG9lcyBub3QgZ2V0IHJlc2V0IHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjb21taXQgcGhhc2UuXG5cbiAgICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHBoYXNlID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJztcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBwaGFzZSA9ICduZXN0ZWQtdXBkYXRlJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uUG9zdENvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvblBvc3RDb21taXQoaWQsIHBoYXNlLCBwYXNzaXZlRWZmZWN0RHVyYXRpb24sIGNvbW1pdFRpbWUpO1xuICAgICAgICAgICAgfSAvLyBCdWJibGUgdGltZXMgdG8gdGhlIG5leHQgbmVhcmVzdCBhbmNlc3RvciBQcm9maWxlci5cbiAgICAgICAgICAgIC8vIEFmdGVyIHdlIHByb2Nlc3MgdGhhdCBQcm9maWxlciwgd2UnbGwgYnViYmxlIGZ1cnRoZXIgdXAuXG5cblxuICAgICAgICAgICAgdmFyIHBhcmVudEZpYmVyID0gZmluaXNoZWRXb3JrLnJldHVybjtcblxuICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIHJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgaWYgKChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBMYXlvdXRNYXNrKSAhPT0gTm9GbGFncykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICggIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgbGF5b3V0IGVmZmVjdHMgaGF2ZSBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIChkdXJpbmcgbXV0YXRpb24gcGhhc2UpLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbiAgICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgPT09IGZpbmlzaGVkV29yay50eXBlID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuXG5cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG5cbiAgICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgdXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuICAgICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIF91cGRhdGVRdWV1ZSwgX2luc3RhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vbkNvbW1pdCxcbiAgICAgICAgICAgICAgICBvblJlbmRlciA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25SZW5kZXI7XG4gICAgICAgICAgICB2YXIgZWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0gJ25lc3RlZC11cGRhdGUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb25SZW5kZXIoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLCBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLCBjb21taXRUaW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uQ29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Db21taXQoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBlZmZlY3REdXJhdGlvbiwgY29tbWl0VGltZSk7XG4gICAgICAgICAgICAgIH0gLy8gU2NoZWR1bGUgYSBwYXNzaXZlIGVmZmVjdCBmb3IgdGhpcyBQcm9maWxlciB0byBjYWxsIG9uUG9zdENvbW1pdCBob29rcy5cbiAgICAgICAgICAgICAgLy8gVGhpcyBlZmZlY3Qgc2hvdWxkIGJlIHNjaGVkdWxlZCBldmVuIGlmIHRoZXJlIGlzIG5vIG9uUG9zdENvbW1pdCBjYWxsYmFjayBmb3IgdGhpcyBQcm9maWxlcixcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgZWZmZWN0IGlzIGFsc28gd2hlcmUgdGltZXMgYnViYmxlIHRvIHBhcmVudCBQcm9maWxlcnMuXG5cblxuICAgICAgICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaW5pc2hlZFdvcmspOyAvLyBQcm9wYWdhdGUgbGF5b3V0IGVmZmVjdCBkdXJhdGlvbnMgdG8gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3Rvci5cbiAgICAgICAgICAgICAgLy8gRG8gbm90IHJlc2V0IHRoZXNlIHZhbHVlcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgc28gRGV2VG9vbHMgaGFzIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSBmaXJzdC5cblxuICAgICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuXG4gICAgICAgICAgICAgIG91dGVyOiB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCAhb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgIHtcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIobm9kZSkge1xuICAvLyBUdXJuIG9uIGxheW91dCBlZmZlY3RzIGluIGEgdHJlZSB0aGF0IHByZXZpb3VzbHkgZGlzYXBwZWFyZWQuXG4gIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG4gIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICggbm9kZS5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudERpZE1vdW50KG5vZGUsIG5vZGUucmV0dXJuLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzYWZlbHlBdHRhY2hSZWYobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKG5vZGUsIG5vZGUucmV0dXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbikge1xuICAvLyBPbmx5IGhpZGUgb3IgdW5oaWRlIHRoZSB0b3AtbW9zdCBob3N0IG5vZGVzLlxuICB2YXIgaG9zdFN1YnRyZWVSb290ID0gbnVsbDtcblxuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBub2RlO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmhpZGVJbnN0YW5jZShub2RlLnN0YXRlTm9kZSwgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMywgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBub2RlKSB7XG4gICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgdmFyIGluc3RhbmNlVG9Vc2U7XG5cbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9IC8vIE1vdmVkIG91dHNpZGUgdG8gZW5zdXJlIERDRSB3b3JrcyB3aXRoIHRoaXMgZmxhZ1xuXG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZXRWYWw7XG5cbiAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICByZXRWYWwgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0VmFsID0gcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0VmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcgKyAnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFyZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50UmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59IC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbi8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG5cblxuZnVuY3Rpb24gY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuXG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdmFyIF9lZmZlY3QgPSBlZmZlY3QsXG4gICAgICAgICAgICAgICAgICBkZXN0cm95ID0gX2VmZmVjdC5kZXN0cm95LFxuICAgICAgICAgICAgICAgICAgdGFnID0gX2VmZmVjdC50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgodGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgcm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAvLyB3ZSBkbyBhbiBpbm5lciBsb29wIHdoaWxlIHdlJ3JlIHN0aWxsIGluc2lkZSB0aGUgaG9zdCBub2RlLlxuICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgIXN1cHBvcnRzTXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyTXV0YXRpb24oZmliZXIpIHtcbiAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXIgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGV0ZWN0IGFuZCB3YXJuIGFnYWluc3Qgc3RhdGUgdXBkYXRlcyBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlxuICAvLyBJdCBhbHNvIHByZXZlbnRzIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIGZyb20gd2l0aGluIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzLlxuICAvL1xuICAvLyBJZGVhbGx5LCB3ZSBzaG91bGQgYWxzbyBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLlxuICAvLyBUaGlzIGNoaWxkIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjbGVhciBjaGlsZCBvciBzaWJsaW5nIHBvaW50ZXJzIHlldC5cbiAgLy8gVGhleSdyZSBuZWVkZWQgZm9yIHBhc3NpdmUgZWZmZWN0cyBhbmQgZm9yIGZpbmRET01Ob2RlLlxuICAvLyBXZSBkZWZlciB0aG9zZSBmaWVsZHMsIGFuZCBhbGwgb3RoZXIgY2xlYW51cCwgdG8gdGhlIHBhc3NpdmUgcGhhc2UgKHNlZSBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cykuXG4gIC8vXG4gIC8vIERvbid0IHJlc2V0IHRoZSBhbHRlcm5hdGUgeWV0LCBlaXRoZXIuIFdlIG5lZWQgdGhhdCBzbyB3ZSBjYW4gZGV0YWNoIHRoZVxuICAvLyBhbHRlcm5hdGUncyBmaWVsZHMgaW4gdGhlIHBhc3NpdmUgcGhhc2UuIENsZWFyaW5nIHRoZSByZXR1cm4gcG9pbnRlciBpc1xuICAvLyBzdWZmaWNpZW50IGZvciBmaW5kRE9NTm9kZSBzZW1hbnRpY3MuXG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5yZXR1cm4gPSBudWxsO1xuICB9XG5cbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpO1xuICB9IC8vIE5vdGU6IERlZmVuc2l2ZWx5IHVzaW5nIG5lZ2F0aW9uIGluc3RlYWQgb2YgPCBpbiBjYXNlXG4gIC8vIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgaXMgdW5kZWZpbmVkLlxuXG5cbiAge1xuICAgIC8vIENsZWFyIGN5Y2xpY2FsIEZpYmVyIGZpZWxkcy4gVGhpcyBsZXZlbCBhbG9uZSBpcyBkZXNpZ25lZCB0byByb3VnaGx5XG4gICAgLy8gYXBwcm94aW1hdGUgdGhlIHBsYW5uZWQgRmliZXIgcmVmYWN0b3IuIEluIHRoYXQgd29ybGQsIGBzZXRTdGF0ZWAgd2lsbCBiZVxuICAgIC8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG4gICAgLy8gb2JqZWN0IHdpbGwgbm90IGhhdmUgYW55IG9mIHRoZXNlIGZpZWxkcy4gSXQgd2lsbCBvbmx5IGJlIGNvbm5lY3RlZCB0b1xuICAgIC8vIHRoZSBmaWJlciB0cmVlIHZpYSBhIHNpbmdsZSBsaW5rIGF0IHRoZSByb290LiBTbyBpZiB0aGlzIGxldmVsIGFsb25lIGlzXG4gICAgLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG4gICAgZmliZXIuY2hpbGQgPSBudWxsO1xuICAgIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgZmliZXIuc2libGluZyA9IG51bGw7IC8vIFRoZSBgc3RhdGVOb2RlYCBpcyBjeWNsaWNhbCBiZWNhdXNlIG9uIGhvc3Qgbm9kZXMgaXQgcG9pbnRzIHRvIHRoZSBob3N0XG4gICAgLy8gdHJlZSwgd2hpY2ggaGFzIGl0cyBvd24gcG9pbnRlcnMgdG8gY2hpbGRyZW4sIHBhcmVudHMsIGFuZCBzaWJsaW5ncy5cbiAgICAvLyBUaGUgb3RoZXIgaG9zdCBub2RlcyBhbHNvIHBvaW50IGJhY2sgdG8gZmliZXJzLCBzbyB3ZSBzaG91bGQgZGV0YWNoIHRoYXRcbiAgICAvLyBvbmUsIHRvby5cblxuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDsgLy8gSSdtIGludGVudGlvbmFsbHkgbm90IGNsZWFyaW5nIHRoZSBgcmV0dXJuYCBmaWVsZCBpbiB0aGlzIGxldmVsLiBXZVxuICAgIC8vIGFscmVhZHkgZGlzY29ubmVjdCB0aGUgYHJldHVybmAgcG9pbnRlciBhdCB0aGUgcm9vdCBvZiB0aGUgZGVsZXRlZFxuICAgIC8vIHN1YnRyZWUgKGluIGBkZXRhY2hGaWJlck11dGF0aW9uYCkuIEJlc2lkZXMsIGByZXR1cm5gIGJ5IGl0c2VsZiBpcyBub3RcbiAgICAvLyBjeWNsaWNhbCDigJQgaXQncyBvbmx5IGN5Y2xpY2FsIHdoZW4gY29tYmluZWQgd2l0aCBgY2hpbGRgLCBgc2libGluZ2AsIGFuZFxuICAgIC8vIGBhbHRlcm5hdGVgLiBCdXQgd2UnbGwgY2xlYXIgaXQgaW4gdGhlIG5leHQgbGV2ZWwgYW55d2F5LCBqdXN0IGluIGNhc2UuXG5cbiAgICB7XG4gICAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gVGhlb3JldGljYWxseSwgbm90aGluZyBpbiBoZXJlIHNob3VsZCBiZSBuZWNlc3NhcnksIGJlY2F1c2Ugd2UgYWxyZWFkeVxuICAgICAgLy8gZGlzY29ubmVjdGVkIHRoZSBmaWJlciBmcm9tIHRoZSB0cmVlLiBTbyBldmVuIGlmIHNvbWV0aGluZyBsZWFrcyB0aGlzXG4gICAgICAvLyBwYXJ0aWN1bGFyIGZpYmVyLCBpdCB3b24ndCBsZWFrIGFueXRoaW5nIGVsc2VcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGlzIGJyYW5jaCBpcyB0byBiZSBzdXBlciBhZ2dyZXNzaXZlIHNvIHdlIGNhbiBtZWFzdXJlXG4gICAgICAvLyBpZiB0aGVyZSdzIGFueSBkaWZmZXJlbmNlIGluIG1lbW9yeSBpbXBhY3QuIElmIHRoZXJlIGlzLCB0aGF0IGNvdWxkXG4gICAgICAvLyBpbmRpY2F0ZSBhIFJlYWN0IGxlYWsgd2UgZG9uJ3Qga25vdyBhYm91dC5cbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsOyAvLyBUT0RPOiBNb3ZlIHRvIGBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcmAgaW5zdGVhZC5cblxuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcbiAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgIHBlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW47XG4gICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBwZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgLy8gbm9kZS4gVW5mb3J0dW5hdGVseSwgaWYgbXVsdGlwbGUgaW5zZXJ0aW9ucyBhcmUgZG9uZSBpbiBhIHJvdyB3ZSBoYXZlIHRvXG4gIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAvLyBUT0RPOiBGaW5kIGEgbW9yZSBlZmZpY2llbnQgd2F5IHRvIGRvIHRoaXMuXG4gIHZhciBub2RlID0gZmliZXI7XG5cbiAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZS5yZXR1cm4pKSB7XG4gICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgLy8gbGFzdCBzaWJsaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCAmJiBub2RlLnRhZyAhPT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICBpZiAobm9kZS5mbGFncyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgLy8gV2UgYWxzbyBza2lwIHBvcnRhbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGlzIGhvc3QgdHJlZS5cblxuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfSAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuXG5cbiAgICBpZiAoIShub2RlLmZsYWdzICYgUGxhY2VtZW50KSkge1xuICAgICAgLy8gRm91bmQgaXQhXG4gICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG5cblxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgICAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgX2JlZm9yZSwgX3BhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBkZWxldGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IGN1cnJlbnQ7IC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG5cbiAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7IC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuXG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuXG4gICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnICsgJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGU7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIG5vZGUsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpOyAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG5cbiAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cblxuICAgIH0gZWxzZSBpZiAoIG5vZGUudGFnID09PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcblxuXG4gICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgICAgLy8gV2Ugd2lsbCByZWFzc2lnbiBpdCBiYWNrIHdoZW4gd2UgcG9wIHRoZSBwb3J0YWwgb24gdGhlIHdheSB1cC5cbiAgICAgICAgY3VycmVudFBhcmVudCA9IG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgcG9ydGFscyBtaWdodCBjb250YWluIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIG5vZGUsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblxuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gIH1cblxuICBkZXRhY2hGaWJlck11dGF0aW9uKGN1cnJlbnQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspOyAvLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcbiAgICAgICAgICAvLyBkZXN0cm95IGZ1bmN0aW9ucyBmb3IgYWxsIGZpYmVycyBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgY3JlYXRlIGZ1bmN0aW9ucy5cbiAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbiAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgYW4gT2Zmc2NyZWVuIHN1YnRyZWUgdGhhdCBkaXNhcHBlYXJlZFxuICAgICAgICAgIC8vIGR1cmluZyB0aGlzIGNvbW1pdC4gSWYgc28sIHdlIHdvdWxkIGhhdmUgYWxyZWFkeSB1bm1vdW50ZWQgaXRzXG4gICAgICAgICAgLy8gbGF5b3V0IGhvb2tzLiAoSG93ZXZlciwgc2luY2Ugd2UgbnVsbCBvdXQgdGhlIGBkZXN0cm95YCBmdW5jdGlvblxuICAgICAgICAgIC8vIHJpZ2h0IGJlZm9yZSBjYWxsaW5nIGl0LCB0aGUgYmVoYXZpb3IgaXMgYWxyZWFkeSBjb3JyZWN0LCBzbyB0aGlzXG4gICAgICAgICAgLy8gd291bGQgbW9zdGx5IGJlIGZvciBtb2RlbGluZyBwdXJwb3Nlcy4pXG5cbiAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcHJldlJvb3RTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICBpZiAocHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KEluc2VydGlvbiB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTsgLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuXG4gICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTsgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3ByZXZSb290U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChfcHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9yb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIoX3Jvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgY29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspO1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKSB7XG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBwYXNzaXZlIHBoYXNlXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaykge1xuICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4gIC8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgdmFyIHdha2VhYmxlcyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuXG4gICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAgICAgaWYgKGluUHJvZ3Jlc3NMYW5lcyAhPT0gbnVsbCAmJiBpblByb2dyZXNzUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgYXNzb2NpYXRlIHRoZSBvcmlnaW5hbCB1cGRhdGVycyB3aXRoIGl0LlxuICAgICAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKGluUHJvZ3Jlc3NSb290LCBpblByb2dyZXNzTGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0V4cGVjdGVkIGZpbmlzaGVkIHJvb3QgYW5kIGxhbmVzIHRvIGJlIHNldC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG5cbmZ1bmN0aW9uIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQoY3VycmVudCkge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQsIGNvbW1pdHRlZExhbmVzKSB7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICBjb21taXRNdXRhdGlvbkVmZmVjdHNfYmVnaW4ocm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICBpblByb2dyZXNzUm9vdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c19iZWdpbihyb290LCBsYW5lcykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRPRE86IFNob3VsZCB3cmFwIHRoaXMgaW4gZmxhZ3MgY2hlY2ssIHRvbywgYXMgb3B0aW1pemF0aW9uXG5cbiAgICB2YXIgZGVsZXRpb25zID0gZmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb21taXREZWxldGlvbihyb290LCBjaGlsZFRvRGVsZXRlLCBmaWJlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjaGlsZFRvRGVsZXRlLCBmaWJlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICBpZiAoKGZpYmVyLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGNoaWxkLCBmaWJlcik7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZShyb290LCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZShyb290LCBsYW5lcykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgIHRyeSB7XG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpYmVyLCByb290LCBsYW5lcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgZmliZXIucmV0dXJuKTtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKSB7XG4gIC8vIFRPRE86IFRoZSBmYWN0b3Jpbmcgb2YgdGhpcyBwaGFzZSBjb3VsZCBwcm9iYWJseSBiZSBpbXByb3ZlZC4gQ29uc2lkZXJcbiAgLy8gc3dpdGNoaW5nIG9uIHRoZSB0eXBlIG9mIHdvcmsgYmVmb3JlIGNoZWNraW5nIHRoZSBmbGFncy4gVGhhdCdzIHdoYXRcbiAgLy8gd2UgZG8gaW4gYWxsIHRoZSBvdGhlciBwaGFzZXMuIEkgdGhpbmsgdGhpcyBvbmUgaXMgb25seSBkaWZmZXJlbnRcbiAgLy8gYmVjYXVzZSBvZiB0aGUgc2hhcmVkIHJlY29uY2lsaWF0aW9uIGxvZ2ljIGJlbG93LlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKGZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChmaW5pc2hlZFdvcmspO1xuICB9XG5cbiAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmxhZ3MgJiBWaXNpYmlsaXR5KSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV3U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gX2N1cnJlbnQgIT09IG51bGwgJiYgX2N1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCF3YXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgICAgICAgICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9uZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgdmFyIF9pc0hpZGRlbiA9IF9uZXdTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgdmFyIF93YXNIaWRkZW4gPSBfY3VycmVudDIgIT09IG51bGwgJiYgX2N1cnJlbnQyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICB2YXIgb2Zmc2NyZWVuQm91bmRhcnkgPSBmaW5pc2hlZFdvcms7XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBuZWVkcyB0byBydW4gd2hlbmV2ZXIgdGhlcmUncyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlXG4gICAgICAgICAgICAvLyBpbnNpZGUgYSBoaWRkZW4gT2Zmc2NyZWVuIHRyZWUuXG4gICAgICAgICAgICBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihvZmZzY3JlZW5Cb3VuZGFyeSwgX2lzSGlkZGVuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoX2lzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIGlmICghX3dhc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIGlmICgob2Zmc2NyZWVuQm91bmRhcnkubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gb2Zmc2NyZWVuQm91bmRhcnk7XG4gICAgICAgICAgICAgICAgICB2YXIgb2Zmc2NyZWVuQ2hpbGQgPSBvZmZzY3JlZW5Cb3VuZGFyeS5jaGlsZDtcblxuICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNjcmVlbkNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBvZmZzY3JlZW5DaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihvZmZzY3JlZW5DaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbkNoaWxkID0gb2Zmc2NyZWVuQ2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnkgcG9zc2libGVcbiAgLy8gYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlIGVmZmVjdCB0YWcgYW5kXG4gIC8vIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuXG5cbiAgdmFyIHByaW1hcnlGbGFncyA9IGZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IEh5ZHJhdGluZyk7XG5cbiAgIHN3aXRjaCAocHJpbWFyeUZsYWdzKSB7XG4gICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspOyAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAgICAgLy8gYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBraWxsIHRoaXMuXG5cbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cblxuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gflBsYWNlbWVudDsgLy8gVXBkYXRlXG5cbiAgICAgICAgdmFyIF9jdXJyZW50MyA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSHlkcmF0aW5nOlxuICAgICAge1xuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gfkh5ZHJhdGluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEh5ZHJhdGluZ0FuZFVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5IeWRyYXRpbmc7IC8vIFVwZGF0ZVxuXG4gICAgICAgIHZhciBfY3VycmVudDQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50NCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jdXJyZW50NSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQ1LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgbmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihmaW5pc2hlZFdvcmssIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICAvLyBTdXNwZW5zZSBsYXlvdXQgZWZmZWN0cyBzZW1hbnRpY3MgZG9uJ3QgY2hhbmdlIGZvciBsZWdhY3kgcm9vdHMuXG4gIHZhciBpc01vZGVyblJvb3QgPSAoc3VidHJlZVJvb3QubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKCBmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBpc01vZGVyblJvb3QpIHtcbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIHN0YWNrJ3Mgc3RhdGUuXG4gICAgICB2YXIgaXNIaWRkZW4gPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcblxuICAgICAgaWYgKG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbikge1xuICAgICAgICAvLyBUaGUgT2Zmc2NyZWVuIHRyZWUgaXMgaGlkZGVuLiBTa2lwIG92ZXIgaXRzIGxheW91dCBlZmZlY3RzLlxuICAgICAgICBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIEFsc28gY2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dE1hc2tcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSB3YXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47IC8vIFRyYXZlcnNlIHRoZSBPZmZzY3JlZW4gc3VidHJlZSB3aXRoIHRoZSBjdXJyZW50IE9mZnNjcmVlbiBhcyB0aGUgcm9vdC5cblxuICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuICYmICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSByZWFwcGVhcmluZyBib3VuZGFyeS4gVHVybiBpdHMgbGF5b3V0IGVmZmVjdHNcbiAgICAgICAgICAvLyBiYWNrIG9uLlxuICAgICAgICAgIG5leHRFZmZlY3QgPSBmaWJlcjtcbiAgICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oZmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihjaGlsZCwgLy8gTmV3IHJvb3Q7IGJ1YmJsZSBiYWNrIHVwIHRvIGhlcmUgYW5kIHN0b3AuXG4gICAgICAgICAgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfSAvLyBSZXN0b3JlIE9mZnNjcmVlbiBzdGF0ZSBhbmQgcmVzdW1lIGluIG91ci1wcm9ncmVzcyB0cmF2ZXJzYWwuXG5cblxuICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MgJiYgZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoZmlyc3RDaGlsZCwgZmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmICgoZmliZXIuZmxhZ3MgJiBMYXlvdXRNYXNrKSAhPT0gTm9GbGFncykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIGN1cnJlbnQsIGZpYmVyLCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKHNpYmxpbmcsIGZpYmVyLnJldHVybik7XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oc3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBmaXJzdENoaWxkID0gZmliZXIuY2hpbGQ7IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgKFJlZlN0YXRpYyB8IExheW91dFN0YXRpYylcblxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBmaWJlci5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCwgZmliZXIsIGZpYmVyLnJldHVybik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIFJlZlN0YXRpY1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsIGZpYmVyLnJldHVybiwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYVxuICAgICAgICAgIHZhciBpc0hpZGRlbiA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIE5lc3RlZCBPZmZzY3JlZW4gdHJlZSBpcyBhbHJlYWR5IGhpZGRlbi4gRG9uJ3QgZGlzYXBwZWFyXG4gICAgICAgICAgICAvLyBpdHMgZWZmZWN0cy5cbiAgICAgICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dFN0YXRpY1xuXG5cbiAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoZmliZXIgPT09IHN1YnRyZWVSb290KSB7XG4gICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmIChmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkge1xuICAgICAgdmFyIGlzSGlkZGVuID0gZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgIC8vIE5lc3RlZCBPZmZzY3JlZW4gdHJlZSBpcyBzdGlsbCBoaWRkZW4uIERvbid0IHJlLWFwcGVhciBpdHMgZWZmZWN0cy5cbiAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBzdWJ0cmVlRmxhZ3MgJiBMYXlvdXRTdGF0aWNcblxuXG4gICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBtYXkgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLCBzbyB3ZSBjYW4ndFxuICAgICAgLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0LlxuICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0OyAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIExheW91dFN0YXRpY1xuXG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgIHRyeSB7XG4gICAgICByZWFwcGVhckxheW91dEVmZmVjdHNPbkZpYmVyKGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBtYXkgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLCBzbyB3ZSBjYW4ndFxuICAgICAgLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0LlxuICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIG5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4oZmluaXNoZWRXb3JrLCByb290KTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCwgcm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzICYmIGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGZpcnN0Q2hpbGQsIGZpYmVyKTtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCwgZmliZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihzaWJsaW5nLCBmaWJlci5yZXR1cm4pO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KFBhc3NpdmUkMSB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpcnN0Q2hpbGQpIHtcbiAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbigpO1xufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfYmVnaW4oKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgobmV4dEVmZmVjdC5mbGFncyAmIENoaWxkRGVsZXRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gZmliZXIuZGVsZXRpb25zO1xuXG4gICAgICBpZiAoZGVsZXRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpYmVyVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IGZpYmVyVG9EZWxldGU7XG4gICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihmaWJlclRvRGVsZXRlLCBmaWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgLy8gQSBmaWJlciB3YXMgZGVsZXRlZCBmcm9tIHRoaXMgcGFyZW50IGZpYmVyLCBidXQgaXQncyBzdGlsbCBwYXJ0IG9mXG4gICAgICAgICAgLy8gdGhlIHByZXZpb3VzIChhbHRlcm5hdGUpIHBhcmVudCBmaWJlcidzIGxpc3Qgb2YgY2hpbGRyZW4uIEJlY2F1c2VcbiAgICAgICAgICAvLyBjaGlsZHJlbiBhcmUgYSBsaW5rZWQgbGlzdCwgYW4gZWFybGllciBzaWJsaW5nIHRoYXQncyBzdGlsbCBhbGl2ZVxuICAgICAgICAgIC8vIHdpbGwgYmUgY29ubmVjdGVkIHRvIHRoZSBkZWxldGVkIGZpYmVyIHZpYSBpdHMgYGFsdGVybmF0ZWA6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgIGxpdmUgZmliZXJcbiAgICAgICAgICAvLyAgIC0tYWx0ZXJuYXRlLS0+IHByZXZpb3VzIGxpdmUgZmliZXJcbiAgICAgICAgICAvLyAgIC0tc2libGluZy0tPiBkZWxldGVkIGZpYmVyXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBXZSBjYW4ndCBkaXNjb25uZWN0IGBhbHRlcm5hdGVgIG9uIG5vZGVzIHRoYXQgaGF2ZW4ndCBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAvLyB5ZXQsIGJ1dCB3ZSBjYW4gZGlzY29ubmVjdCB0aGUgYHNpYmxpbmdgIGFuZCBgY2hpbGRgIHBvaW50ZXJzLlxuICAgICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkZXRhY2hlZENoaWxkID0gcHJldmlvdXNGaWJlci5jaGlsZDtcblxuICAgICAgICAgICAgaWYgKGRldGFjaGVkQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNGaWJlci5jaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBkZXRhY2hlZFNpYmxpbmcgPSBkZXRhY2hlZENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWRDaGlsZC5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZXRhY2hlZENoaWxkID0gZGV0YWNoZWRTaWJsaW5nO1xuICAgICAgICAgICAgICB9IHdoaWxlIChkZXRhY2hlZENoaWxkICE9PSBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGNoaWxkLCBmaWJlcik7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmICgoZmliZXIuZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaWJlcik7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihzaWJsaW5nLCBmaWJlci5yZXR1cm4pO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGRlbGV0ZWRTdWJ0cmVlUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIERlbGV0aW9uIGVmZmVjdHMgZmlyZSBpbiBwYXJlbnQgLT4gY2hpbGQgb3JkZXJcbiAgICAvLyBUT0RPOiBDaGVjayBpZiBmaWJlciBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWdcblxuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIoZmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IC8vIFRPRE86IE9ubHkgdHJhdmVyc2Ugc3VidHJlZSBpZiBpdCBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWcuIChCdXQsIGlmIHdlXG4gICAgLy8gZG8gdGhpcywgc3RpbGwgbmVlZCB0byBoYW5kbGUgYGRlbGV0ZWRUcmVlQ2xlYW5VcExldmVsYCBjb3JyZWN0bHkuKVxuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihjaGlsZCwgZmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlKGRlbGV0ZWRTdWJ0cmVlUm9vdCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG4gICAgdmFyIHJldHVybkZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgdGhlIGVudGlyZSBkZWxldGVkIHRyZWUgYW5kIGNsZWFuIHVwIGZpYmVyIGZpZWxkcy5cbiAgICAgIC8vIFRoaXMgaXMgbW9yZSBhZ2dyZXNzaXZlIHRoYW4gaWRlYWwsIGFuZCB0aGUgbG9uZyB0ZXJtIGdvYWwgaXMgdG8gb25seVxuICAgICAgLy8gaGF2ZSB0byBkZXRhY2ggdGhlIGRlbGV0ZWQgdHJlZSBhdCB0aGUgcm9vdC5cbiAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKTtcblxuICAgICAgaWYgKGZpYmVyID09PSBkZWxldGVkU3VidHJlZVJvb3QpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgcmV0dXJuRmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBjdXJyZW50Lm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoZmliZXIsIGV4cGVjdGVkUmV0dXJuRmliZXIpIHtcbiAge1xuICAgIGlmICghZGlkV2Fybldyb25nUmV0dXJuUG9pbnRlciAmJiBmaWJlci5yZXR1cm4gIT09IGV4cGVjdGVkUmV0dXJuRmliZXIpIHtcbiAgICAgIGRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIgPSB0cnVlO1xuXG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IFJldHVybiBwb2ludGVyIGlzIGluY29uc2lzdGVudCAnICsgJ3dpdGggcGFyZW50LicpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhc3NpZ25tZW50IG9uY2Ugd2UncmUgY29uZmlkZW50IHRoYXQgaXQgd29uJ3QgYnJlYWtcbiAgLy8gYW55dGhpbmcsIGJ5IGNoZWNraW5nIHRoZSB3YXJuaW5nIGxvZ3MgZm9yIHRoZSBhYm92ZSBpbnZhcmlhbnRcblxuXG4gIGZpYmVyLnJldHVybiA9IGV4cGVjdGVkUmV0dXJuRmliZXI7XG59IC8vIFRPRE86IFJldXNlIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyB0cmF2ZXJzYWwgaGVyZT9cblxuXG5mdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RNb3VudEluREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmliZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0TW91bnRJbkRFVihmaWJlcikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpYmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsIGZpYmVyLnJldHVybiwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgQ09NUE9ORU5UX1RZUEUgPSAwO1xudmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDE7XG52YXIgUk9MRV9UWVBFID0gMjtcbnZhciBURVNUX05BTUVfVFlQRSA9IDM7XG52YXIgVEVYVF9UWVBFID0gNDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3MnKTtcbiAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IudGV4dCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRTZWxlY3Rvcihjb21wb25lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogQ09NUE9ORU5UX1RZUEUsXG4gICAgdmFsdWU6IGNvbXBvbmVudFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvcihzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogSEFTX1BTRVVET19DTEFTU19UWVBFLFxuICAgIHZhbHVlOiBzZWxlY3RvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvbGVTZWxlY3Rvcihyb2xlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJPTEVfVFlQRSxcbiAgICB2YWx1ZTogcm9sZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFNlbGVjdG9yKHRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogVEVYVF9UWVBFLFxuICAgIHZhbHVlOiB0ZXh0XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUZXN0TmFtZVNlbGVjdG9yKGlkKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFRFU1RfTkFNRV9UWVBFLFxuICAgIHZhbHVlOiBpZFxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcbiAgdmFyIG1heWJlRmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGhvc3RSb290KTtcblxuICBpZiAobWF5YmVGaWJlciAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBtYXliZUZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHJvb3Qgc3BlY2lmaWVkLiBTaG91bGQgYmUgZWl0aGVyIGEgUmVhY3QgY29udGFpbmVyIG9yIGEgbm9kZSB3aXRoIGEgdGVzdG5hbWUgYXR0cmlidXRlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZUZpYmVyO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaWJlclJvb3QgPSBmaW5kRmliZXJSb290KGhvc3RSb290KTtcblxuICAgIGlmIChmaWJlclJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgUmVhY3QgY29udGFpbmVyIHdpdGhpbiBzcGVjaWZpZWQgaG9zdCBzdWJ0cmVlLicpO1xuICAgIH0gLy8gVGhlIEZsb3cgdHlwZSBmb3IgRmliZXJSb290IGlzIGEgbGl0dGxlIGZ1bmt5LlxuICAgIC8vIGNyZWF0ZUZpYmVyUm9vdCgpIGNoZWF0cyB0aGlzIGJ5IHRyZWF0aW5nIHRoZSByb290IGFzIDphbnkgYW5kIGFkZGluZyBzdGF0ZU5vZGUgbGF6aWx5LlxuXG5cbiAgICByZXR1cm4gZmliZXJSb290LnN0YXRlTm9kZS5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSB7XG4gIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnR5cGUgPT09IHNlbGVjdG9yLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgcmV0dXJuIGhhc01hdGNoaW5nUGF0aHMoZmliZXIsIHNlbGVjdG9yLnZhbHVlKTtcblxuICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZShub2RlLCBzZWxlY3Rvci52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGZpYmVyKTtcblxuICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwgJiYgdGV4dENvbnRlbnQuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGRhdGFUZXN0SUQgPSBmaWJlci5tZW1vaXplZFByb3BzWydkYXRhLXRlc3RuYW1lJ107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhVGVzdElEID09PSAnc3RyaW5nJyAmJiBkYXRhVGVzdElELnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuJyk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHtcbiAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoc2VsZWN0b3IudmFsdWUpIHx8ICdVbmtub3duJztcbiAgICAgIHJldHVybiBcIjxcIiArIGRpc3BsYXlOYW1lICsgXCI+XCI7XG5cbiAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgIHJldHVybiBcIjpoYXMoXCIgKyAoc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikgfHwgJycpICsgXCIpXCI7XG5cbiAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgIHJldHVybiBcIltyb2xlPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG4gICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyBzZWxlY3Rvci52YWx1ZSArIFwiXFxcIlwiO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIHJldHVybiBcIltkYXRhLXRlc3RuYW1lPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKSB7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IFtdO1xuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoc2VsZWN0b3IgIT0gbnVsbCAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgICAgc2VsZWN0b3JJbmRleCsrO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgbWF0Y2hpbmdGaWJlcnMucHVzaChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hpbmdGaWJlcnM7XG59IC8vIFNhbWUgYXMgZmluZFBhdGhzIGJ1dCB3aXRoIGVhZ2VyIGJhaWxvdXQgb24gZmlyc3QgbWF0Y2hcblxuXG5mdW5jdGlvbiBoYXNNYXRjaGluZ1BhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoc2VsZWN0b3IgIT0gbnVsbCAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgICAgc2VsZWN0b3JJbmRleCsrO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpO1xuICB2YXIgaW5zdGFuY2VSb290cyA9IFtdO1xuICB2YXIgc3RhY2sgPSBBcnJheS5mcm9tKG1hdGNoaW5nRmliZXJzKTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgbm9kZSA9IHN0YWNrW2luZGV4KytdO1xuXG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZVJvb3RzLnB1c2gobm9kZS5zdGF0ZU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2VSb290cztcbn1cbmZ1bmN0aW9uIGdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbihob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXhTZWxlY3RvckluZGV4ID0gMDtcbiAgdmFyIG1hdGNoZWROYW1lcyA9IFtdOyAvLyBUaGUgbG9naWMgb2YgdGhpcyBsb29wIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCBmaW5kUGF0aHMoKVxuXG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3JJbmRleCA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcblxuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgIG1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpKTtcbiAgICAgIHNlbGVjdG9ySW5kZXgrKztcblxuICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4KSB7XG4gICAgICAgIG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgIHZhciB1bm1hdGNoZWROYW1lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IG1heFNlbGVjdG9ySW5kZXg7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcnNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ2ZpbmRBbGxOb2RlcyB3YXMgYWJsZSB0byBtYXRjaCBwYXJ0IG9mIHRoZSBzZWxlY3RvcjpcXG4nICsgKFwiICBcIiArIG1hdGNoZWROYW1lcy5qb2luKCcgPiAnKSArIFwiXFxuXFxuXCIpICsgJ05vIG1hdGNoaW5nIGNvbXBvbmVudCB3YXMgZm91bmQgZm9yOlxcbicgKyAoXCIgIFwiICsgdW5tYXRjaGVkTmFtZXMuam9pbignID4gJykpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQm91bmRpbmdSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIGJvdW5kaW5nUmVjdHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlUm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICBib3VuZGluZ1JlY3RzLnB1c2goZ2V0Qm91bmRpbmdSZWN0KGluc3RhbmNlUm9vdHNbaV0pKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gYm91bmRpbmdSZWN0cy5sZW5ndGggLSAxOyBfaSA+IDA7IF9pLS0pIHtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IGJvdW5kaW5nUmVjdHNbX2ldO1xuICAgIHZhciB0YXJnZXRMZWZ0ID0gdGFyZ2V0UmVjdC54O1xuICAgIHZhciB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyB0YXJnZXRSZWN0LndpZHRoO1xuICAgIHZhciB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0Lnk7XG4gICAgdmFyIHRhcmdldEJvdHRvbSA9IHRhcmdldFRvcCArIHRhcmdldFJlY3QuaGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaiA9IF9pIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChfaSAhPT0gaikge1xuICAgICAgICB2YXIgb3RoZXJSZWN0ID0gYm91bmRpbmdSZWN0c1tqXTtcbiAgICAgICAgdmFyIG90aGVyTGVmdCA9IG90aGVyUmVjdC54O1xuICAgICAgICB2YXIgb3RoZXJSaWdodCA9IG90aGVyTGVmdCArIG90aGVyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIG90aGVyVG9wID0gb3RoZXJSZWN0Lnk7XG4gICAgICAgIHZhciBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDsgLy8gTWVyZ2luZyBhbGwgcmVjdHMgdG8gdGhlIG1pbmltdW1zIHNldCB3b3VsZCBiZSBjb21wbGljYXRlZCxcbiAgICAgICAgLy8gYnV0IHdlIGNhbiBoYW5kbGUgdGhlIG1vc3QgY29tbW9uIGNhc2VzOlxuICAgICAgICAvLyAxLiBjb21wbGV0ZWx5IG92ZXJsYXBwaW5nIHJlY3RzXG4gICAgICAgIC8vIDIuIGFkamFjZW50IHJlY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHdpZHRoIG9yIGhlaWdodCAoZS5nLiBpdGVtcyBpbiBhIGxpc3QpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV2ZW4gZ2l2ZW4gdGhlIGFib3ZlIGNvbnN0cmFpbnRzLFxuICAgICAgICAvLyB3ZSBzdGlsbCB3b24ndCBlbmQgdXAgd2l0aCB0aGUgZmV3ZXN0IHBvc3NpYmxlIHJlY3RzIHdpdGhvdXQgZG9pbmcgbXVsdGlwbGUgcGFzc2VzLFxuICAgICAgICAvLyBidXQgaXQncyBnb29kIGVub3VnaCBmb3IgdGhpcyBwdXJwb3NlLlxuXG4gICAgICAgIGlmICh0YXJnZXRMZWZ0ID49IG90aGVyTGVmdCAmJiB0YXJnZXRUb3AgPj0gb3RoZXJUb3AgJiYgdGFyZ2V0UmlnaHQgPD0gb3RoZXJSaWdodCAmJiB0YXJnZXRCb3R0b20gPD0gb3RoZXJCb3R0b20pIHtcbiAgICAgICAgICAvLyBDb21wbGV0ZSBvdmVybGFwcGluZyByZWN0czsgcmVtb3ZlIHRoZSBpbm5lciBvbmUuXG4gICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldExlZnQgPT09IG90aGVyTGVmdCAmJiB0YXJnZXRSZWN0LndpZHRoID09PSBvdGhlclJlY3Qud2lkdGggJiYgIShvdGhlckJvdHRvbSA8IHRhcmdldFRvcCkgJiYgIShvdGhlclRvcCA+IHRhcmdldEJvdHRvbSkpIHtcbiAgICAgICAgICAvLyBBZGphY2VudCB2ZXJ0aWNhbCByZWN0czsgbWVyZ2UgdGhlbS5cbiAgICAgICAgICBpZiAob3RoZXJUb3AgPiB0YXJnZXRUb3ApIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgKz0gb3RoZXJUb3AgLSB0YXJnZXRUb3A7XG4gICAgICAgICAgICBvdGhlclJlY3QueSA9IHRhcmdldFRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXJCb3R0b20gPCB0YXJnZXRCb3R0b20pIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZGluZ1JlY3RzLnNwbGljZShfaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VG9wID09PSBvdGhlclRvcCAmJiB0YXJnZXRSZWN0LmhlaWdodCA9PT0gb3RoZXJSZWN0LmhlaWdodCAmJiAhKG90aGVyUmlnaHQgPCB0YXJnZXRMZWZ0KSAmJiAhKG90aGVyTGVmdCA+IHRhcmdldFJpZ2h0KSkge1xuICAgICAgICAgIC8vIEFkamFjZW50IGhvcml6b250YWwgcmVjdHM7IG1lcmdlIHRoZW0uXG4gICAgICAgICAgaWYgKG90aGVyTGVmdCA+IHRhcmdldExlZnQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCArPSBvdGhlckxlZnQgLSB0YXJnZXRMZWZ0O1xuICAgICAgICAgICAgb3RoZXJSZWN0LnggPSB0YXJnZXRMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlclJpZ2h0IDwgdGFyZ2V0UmlnaHQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kaW5nUmVjdHMuc3BsaWNlKF9pLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZGluZ1JlY3RzO1xufVxuZnVuY3Rpb24gZm9jdXNXaXRoaW4oaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIHN0YWNrID0gQXJyYXkuZnJvbShtYXRjaGluZ0ZpYmVycyk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG5cbiAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgdmFyIG5vZGUgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChzZXRGb2N1c0lmRm9jdXNhYmxlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzdGFjay5wdXNoKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgY29tbWl0SG9va3MgPSBbXTtcbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKCkge1xuICBpZiAoc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gb2JzZXJ2ZVZpc2libGVSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG5cbiAgdmFyIF9zZXR1cEludGVyc2VjdGlvbk9icyA9IHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW5zdGFuY2VSb290cywgY2FsbGJhY2ssIG9wdGlvbnMpLFxuICAgICAgZGlzY29ubmVjdCA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5kaXNjb25uZWN0LFxuICAgICAgb2JzZXJ2ZSA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5vYnNlcnZlLFxuICAgICAgdW5vYnNlcnZlID0gX3NldHVwSW50ZXJzZWN0aW9uT2JzLnVub2JzZXJ2ZTsgLy8gV2hlbiBSZWFjdCBtdXRhdGVzIHRoZSBob3N0IGVudmlyb25tZW50LCB3ZSBtYXkgbmVlZCB0byBjaGFuZ2Ugd2hhdCB3ZSdyZSBsaXN0ZW5pbmcgdG8uXG5cblxuICB2YXIgY29tbWl0SG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dEluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgaW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgIHVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5leHRJbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKGluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpIDwgMCkge1xuICAgICAgICBvYnNlcnZlKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29tbWl0SG9va3MucHVzaChjb21taXRIb29rKTtcbiAgcmV0dXJuIHtcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3IgUmVhY3QgbXV0YXRpb25zOlxuICAgICAgdmFyIGluZGV4ID0gY29tbWl0SG9va3MuaW5kZXhPZihjb21taXRIb29rKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgY29tbWl0SG9va3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH0gLy8gRGlzY29ubmVjdCB0aGUgaG9zdCBvYnNlcnZlcjpcblxuXG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3RDdXJyZW50QWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZTtcbmZ1bmN0aW9uIGlzTGVnYWN5QWN0RW52aXJvbm1lbnQoZmliZXIpIHtcbiAge1xuICAgIC8vIExlZ2FjeSBtb2RlLiBXZSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2YgUmVhY3QgMTcncyBhY3QuIEl0IGFzc3VtZXMgYW5cbiAgICAvLyBhY3QgZW52aXJvbm1lbnQgd2hlbmV2ZXIgYGplc3RgIGlzIGRlZmluZWQsIGJ1dCB5b3UgY2FuIHN0aWxsIHR1cm4gb2ZmXG4gICAgLy8gc3B1cmlvdXMgd2FybmluZ3MgYnkgc2V0dGluZyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZXhwbGljaXRseVxuICAgIC8vIHRvIGZhbHNlLlxuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDsgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgamVzdFxuXG4gICAgdmFyIGplc3RJc0RlZmluZWQgPSB0eXBlb2YgamVzdCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgcmV0dXJuIHdhcm5zSWZOb3RBY3RpbmcgJiYgamVzdElzRGVmaW5lZCAmJiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgIT09IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAge1xuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IEluY2x1ZGUgbGluayB0byByZWxldmFudCBkb2N1bWVudGF0aW9uIHBhZ2UuXG4gICAgICBlcnJvcignVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0ICcgKyAnYWN0KC4uLiknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICB9XG59XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyLFxuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7XG52YXIgTm9Db250ZXh0ID1cbi8qICAgICAgICAgICAgICovXG4wO1xudmFyIEJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUmVuZGVyQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBDb21taXRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgICovXG40O1xudmFyIFJvb3RJblByb2dyZXNzID0gMDtcbnZhciBSb290RmF0YWxFcnJvcmVkID0gMTtcbnZhciBSb290RXJyb3JlZCA9IDI7XG52YXIgUm9vdFN1c3BlbmRlZCA9IDM7XG52YXIgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQ7XG52YXIgUm9vdENvbXBsZXRlZCA9IDU7XG52YXIgUm9vdERpZE5vdENvbXBsZXRlID0gNjsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSAoKm5vdCogYW4gaW50ZXJsZWF2ZWQgZXZlbnQpLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzOyAvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7IC8vIFRoZXNlIGFyZSBlcnJvcnMgdGhhdCB3ZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IHN1cmZhY2luZyB0aGVtIHRvIHRoZSBVSS5cbi8vIFdlIHdpbGwgbG9nIHRoZW0gb25jZSB0aGUgdHJlZSBjb21taXRzLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsOyAvLyBUaGUgbW9zdCByZWNlbnQgdGltZSB3ZSBjb21taXR0ZWQgYSBmYWxsYmFjay4gVGhpcyBsZXRzIHVzIGVuc3VyZSBhIHRyYWluXG4vLyBtb2RlbCB3aGVyZSB3ZSBkb24ndCBjb21taXQgbmV3IGxvYWRpbmcgc3RhdGVzIGluIHRvbyBxdWljayBzdWNjZXNzaW9uLlxuXG52YXIgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDA7XG52YXIgRkFMTEJBQ0tfVEhST1RUTEVfTVMgPSA1MDA7IC8vIFRoZSBhYnNvbHV0ZSB0aW1lIGZvciB3aGVuIHdlIHNob3VsZCBzdGFydCBnaXZpbmcgdXAgb24gcmVuZGVyaW5nXG4vLyBtb3JlIGFuZCBwcmVmZXIgQ1BVIHN1c3BlbnNlIGhldXJpc3RpY3MgaW5zdGVhZC5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eTsgLy8gSG93IGxvbmcgYSByZW5kZXIgaXMgc3VwcG9zZWQgdG8gdGFrZSBiZWZvcmUgd2Ugc3RhcnQgZm9sbG93aW5nIENQVVxuLy8gc3VzcGVuc2UgaGV1cmlzdGljcyBhbmQgb3B0IG91dCBvZiByZW5kZXJpbmcgbW9yZSBjb250ZW50LlxuXG52YXIgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDA7XG5cbmZ1bmN0aW9uIHJlc2V0UmVuZGVyVGltZXIoKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVM7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO1xufVxudmFyIGhhc1VuY2F1Z2h0RXJyb3IgPSBmYWxzZTtcbnZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDsgLy8gT25seSB1c2VkIHdoZW4gZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVTY2hlZHVsZWRIb29rIGlzIHRydWU7XG52YXIgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG52YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xudmFyIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzID0gW107XG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDsgLy8gSWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlIHNob3VsZCB0cmVhdCB0aGVpclxuLy8gZXZlbnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2sgdGltZSBoYXMgYWR2YW5jZWRcbi8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxudmFyIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbnZhciBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IE5vTGFuZXM7XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG59XG5mdW5jdGlvbiByZXF1ZXN0RXZlbnRUaW1lKCkge1xuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgLy8gV2UncmUgaW5zaWRlIFJlYWN0LCBzbyBpdCdzIGZpbmUgdG8gcmVhZCB0aGUgYWN0dWFsIHRpbWUuXG4gICAgcmV0dXJuIG5vdyQxKCk7XG4gIH0gLy8gV2UncmUgbm90IGluc2lkZSBSZWFjdCwgc28gd2UgbWF5IGJlIGluIHRoZSBtaWRkbGUgb2YgYSBicm93c2VyIGV2ZW50LlxuXG5cbiAgaWYgKGN1cnJlbnRFdmVudFRpbWUgIT09IE5vVGltZXN0YW1wKSB7XG4gICAgLy8gVXNlIHRoZSBzYW1lIHN0YXJ0IHRpbWUgZm9yIGFsbCB1cGRhdGVzIHVudGlsIHdlIGVudGVyIFJlYWN0IGFnYWluLlxuICAgIHJldHVybiBjdXJyZW50RXZlbnRUaW1lO1xuICB9IC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZSBzaW5jZSBSZWFjdCB5aWVsZGVkLiBDb21wdXRlIGEgbmV3IHN0YXJ0IHRpbWUuXG5cblxuICBjdXJyZW50RXZlbnRUaW1lID0gbm93JDEoKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICggKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFRoZXNlIGFyZSBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuIFRoZVxuICAgIC8vIG9sZCBiZWhhdmlvciBpcyB0byBnaXZlIHRoaXMgdGhlIHNhbWUgXCJ0aHJlYWRcIiAobGFuZXMpIGFzXG4gICAgLy8gd2hhdGV2ZXIgaXMgY3VycmVudGx5IHJlbmRlcmluZy4gU28gaWYgeW91IGNhbGwgYHNldFN0YXRlYCBvbiBhIGNvbXBvbmVudFxuICAgIC8vIHRoYXQgaGFwcGVucyBsYXRlciBpbiB0aGUgc2FtZSByZW5kZXIsIGl0IHdpbGwgZmx1c2guIElkZWFsbHksIHdlIHdhbnQgdG9cbiAgICAvLyByZW1vdmUgdGhlIHNwZWNpYWwgY2FzZSBhbmQgdHJlYXQgdGhlbSBhcyBpZiB0aGV5IGNhbWUgZnJvbSBhblxuICAgIC8vIGludGVybGVhdmVkIGV2ZW50LiBSZWdhcmRsZXNzLCB0aGlzIHBhdHRlcm4gaXMgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgb25seSBhIGZhbGxiYWNrLiBUaGUgZmxhZyBvbmx5IGV4aXN0cyB1bnRpbCB3ZSBjYW4gcm9sbFxuICAgIC8vIG91dCB0aGUgc2V0U3RhdGUgd2FybmluZywgc2luY2UgZXhpc3RpbmcgY29kZSBtaWdodCBhY2NpZGVudGFsbHkgcmVseSBvblxuICAgIC8vIHRoZSBjdXJyZW50IGJlaGF2aW9yLlxuICAgIHJldHVybiBwaWNrQXJiaXRyYXJ5TGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgaXNUcmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkgIT09IE5vVHJhbnNpdGlvbjtcblxuICBpZiAoaXNUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuXG4gICAgICBpZiAoIXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpO1xuICAgIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gICAgLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZVxuICAgIC8vIGlucHV0cyB0byB0aGUgYWxnb3JpdGhtIG11c3QgYmUgdGhlIHNhbWUuXG4gICAgLy9cbiAgICAvLyBUaGUgdHJpY2sgd2UgdXNlIGlzIHRvIGNhY2hlIHRoZSBmaXJzdCBvZiBlYWNoIG9mIHRoZXNlIGlucHV0cyB3aXRoaW4gYW5cbiAgICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpc1xuICAgIC8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cblxuXG4gICAgaWYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIEFsbCB0cmFuc2l0aW9ucyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgYXJlIGFzc2lnbmVkIHRoZSBzYW1lIGxhbmUuXG4gICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO1xuICB9IC8vIFVwZGF0ZXMgb3JpZ2luYXRpbmcgaW5zaWRlIGNlcnRhaW4gUmVhY3QgbWV0aG9kcywgbGlrZSBmbHVzaFN5bmMsIGhhdmVcbiAgLy8gdGhlaXIgcHJpb3JpdHkgc2V0IGJ5IHRyYWNraW5nIGl0IHdpdGggYSBjb250ZXh0IHZhcmlhYmxlLlxuICAvL1xuICAvLyBUaGUgb3BhcXVlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGhvc3QgY29uZmlnIGlzIGludGVybmFsbHkgYSBsYW5lLCBzbyB3ZSBjYW5cbiAgLy8gdXNlIHRoYXQgZGlyZWN0bHkuXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0eXBlIGNvbnZlcnNpb24gdG8gdGhlIGV2ZW50IHByaW9yaXR5IG1vZHVsZS5cblxuXG4gIHZhciB1cGRhdGVMYW5lID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgaWYgKHVwZGF0ZUxhbmUgIT09IE5vTGFuZSkge1xuICAgIHJldHVybiB1cGRhdGVMYW5lO1xuICB9IC8vIFRoaXMgdXBkYXRlIG9yaWdpbmF0ZWQgb3V0c2lkZSBSZWFjdC4gQXNrIHRoZSBob3N0IGVudmlyb25tZW50IGZvciBhblxuICAvLyBhcHByb3ByaWF0ZSBwcmlvcml0eSwgYmFzZWQgb24gdGhlIHR5cGUgb2YgZXZlbnQuXG4gIC8vXG4gIC8vIFRoZSBvcGFxdWUgdHlwZSByZXR1cm5lZCBieSB0aGUgaG9zdCBjb25maWcgaXMgaW50ZXJuYWxseSBhIGxhbmUsIHNvIHdlIGNhblxuICAvLyB1c2UgdGhhdCBkaXJlY3RseS5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHR5cGUgY29udmVyc2lvbiB0byB0aGUgZXZlbnQgcHJpb3JpdHkgbW9kdWxlLlxuXG5cbiAgdmFyIGV2ZW50TGFuZSA9IGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCk7XG4gIHJldHVybiBldmVudExhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfVxuXG4gIHJldHVybiBjbGFpbU5leHRSZXRyeUxhbmUoKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIGxhbmUpO1xuXG4gIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxuXG5cbiAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vTGFuZXMgJiYgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gVGhpcyB1cGRhdGUgd2FzIGRpc3BhdGNoZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXMgaXMgYSBtaXN0YWtlXG4gICAgLy8gaWYgdGhlIHVwZGF0ZSBvcmlnaW5hdGVzIGZyb20gdXNlciBzcGFjZSAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIGxvY2FsXG4gICAgLy8gaG9vayB1cGRhdGVzLCB3aGljaCBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgcmVhY2ggdGhpc1xuICAgIC8vIGZ1bmN0aW9uKSwgYnV0IHRoZXJlIGFyZSBzb21lIGludGVybmFsIFJlYWN0IGZlYXR1cmVzIHRoYXQgdXNlIHRoaXMgYXNcbiAgICAvLyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGxpa2Ugc2VsZWN0aXZlIGh5ZHJhdGlvbi5cbiAgICB3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcik7IC8vIFRyYWNrIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIG5vcm1hbCB1cGRhdGUsIHNjaGVkdWxlZCBmcm9tIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS4gRm9yXG4gICAgLy8gZXhhbXBsZSwgZHVyaW5nIGFuIGlucHV0IGV2ZW50LlxuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcik7XG5cbiAgICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgICAvLyBUT0RPOiBDb25zb2xpZGF0ZSB3aXRoIGBpc0ludGVybGVhdmVkVXBkYXRlYCBjaGVja1xuICAgICAgLy8gUmVjZWl2ZWQgYW4gdXBkYXRlIHRvIGEgdHJlZSB0aGF0J3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuIE1hcmtcbiAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuICAgICAgLy8gYGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaGAgZmxhZyBpcyBvZmYgYW5kIHRoaXMgaXMgYSByZW5kZXJcbiAgICAgIC8vIHBoYXNlIHVwZGF0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBkb24ndCB0cmVhdCByZW5kZXIgcGhhc2UgdXBkYXRlcyBhcyBpZlxuICAgICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICAgICAgaWYgKCAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpIHtcbiAgICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbiAgICAgICAgLy8gc3VzcGVuZGVkIG5vdywgcmlnaHQgYmVmb3JlIG1hcmtpbmcgdGhlIGluY29taW5nIHVwZGF0ZS4gVGhpcyBoYXMgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuICAgICAgICAvLyBhbHJlYWR5IHN0YXJ0ZWQgcmVuZGVyaW5nLlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcblxuICAgIGlmIChsYW5lID09PSBTeW5jTGFuZSAmJiBleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiYgKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgIC8vIGEgYmF0Y2guIFRoaXMgaXMgaW50ZW50aW9uYWxseSBpbnNpZGUgc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGluc3RlYWQgb2ZcbiAgICAgIC8vIHNjaGVkdWxlQ2FsbGJhY2tGb3JGaWJlciB0byBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAvLyB1cGRhdGVzLCB0byBwcmVzZXJ2ZSBoaXN0b3JpY2FsIGJlaGF2aW9yIG9mIGxlZ2FjeSBtb2RlLlxuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSkge1xuICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBmb3JrIG9mIHNjaGVkdWxlVXBkYXRlT25GaWJlciB0aGF0IGlzIG9ubHkgdXNlZCB0b1xuICAvLyBzY2hlZHVsZSB0aGUgaW5pdGlhbCBoeWRyYXRpb24gb2YgYSByb290IHRoYXQgaGFzIGp1c3QgYmVlbiBjcmVhdGVkLiBNb3N0XG4gIC8vIG9mIHRoZSBzdHVmZiBpbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgY2FuIGJlIHNraXBwZWQuXG4gIC8vXG4gIC8vIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBzZXBhcmF0ZSBwYXRoLCB0aG91Z2gsIGlzIHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAvLyBpbml0aWFsIGNoaWxkcmVuIGZyb20gc3Vic2VxdWVudCB1cGRhdGVzLiBJbiBmdWxseSBjbGllbnQtcmVuZGVyZWQgcm9vdHNcbiAgLy8gKGNyZWF0ZVJvb3QgaW5zdGVhZCBvZiBoeWRyYXRlUm9vdCksIGFsbCB0b3AtbGV2ZWwgcmVuZGVycyBhcmUgbW9kZWxlZCBhc1xuICAvLyB1cGRhdGVzLCBidXQgaHlkcmF0aW9uIHJvb3RzIGFyZSBzcGVjaWFsIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3RcbiAgLy8gbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIGN1cnJlbnQubGFuZXMgPSBsYW5lO1xuICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG59IC8vIFRoaXMgaXMgc3BsaXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIHdlIGNhbiBtYXJrIGEgZmliZXIgd2l0aCBwZW5kaW5nXG4vLyB3b3JrIHdpdGhvdXQgdHJlYXRpbmcgaXQgYXMgYSB0eXBpY2FsIHVwZGF0ZSB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBhbiBldmVudDtcbi8vIGUuZy4gcmV0cnlpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBpc24ndCBhbiB1cGRhdGUsIGJ1dCBpdCBkb2VzIHNjaGVkdWxlIHdvcmtcbi8vIG9uIGEgZmliZXIuXG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCBsYW5lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgbGFuZXNcbiAgc291cmNlRmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLCBsYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIGxhbmUpO1xuICB9XG5cbiAge1xuICAgIGlmIChhbHRlcm5hdGUgPT09IG51bGwgJiYgKHNvdXJjZUZpYmVyLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICB9XG4gIH0gLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMuXG5cblxuICB2YXIgbm9kZSA9IHNvdXJjZUZpYmVyO1xuICB2YXIgcGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBwYXJlbnQuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMocGFyZW50LmNoaWxkTGFuZXMsIGxhbmUpO1xuICAgIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG5cbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIGxhbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmICgocGFyZW50LmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gcGFyZW50O1xuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cblxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyLCBsYW5lKSB7XG4gIHJldHVybiAoLy8gVE9ETzogT3B0aW1pemUgc2xpZ2h0bHkgYnkgY29tcGFyaW5nIHRvIHJvb3QgdGhhdCBmaWJlciBiZWxvbmdzIHRvLlxuICAgIC8vIFJlcXVpcmVzIHNvbWUgcmVmYWN0b3JpbmcuIE5vdCBhIGJpZyBkZWFsIHRob3VnaCBzaW5jZSBpdCdzIHJhcmUgZm9yXG4gICAgLy8gY29uY3VycmVudCBhcHBzIHRvIGhhdmUgbW9yZSB0aGFuIGEgc2luZ2xlIHJvb3QuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsICYmIChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUgJiYgKCAvLyBJZiB0aGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZSAoaS5lLiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyksXG4gICAgLy8gdGhlbiBkb24ndCB0cmVhdCB0aGlzIGFzIGFuIGludGVybGVhdmVkIHVwZGF0ZS4gVGhpcyBwYXR0ZXJuIGlzXG4gICAgLy8gYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nIGJ1dCB3ZSBoYXZlbid0IGZ1bGx5IGRlcHJlY2F0ZWQgaXQgeWV0LiBXZSBjYW5cbiAgICAvLyByZW1vdmUgb25jZSB0aGUgZGVmZXJSZW5kZXJQaGFzZVVwZGF0ZVRvTmV4dEJhdGNoIGZsYWcgaXMgZW5hYmxlZC5cbiAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KVxuICApO1xufSAvLyBVc2UgdGhpcyBmdW5jdGlvbiB0byBzY2hlZHVsZSBhIHRhc2sgZm9yIGEgcm9vdC4gVGhlcmUncyBvbmx5IG9uZSB0YXNrIHBlclxuLy8gcm9vdDsgaWYgYSB0YXNrIHdhcyBhbHJlYWR5IHNjaGVkdWxlZCwgd2UnbGwgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBwcmlvcml0eVxuLy8gb2YgdGhlIGV4aXN0aW5nIHRhc2sgaXMgdGhlIHNhbWUgYXMgdGhlIHByaW9yaXR5IG9mIHRoZSBuZXh0IGxldmVsIHRoYXQgdGhlXG4vLyByb290IGhhcyB3b3JrIG9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSB1cGRhdGUsIGFuZCByaWdodCBiZWZvcmVcbi8vIGV4aXRpbmcgYSB0YXNrLlxuXG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7IC8vIENoZWNrIGlmIGFueSBsYW5lcyBhcmUgYmVpbmcgc3RhcnZlZCBieSBvdGhlciB3b3JrLiBJZiBzbywgbWFyayB0aGVtIGFzXG4gIC8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG5cbiAgbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSk7IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG5cbiAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgICByZXR1cm47XG4gIH0gLy8gV2UgdXNlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGxhbmUgdG8gcmVwcmVzZW50IHRoZSBwcmlvcml0eSBvZiB0aGUgY2FsbGJhY2suXG5cblxuICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB0YXNrLiBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSBpdC5cblxuICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuXG4gIGlmIChleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPT09IG5ld0NhbGxiYWNrUHJpb3JpdHkgJiYgLy8gU3BlY2lhbCBjYXNlIHJlbGF0ZWQgdG8gYGFjdGAuIElmIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkIHRhc2sgaXMgYVxuICAvLyBTY2hlZHVsZXIgdGFzaywgcmF0aGVyIHRoYW4gYW4gYGFjdGAgdGFzaywgY2FuY2VsIGl0IGFuZCByZS1zY2hlZHVsZWRcbiAgLy8gb24gdGhlIGBhY3RgIHF1ZXVlLlxuICAhKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgIT09IG51bGwgJiYgZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUpKSB7XG4gICAge1xuICAgICAgLy8gSWYgd2UncmUgZ29pbmcgdG8gcmUtdXNlIGFuIGV4aXN0aW5nIHRhc2ssIGl0IG5lZWRzIHRvIGV4aXN0LlxuICAgICAgLy8gQXNzdW1lIHRoYXQgZGlzY3JldGUgdXBkYXRlIG1pY3JvdGFza3MgYXJlIG5vbi1jYW5jZWxsYWJsZSBhbmQgbnVsbC5cbiAgICAgIC8vIFRPRE86IFRlbXBvcmFyeSB1bnRpbCB3ZSBjb25maXJtIHRoaXMgd2FybmluZyBpcyBub3QgZmlyZWQuXG4gICAgICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgPT0gbnVsbCAmJiBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgIT09IFN5bmNMYW5lKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCBzY2hlZHVsZWQgY2FsbGJhY2sgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgcHJpb3JpdHkgaGFzbid0IGNoYW5nZWQuIFdlIGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgdGFzay4gRXhpdC5cblxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9IG51bGwpIHtcbiAgICAvLyBDYW5jZWwgdGhlIGV4aXN0aW5nIGNhbGxiYWNrLiBXZSdsbCBzY2hlZHVsZSBhIG5ldyBvbmUgYmVsb3cuXG4gICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gIH0gLy8gU2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG5cblxuICB2YXIgbmV3Q2FsbGJhY2tOb2RlO1xuXG4gIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBTeW5jTGFuZSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU3luYyBSZWFjdCBjYWxsYmFja3MgYXJlIHNjaGVkdWxlZCBvbiBhIHNwZWNpYWxcbiAgICAvLyBpbnRlcm5hbCBxdWV1ZVxuICAgIGlmIChyb290LnRhZyA9PT0gTGVnYWN5Um9vdCkge1xuICAgICAgaWYgKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmlzQmF0Y2hpbmdMZWdhY3kgIT09IG51bGwpIHtcbiAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrKHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c01pY3JvdGFza3MpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBxdWV1ZSBpbiBhIG1pY3JvdGFzay5cbiAgICAgIGlmICggUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEluc2lkZSBgYWN0YCwgdXNlIG91ciBpbnRlcm5hbCBgYWN0YCBxdWV1ZSBzbyB0aGF0IHRoZXNlIGdldCBmbHVzaGVkXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2NvcGUgZXZlbiB3aGVuIHVzaW5nIHRoZSBzeW5jIHZlcnNpb25cbiAgICAgICAgLy8gb2YgYGFjdGAuXG4gICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudC5wdXNoKGZsdXNoU3luY0NhbGxiYWNrcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gSW4gU2FmYXJpLCBhcHBlbmRpbmcgYW4gaWZyYW1lIGZvcmNlcyBtaWNyb3Rhc2tzIHRvIHJ1bi5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIyNDU5XG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBydW5uaW5nIGNhbGxiYWNrcyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlclxuICAgICAgICAgIC8vIG9yIGNvbW1pdCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgdGhhdC5cbiAgICAgICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgICAgICAvLyBJdCdzIG9ubHkgc2FmZSB0byBkbyB0aGlzIGNvbmRpdGlvbmFsbHkgYmVjYXVzZSB3ZSBhbHdheXNcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBwZW5kaW5nIHdvcmsgYmVmb3JlIHdlIGV4aXQgdGhlIHRhc2suXG4gICAgICAgICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCB0aGUgcXVldWUgaW4gYW4gSW1tZWRpYXRlIHRhc2suXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrcyk7XG4gICAgfVxuXG4gICAgbmV3Q2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbDtcblxuICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkobmV4dExhbmVzKSkge1xuICAgICAgY2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSWRsZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG5ld0NhbGxiYWNrTm9kZSA9IHNjaGVkdWxlQ2FsbGJhY2skMShzY2hlZHVsZXJQcmlvcml0eUxldmVsLCBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH1cblxuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICByb290LmNhbGxiYWNrTm9kZSA9IG5ld0NhbGxiYWNrTm9kZTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290LCBkaWRUaW1lb3V0KSB7XG4gIHtcbiAgICByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKTtcbiAgfSAvLyBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIGEgUmVhY3QgZXZlbnQsIHdlIGNhbiBjbGVhciB0aGUgY3VycmVudFxuICAvLyBldmVudCB0aW1lLiBUaGUgbmV4dCB1cGRhdGUgd2lsbCBjb21wdXRlIGEgbmV3IGV2ZW50IHRpbWUuXG5cblxuICBjdXJyZW50RXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG4gIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gTm9MYW5lcztcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfSAvLyBGbHVzaCBhbnkgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYmVmb3JlIGRlY2lkaW5nIHdoaWNoIGxhbmVzIHRvIHdvcmsgb24sXG4gIC8vIGluIGNhc2UgdGhleSBzY2hlZHVsZSBhZGRpdGlvbmFsIHdvcmsuXG5cblxuICB2YXIgb3JpZ2luYWxDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgdmFyIGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG5cbiAgaWYgKGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHBhc3NpdmUgZWZmZWN0IHBoYXNlIG1heSBoYXZlIGNhbmNlbGVkIHRoZSBjdXJyZW50IHRhc2suXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRhc2sgbm9kZSBmb3IgdGhpcyByb290IHdhcyBjaGFuZ2VkLlxuICAgIGlmIChyb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRhc2sgd2FzIGNhbmNlbGVkLiBFeGl0LiBXZSBkb24ndCBuZWVkIHRvIGNhbGxcbiAgICAgIC8vIGBlbnN1cmVSb290SXNTY2hlZHVsZWRgIGJlY2F1c2UgdGhlIGNoZWNrIGFib3ZlIGltcGxpZXMgZWl0aGVyIHRoYXRcbiAgICAgIC8vIHRoZXJlJ3MgYSBuZXcgdGFzaywgb3IgdGhhdCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG5cblxuICB2YXIgbGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBXZSBkaXNhYmxlIHRpbWUtc2xpY2luZyBpbiBzb21lIGNhc2VzOiBpZiB0aGUgd29yayBoYXMgYmVlbiBDUFUtYm91bmRcbiAgLy8gZm9yIHRvbyBsb25nIChcImV4cGlyZWRcIiB3b3JrLCB0byBwcmV2ZW50IHN0YXJ2YXRpb24pLCBvciB3ZSdyZSBpblxuICAvLyBzeW5jLXVwZGF0ZXMtYnktZGVmYXVsdCBtb2RlLlxuICAvLyBUT0RPOiBXZSBvbmx5IGNoZWNrIGBkaWRUaW1lb3V0YCBkZWZlbnNpdmVseSwgdG8gYWNjb3VudCBmb3IgYSBTY2hlZHVsZXJcbiAgLy8gYnVnIHdlJ3JlIHN0aWxsIGludmVzdGlnYXRpbmcuIE9uY2UgdGhlIGJ1ZyBpbiBTY2hlZHVsZXIgaXMgZml4ZWQsXG4gIC8vIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2UgdHJhY2sgZXhwaXJhdGlvbiBvdXJzZWx2ZXMuXG5cblxuICB2YXIgc2hvdWxkVGltZVNsaWNlID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSAmJiAhaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LCBsYW5lcykgJiYgKCAhZGlkVGltZW91dCk7XG4gIHZhciBleGl0U3RhdHVzID0gc2hvdWxkVGltZVNsaWNlID8gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIDogcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcykge1xuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsXG4gICAgICAvLyByZW5kZXIgc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGxcbiAgICAgIC8vIGluY2x1ZGVzIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlclxuICAgICAgLy8gdGhlIHNlY29uZCBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG4gICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICBleGl0U3RhdHVzID0gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgICAgdmFyIGZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgICAgIHRocm93IGZhdGFsRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSkge1xuICAgICAgLy8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcbiAgICAgIC8vIGNhc2VzIHdoZXJlIG5lZWQgdG8gZXhpdCB0aGUgY3VycmVudCByZW5kZXIgd2l0aG91dCBwcm9kdWNpbmcgYVxuICAgICAgLy8gY29uc2lzdGVudCB0cmVlIG9yIGNvbW1pdHRpbmcuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gZHVyaW5nIGEgY29uY3VycmVudCByZW5kZXIsIG5vdCBhIGRpc2NyZXRlIG9yXG4gICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGUuIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgY2hlY2tlZCBmb3IgdGhpcyB3aGVuIHdlXG4gICAgICAvLyB1bndvdW5kIHRoZSBzdGFjay5cbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmVuZGVyIGNvbXBsZXRlZC5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgcmVuZGVyIG1heSBoYXZlIHlpZWxkZWQgdG8gYSBjb25jdXJyZW50IGV2ZW50LCBhbmQgaWYgc28sXG4gICAgICAvLyBjb25maXJtIHRoYXQgYW55IG5ld2x5IHJlbmRlcmVkIHN0b3JlcyBhcmUgY29uc2lzdGVudC5cbiAgICAgIC8vIFRPRE86IEl0J3MgcG9zc2libGUgdGhhdCBldmVuIGEgY29uY3VycmVudCByZW5kZXIgbWF5IG5ldmVyIGhhdmUgeWllbGRlZFxuICAgICAgLy8gdG8gdGhlIG1haW4gdGhyZWFkLCBpZiBpdCB3YXMgZmFzdCBlbm91Z2gsIG9yIGlmIGl0IGV4cGlyZWQuIFdlIGNvdWxkXG4gICAgICAvLyBza2lwIHRoZSBjb25zaXN0ZW5jeSBjaGVjayBpbiB0aGF0IGNhc2UsIHRvby5cbiAgICAgIHZhciByZW5kZXJXYXNDb25jdXJyZW50ID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKTtcbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAocmVuZGVyV2FzQ29uY3VycmVudCAmJiAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgLy8gQSBzdG9yZSB3YXMgbXV0YXRlZCBpbiBhbiBpbnRlcmxlYXZlZCBldmVudC4gUmVuZGVyIGFnYWluLFxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5LCB0byBibG9jayBmdXJ0aGVyIG11dGF0aW9ucy5cbiAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTsgLy8gV2UgbmVlZCB0byBjaGVjayBhZ2FpbiBpZiBzb21ldGhpbmcgdGhyZXdcblxuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgX2Vycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG4gICAgICAgICAgaWYgKF9lcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgIGxhbmVzID0gX2Vycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBfZXJyb3JSZXRyeUxhbmVzKTsgLy8gV2UgYXNzdW1lIHRoZSB0cmVlIGlzIG5vdyBjb25zaXN0ZW50IGJlY2F1c2Ugd2UgZGlkbid0IHlpZWxkIHRvIGFueVxuICAgICAgICAgICAgLy8gY29uY3VycmVudCBldmVudHMuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgX2ZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgICAgICAgICB0aHJvdyBfZmF0YWxFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG4gICAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuXG4gIGlmIChyb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAvLyBUaGUgdGFzayBub2RlIHNjaGVkdWxlZCBmb3IgdGhpcyByb290IGlzIHRoZSBzYW1lIG9uZSB0aGF0J3NcbiAgICAvLyBjdXJyZW50bHkgZXhlY3V0ZWQuIE5lZWQgdG8gcmV0dXJuIGEgY29udGludWF0aW9uLlxuICAgIHJldHVybiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBlcnJvclJldHJ5TGFuZXMpIHtcbiAgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbiwgZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGxcbiAgLy8gYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG4gIC8vIEJlZm9yZSByZW5kZXJpbmcgYWdhaW4sIHNhdmUgdGhlIGVycm9ycyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LlxuICB2YXIgZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdCA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG5cbiAgaWYgKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpIHtcbiAgICAvLyBUaGUgc2hlbGwgZmFpbGVkIHRvIGh5ZHJhdGUuIFNldCBhIGZsYWcgdG8gZm9yY2UgYSBjbGllbnQgcmVuZGVyaW5nXG4gICAgLy8gZHVyaW5nIHRoZSBuZXh0IGF0dGVtcHQuIFRvIGRvIHRoaXMsIHdlIGNhbGwgcHJlcGFyZUZyZXNoU3RhY2sgbm93XG4gICAgLy8gdG8gY3JlYXRlIHRoZSByb290IHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoaXMgaXMgYSBiaXQgd2VpcmQgaW4gdGVybXNcbiAgICAvLyBvZiBmYWN0b3JpbmcsIGJlY2F1c2UgaXQgcmVsaWVzIG9uIHJlbmRlclJvb3RTeW5jIG5vdCBjYWxsaW5nXG4gICAgLy8gcHJlcGFyZUZyZXNoU3RhY2sgYWdhaW4gaW4gdGhlIGNhbGwgYmVsb3csIHdoaWNoIGhhcHBlbnMgYmVjYXVzZSB0aGVcbiAgICAvLyByb290IGFuZCBsYW5lcyBoYXZlbid0IGNoYW5nZWQuXG4gICAgLy9cbiAgICAvLyBUT0RPOiBJIHRoaW5rIHdoYXQgd2Ugc2hvdWxkIGRvIGlzIHNldCBGb3JjZUNsaWVudFJlbmRlciBpbnNpZGVcbiAgICAvLyB0aHJvd0V4Y2VwdGlvbiwgbGlrZSB3ZSBkbyBmb3IgbmVzdGVkIFN1c3BlbnNlIGJvdW5kYXJpZXMuIFRoZSByZWFzb25cbiAgICAvLyBpdCdzIGhlcmUgaW5zdGVhZCBpcyBzbyB3ZSBjYW4gc3dpdGNoIHRvIHRoZSBzeW5jaHJvbm91cyB3b3JrIGxvb3AsIHRvby5cbiAgICAvLyBTb21ldGhpbmcgdG8gY29uc2lkZXIgZm9yIGEgZnV0dXJlIHJlZmFjdG9yLlxuICAgIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuICAgIHJvb3RXb3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcblxuICAgIHtcbiAgICAgIGVycm9ySHlkcmF0aW5nQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBmaW5pc2hlZCByZW5kZXJpbmcgb24gcmV0cnlcbiAgICAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIGZhaWxlZCBmaXJzdCBhdHRlbXB0IGhhdmUgYmVlbiByZWNvdmVyZWQuIEFkZFxuICAgIC8vIHRoZW0gdG8gdGhlIGNvbGxlY3Rpb24gb2YgcmVjb3ZlcmFibGUgZXJyb3JzLiBXZSdsbCBsb2cgdGhlbSBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UuXG4gICAgdmFyIGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0ID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnNGcm9tRmlyc3RBdHRlbXB0OyAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIHNlY29uZCBhdHRlbXB0IHNob3VsZCBiZSBxdWV1ZWQgYWZ0ZXIgdGhlIGVycm9yc1xuICAgIC8vIGZyb20gdGhlIGZpcnN0IGF0dGVtcHQsIHRvIHByZXNlcnZlIHRoZSBjYXVzYWwgc2VxdWVuY2UuXG5cbiAgICBpZiAoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQgIT09IG51bGwpIHtcbiAgICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleGl0U3RhdHVzO1xufVxuXG5mdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9ycztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgbGFuZXMpIHtcbiAgc3dpdGNoIChleGl0U3RhdHVzKSB7XG4gICAgY2FzZSBSb290SW5Qcm9ncmVzczpcbiAgICBjYXNlIFJvb3RGYXRhbEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIC8vIEZsb3cga25vd3MgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnMgaWYgSSBhZGQgYSBicmVha1xuICAgIC8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcbiAgICAvLyBpZiBJIGRvLiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJldHJ5IHRoaXMgdHJlZS4gSWYgd2UgcmVhY2hlZFxuICAgICAgICAvLyB0aGlzIHBvaW50LCBpdCBlcnJvcmVkIGFnYWluLiBDb21taXQgaXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdFN1c3BlbmRlZDpcbiAgICAgIHtcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7IC8vIFdlIGhhdmUgYW4gYWNjZXB0YWJsZSBsb2FkaW5nIHN0YXRlLiBXZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgd2VcbiAgICAgICAgLy8gc2hvdWxkIGltbWVkaWF0ZWx5IGNvbW1pdCBpdCBvciB3YWl0IGEgYml0LlxuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSAmJiAvLyBkbyBub3QgZGVsYXkgaWYgd2UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlXG4gICAgICAgICFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSkge1xuICAgICAgICAgIC8vIFRoaXMgcmVuZGVyIG9ubHkgaW5jbHVkZWQgcmV0cmllcywgbm8gdXBkYXRlcy4gVGhyb3R0bGUgY29tbWl0dGluZ1xuICAgICAgICAgIC8vIHJldHJpZXMgc28gdGhhdCB3ZSBkb24ndCBzaG93IHRvbyBtYW55IGxvYWRpbmcgc3RhdGVzIHRvbyBxdWlja2x5LlxuICAgICAgICAgIHZhciBtc1VudGlsVGltZW91dCA9IGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgKyBGQUxMQkFDS19USFJPVFRMRV9NUyAtIG5vdyQxKCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3RcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG4gICAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICAgIG1hcmtSb290UGluZ2VkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cblxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyksIG1zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgd29yayBleHBpcmVkLiBDb21taXQgaW1tZWRpYXRlbHkuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgdHJhbnNpdGlvbiwgc28gd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCBjb21taXR0aW5nIGFcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgLy8gdW50aWwgd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB0cmFuc2l0aW9uLCBidXQgd2UgZGlkIHRyaWdnZXIgYW4gYXZvaWRlZCBzdGF0ZS5cbiAgICAgICAgICAvLyBTY2hlZHVsZSBhIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgdXNpbmcgdGhlIEp1c3RcbiAgICAgICAgICAvLyBOb3RpY2VhYmxlIERpZmZlcmVuY2UuXG4gICAgICAgICAgLy8gVE9ETzogSXMgdGhlIEpORCBvcHRpbWl6YXRpb24gd29ydGggdGhlIGFkZGVkIGNvbXBsZXhpdHk/IElmIHRoaXMgaXNcbiAgICAgICAgICAvLyB0aGUgb25seSByZWFzb24gd2UgdHJhY2sgdGhlIGV2ZW50IHRpbWUsIHRoZW4gcHJvYmFibHkgbm90LlxuICAgICAgICAgIC8vIENvbnNpZGVyIHJlbW92aW5nLlxuICAgICAgICAgIHZhciBtb3N0UmVjZW50RXZlbnRUaW1lID0gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcyk7XG4gICAgICAgICAgdmFyIGV2ZW50VGltZU1zID0gbW9zdFJlY2VudEV2ZW50VGltZTtcbiAgICAgICAgICB2YXIgdGltZUVsYXBzZWRNcyA9IG5vdyQxKCkgLSBldmVudFRpbWVNcztcblxuICAgICAgICAgIHZhciBfbXNVbnRpbFRpbWVvdXQgPSBqbmQodGltZUVsYXBzZWRNcykgLSB0aW1lRWxhcHNlZE1zOyAvLyBEb24ndCBib3RoZXIgd2l0aCBhIHZlcnkgc2hvcnQgc3VzcGVuc2UgdGltZS5cblxuXG4gICAgICAgICAgaWYgKF9tc1VudGlsVGltZW91dCA+IDEwKSB7XG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICAgIC8vIHRvIGFycml2ZS5cbiAgICAgICAgICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChjb21taXRSb290LmJpbmQobnVsbCwgcm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMpLCBfbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbW1pdCB0aGUgcGxhY2Vob2xkZXIuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcm9vdCBleGl0IHN0YXR1cy4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFNlYXJjaCB0aGUgcmVuZGVyZWQgdHJlZSBmb3IgZXh0ZXJuYWwgc3RvcmUgcmVhZHMsIGFuZCBjaGVjayB3aGV0aGVyIHRoZVxuICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkIGluIGEgY29uY3VycmVudCBldmVudC4gSW50ZW50aW9uYWxseSB1c2luZyBhbiBpdGVyYXRpdmVcbiAgLy8gbG9vcCBpbnN0ZWFkIG9mIHJlY3Vyc2lvbiBzbyB3ZSBjYW4gZXhpdCBlYXJseS5cbiAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS5mbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IG5vZGUudXBkYXRlUXVldWU7XG5cbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gdXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgICAgIGlmIChjaGVja3MgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gY2hlY2tzW2ldO1xuICAgICAgICAgICAgdmFyIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRWYWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIHJlbmRlcmVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gaW5jb25zaXN0ZW50IHN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYGdldFNuYXBzaG90YCB0aHJvd3MsIHJldHVybiBgZmFsc2VgLiBUaGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgICAgICAgICAgLy8gYSByZS1yZW5kZXIsIGFuZCB0aGUgZXJyb3Igd2lsbCBiZSByZXRocm93biBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9IC8vIEZsb3cgZG9lc24ndCBrbm93IHRoaXMgaXMgdW5yZWFjaGFibGUsIGJ1dCBlc2xpbnQgZG9lc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIC8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbiAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyk7XG4gIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgZ29cbi8vIHRocm91Z2ggU2NoZWR1bGVyXG5cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QpIHtcbiAge1xuICAgIHN5bmNOZXN0ZWRVcGRhdGVGbGFnKCk7XG4gIH1cblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgdmFyIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIE5vTGFuZXMpO1xuXG4gIGlmICghaW5jbHVkZXNTb21lTGFuZShsYW5lcywgU3luY0xhbmUpKSB7XG4gICAgLy8gVGhlcmUncyBubyByZW1haW5pbmcgc3luYyB3b3JrIGxlZnQuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG5cbiAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgIC8vIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsIGluY2x1ZGVzXG4gICAgLy8gYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuICAgIGlmIChlcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuICAvLyB3aWxsIGNvbW1pdCBpdCBldmVuIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBsYW5lcykge1xuICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBtZXJnZUxhbmVzKGxhbmVzLCBTeW5jTGFuZSkpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblxuICB0cnkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5KTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBJZiB0aGVyZSB3ZXJlIGxlZ2FjeSBzeW5jIHVwZGF0ZXMsIGZsdXNoIHRoZW0gYXQgdGhlIGVuZCBvZiB0aGUgb3V0ZXJcbiAgICAvLyBtb3N0IGJhdGNoZWRVcGRhdGVzLWxpa2UgbWV0aG9kLlxuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyhmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgfVxuICB9XG59IC8vIE92ZXJsb2FkIHRoZSBkZWZpbml0aW9uIHRvIHRoZSB0d28gdmFsaWQgc2lnbmF0dXJlcy5cbi8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgZmx1c2ggcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgLy8gbmV4dCBldmVudCwgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIG9uZS5cbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsICYmIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLnRhZyA9PT0gTGVnYWN5Um9vdCAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuXG4gICAgaWYgKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgIC8vIHRoZSBzdGFjay5cblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNBbHJlYWR5UmVuZGVyaW5nKCkge1xuICAvLyBVc2VkIGJ5IHRoZSByZW5kZXJlciB0byBwcmludCBhIHdhcm5pbmcgaWYgY2VydGFpbiBBUElzIGFyZSBjYWxsZWQgZnJvbVxuICAvLyB0aGUgd3JvbmcgY29udGV4dC5cbiAgcmV0dXJuICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQ7XG59XG5mdW5jdGlvbiBmbHVzaENvbnRyb2xsZWQoZm4pIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gIHRyeSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hSZW5kZXJMYW5lcyhmaWJlciwgbGFuZXMpIHtcbiAgcHVzaChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIHN1YnRyZWVSZW5kZXJMYW5lcywgZmliZXIpO1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBtZXJnZUxhbmVzKHN1YnRyZWVSZW5kZXJMYW5lcywgbGFuZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiBwb3BSZW5kZXJMYW5lcyhmaWJlcikge1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcbiAgcG9wKHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAvLyBUaGUgcm9vdCBwcmV2aW91cyBzdXNwZW5kZWQgYW5kIHNjaGVkdWxlZCBhIHRpbWVvdXQgdG8gY29tbWl0IGEgZmFsbGJhY2tcbiAgICAvLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cbiAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7IC8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5cbiAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgd29ya0luUHJvZ3Jlc3MgPSByb290V29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IGxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDtcbiAgZW5xdWV1ZUludGVybGVhdmVkVXBkYXRlcygpO1xuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gIH1cblxuICByZXR1cm4gcm9vdFdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSkge1xuICBkbyB7XG4gICAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICB0cnkge1xuICAgICAgLy8gUmVzZXQgbW9kdWxlLWxldmVsIHN0YXRlIHRoYXQgd2FzIHNldCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTtcbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7IC8vIFRPRE86IEkgZm91bmQgYW5kIGFkZGVkIHRoaXMgbWlzc2luZyBsaW5lIHdoaWxlIGludmVzdGlnYXRpbmcgYVxuICAgICAgLy8gc2VwYXJhdGUgaXNzdWUuIFdyaXRlIGEgcmVncmVzc2lvbiB0ZXN0IHVzaW5nIHN0cmluZyByZWZzLlxuXG4gICAgICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICBpZiAoZXJyb3JlZFdvcmsgPT09IG51bGwgfHwgZXJyb3JlZFdvcmsucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIHRvIGJlIHdvcmtpbmcgb24gYSBub24tcm9vdCBmaWJlci4gVGhpcyBpcyBhIGZhdGFsIGVycm9yXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBhbmNlc3RvciB0aGF0IGNhbiBoYW5kbGUgaXQ7IHRoZSByb290IGlzXG4gICAgICAgIC8vIHN1cHBvc2VkIHRvIGNhcHR1cmUgYWxsIGVycm9ycyB0aGF0IHdlcmVuJ3QgY2F1Z2h0IGJ5IGFuIGVycm9yXG4gICAgICAgIC8vIGJvdW5kYXJ5LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvciA9IHRocm93blZhbHVlOyAvLyBTZXQgYHdvcmtJblByb2dyZXNzYCB0byBudWxsLiBUaGlzIHJlcHJlc2VudHMgYWR2YW5jaW5nIHRvIHRoZSBuZXh0XG4gICAgICAgIC8vIHNpYmxpbmcsIG9yIHRoZSBwYXJlbnQgaWYgdGhlcmUgYXJlIG5vIHNpYmxpbmdzLiBCdXQgc2luY2UgdGhlIHJvb3RcbiAgICAgICAgLy8gaGFzIG5vIHNpYmxpbmdzIG5vciBhIHBhcmVudCwgd2Ugc2V0IGl0IHRvIG51bGwuIFVzdWFsbHkgdGhpcyBpc1xuICAgICAgICAvLyBoYW5kbGVkIGJ5IGBjb21wbGV0ZVVuaXRPZldvcmtgIG9yIGB1bndpbmRXb3JrYCwgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgbm90IGNhbGxpbmcgdGhvc2UsIHdlIG5lZWQgc2V0IGl0IGhlcmUuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGNhbGxpbmcgYHVud2luZFdvcmtgIHRvIHBvcCB0aGUgY29udGV4dHMuXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIGVycm9yZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGJlZm9yZSBhbiBlcnJvciB3YXMgdGhyb3duLiBUaGlzXG4gICAgICAgIC8vIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhXG4gICAgICAgIC8vIHN1c3BlbmRlZCByZW5kZXIuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZXJyb3JlZFdvcmssIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyKSB7XG4gICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG5cbiAgICAgICAgaWYgKHRocm93blZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0aHJvd25WYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRocm93blZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgd2FrZWFibGUgPSB0aHJvd25WYWx1ZTtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50U3VzcGVuZGVkKGVycm9yZWRXb3JrLCB3YWtlYWJsZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtDb21wb25lbnRFcnJvcmVkKGVycm9yZWRXb3JrLCB0aHJvd25WYWx1ZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIGVycm9yZWRXb3JrLnJldHVybiwgZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO1xuICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxuICAgICAgdGhyb3duVmFsdWUgPSB5ZXRBbm90aGVyVGhyb3duVmFsdWU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGVycm9yZWRXb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgIHJldHVybjtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpIHtcbiAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdyQxKCk7XG59XG5mdW5jdGlvbiBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGxhbmUpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gbWVyZ2VMYW5lcyhsYW5lLCB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZCgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gIH0gLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHVwZGF0ZXMgdGhhdCB3ZSBza2lwcGVkIHRyZWUgdGhhdCBtaWdodCBoYXZlIHVuYmxvY2tlZFxuICAvLyB0aGlzIHJlbmRlci5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwgJiYgKGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKSB8fCBpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKSkpIHtcbiAgICAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbiAgICAvLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbiAgICAvLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcihlcnJvcikge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZDtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxufSAvLyBDYWxsZWQgZHVyaW5nIHJlbmRlciB0byBkZXRlcm1pbmUgaWYgYW55dGhpbmcgaGFzIHN1c3BlbmRlZC5cbi8vIFJldHVybnMgZmFsc2UgaWYgd2UncmUgbm90IHN1cmUuXG5cbmZ1bmN0aW9uIHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGVycm9yZWQgb3IgY29tcGxldGVkLCB3ZSBjYW4ndCByZWFsbHkgYmUgc3VyZSxcbiAgLy8gc28gdGhvc2UgYXJlIGZhbHNlLlxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN5bmMgcmVuZGVyLCBzbyB3ZSBzaG91bGQgaGF2ZSBmaW5pc2hlZCB0aGUgd2hvbGUgdHJlZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSAnICsgJ2J1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbn0gLy8gVGhlIHdvcmsgbG9vcCBpcyBhbiBleHRyZW1lbHkgaG90IHBhdGguIFRlbGwgQ2xvc3VyZSBub3QgdG8gaW5saW5lIGl0LlxuXG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAvLyBBbHJlYWR5IHRpbWVkIG91dCwgc28gcGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZC5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gU3RpbGwgd29yayByZW1haW5pbmcuXG4gICAge1xuICAgICAgbWFya1JlbmRlcllpZWxkZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUm9vdEluUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcGxldGVkIHRoZSB0cmVlLlxuICAgIHtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICB9XG59XG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHNldEN1cnJlbnRGaWJlcih1bml0T2ZXb3JrKTtcbiAgdmFyIG5leHQ7XG5cbiAgaWYgKCAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrJDEoY3VycmVudCwgdW5pdE9mV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG4gIC8vIHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlIHBhcmVudCBmaWJlci5cbiAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuXG4gIGRvIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBjb21wbGV0ZWRXb3JrLnJldHVybjsgLy8gQ2hlY2sgaWYgdGhlIHdvcmsgY29tcGxldGVkIG9yIGlmIHNvbWV0aGluZyB0aHJldy5cblxuICAgIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIEluY29tcGxldGUpID09PSBOb0ZsYWdzKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIoY29tcGxldGVkV29yayk7XG4gICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7IC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrKTsgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBsYW5lcy5cblxuXG4gICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3RcbiAgICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgICAgX25leHQuZmxhZ3MgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gX25leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSByZW5kZXIgZHVyYXRpb24gZm9yIHRoZSBmaWJlciB0aGF0IGVycm9yZWQuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpOyAvLyBJbmNsdWRlIHRoZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gZmFpbGVkIGNoaWxkcmVuIGJlZm9yZSBjb250aW51aW5nLlxuXG4gICAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBzdWJ0cmVlIGZsYWdzLlxuICAgICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgICByZXR1cm5GaWJlci5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgdW53b3VuZCBhbGwgdGhlIHdheSB0byB0aGUgcm9vdC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmdGaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcblxuXG4gICAgY29tcGxldGVkV29yayA9IHJldHVybkZpYmVyOyAvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gIH0gd2hpbGUgKGNvbXBsZXRlZFdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCByZWNvdmVyYWJsZUVycm9ycykge1xuICAvLyBUT0RPOiBUaGlzIG5vIGxvbmdlciBtYWtlcyBhbnkgc2Vuc2UuIFdlIGFscmVhZHkgd3JhcCB0aGUgbXV0YXRpb24gYW5kXG4gIC8vIGxheW91dCBwaGFzZXMuIFNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZS5cbiAgdmFyIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblxuICB0cnkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgY29tbWl0Um9vdEltcGwocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3RJbXBsKHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIGRvIHtcbiAgICAvLyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBjYWxsIGBmbHVzaFN5bmNVcGRhdGVRdWV1ZWAgYXQgdGhlIGVuZCwgd2hpY2hcbiAgICAvLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzaXZlIGVmZmVjdHMuIFNvIHdlIG5lZWQgdG8ga2VlcCBmbHVzaGluZyBpbiBhIGxvb3AgdW50aWwgdGhlcmUgYXJlXG4gICAgLy8gbm8gbW9yZSBwZW5kaW5nIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBmbHVzaCBzeW5jaHJvbm91cyB3b3JrIGF0IHRoZSBlbmQsIHRvIGF2b2lkIGZhY3RvcmluZyBoYXphcmRzIGxpa2UgdGhpcy5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gd2hpbGUgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKTtcblxuICBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKTtcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgdmFyIGxhbmVzID0gcm9vdC5maW5pc2hlZExhbmVzO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBpZiAoZmluaXNoZWRXb3JrID09PSBudWxsKSB7XG5cbiAgICB7XG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgICBlcnJvcigncm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgJyArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5ICcgKyAnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9IC8vIGNvbW1pdFJvb3QgbmV2ZXIgcmV0dXJucyBhIGNvbnRpbnVhdGlvbjsgaXQgYWx3YXlzIGZpbmlzaGVzIHN5bmNocm9ub3VzbHkuXG4gIC8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxuXG5cbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7IC8vIFVwZGF0ZSB0aGUgZmlyc3QgYW5kIGxhc3QgcGVuZGluZyB0aW1lcyBvbiB0aGlzIHJvb3QuIFRoZSBuZXcgZmlyc3RcbiAgLy8gcGVuZGluZyB0aW1lIGlzIHdoYXRldmVyIGlzIGxlZnQgb24gdGhlIHJvb3QgZmliZXIuXG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzID0gbWVyZ2VMYW5lcyhmaW5pc2hlZFdvcmsubGFuZXMsIGZpbmlzaGVkV29yay5jaGlsZExhbmVzKTtcbiAgbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcyk7XG5cbiAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFdlIGNhbiByZXNldCB0aGVzZSBub3cgdGhhdCB0aGV5IGFyZSBmaW5pc2hlZC5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvIHByb2Nlc3MgdGhlbS5cbiAgLy8gRG8gdGhpcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gaXQgaXMgcXVldWVkIGJlZm9yZSBhbnl0aGluZyBlbHNlIHRoYXRcbiAgLy8gbWlnaHQgZ2V0IHNjaGVkdWxlZCBpbiB0aGUgY29tbWl0IHBoYXNlLiAoU2VlICMxNjcxNC4pXG4gIC8vIFRPRE86IERlbGV0ZSBhbGwgb3RoZXIgcGxhY2VzIHRoYXQgc2NoZWR1bGUgdGhlIHBhc3NpdmUgZWZmZWN0IGNhbGxiYWNrXG4gIC8vIFRoZXkncmUgcmVkdW5kYW50LlxuXG5cbiAgaWYgKChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzIHx8IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpOyAvLyBUaGlzIHJlbmRlciB0cmlnZ2VyZWQgcGFzc2l2ZSBlZmZlY3RzOiByZWxlYXNlIHRoZSByb290IGNhY2hlIHBvb2xcbiAgICAgICAgLy8gKmFmdGVyKiBwYXNzaXZlIGVmZmVjdHMgZmlyZSB0byBhdm9pZCBmcmVlaW5nIGEgY2FjaGUgcG9vbCB0aGF0IG1heVxuICAgICAgICAvLyBiZSByZWZlcmVuY2VkIGJ5IGEgbm9kZSBpbiB0aGUgdHJlZSAoSG9zdFJvb3QsIENhY2hlIGJvdW5kYXJ5IGV0YylcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IGVmZmVjdHMgaW4gdGhlIHdob2xlIHRyZWUuXG4gIC8vIFRPRE86IFRoaXMgaXMgbGVmdCBvdmVyIGZyb20gdGhlIGVmZmVjdCBsaXN0IGltcGxlbWVudGF0aW9uLCB3aGVyZSB3ZSBoYWRcbiAgLy8gdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYGZpcnN0RWZmZWN0YCB0byBzYXRpc2Z5IEZsb3cuIEkgdGhpbmsgdGhlXG4gIC8vIG9ubHkgb3RoZXIgcmVhc29uIHRoaXMgb3B0aW1pemF0aW9uIGV4aXN0cyBpcyBiZWNhdXNlIGl0IGFmZmVjdHMgcHJvZmlsaW5nLlxuICAvLyBSZWNvbnNpZGVyIHdoZXRoZXIgdGhpcyBpcyBuZWNlc3NhcnkuXG5cblxuICB2YXIgc3VidHJlZUhhc0VmZmVjdHMgPSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIChCZWZvcmVNdXRhdGlvbk1hc2sgfCBNdXRhdGlvbk1hc2sgfCBMYXlvdXRNYXNrIHwgUGFzc2l2ZU1hc2spKSAhPT0gTm9GbGFncztcbiAgdmFyIHJvb3RIYXNFZmZlY3QgPSAoZmluaXNoZWRXb3JrLmZsYWdzICYgKEJlZm9yZU11dGF0aW9uTWFzayB8IE11dGF0aW9uTWFzayB8IExheW91dE1hc2sgfCBQYXNzaXZlTWFzaykpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChzdWJ0cmVlSGFzRWZmZWN0cyB8fCByb290SGFzRWZmZWN0KSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDsgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3NcbiAgICAvLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuICAgIC8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4gICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbiAgICAvLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbiAgICAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG5cbiAgICB2YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cblxuXG4gICAgY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBsYXlvdXQgcGhhc2UsIHNvIHRoYXQgdGhlIGZpbmlzaGVkXG4gICAgLy8gd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuXG4gICAgY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgICAvLyBvcHBvcnR1bml0eSB0byBwYWludC5cblxuXG4gICAgcmVxdWVzdFBhaW50KCk7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBSZXNldCB0aGUgcHJpb3JpdHkgdG8gdGhlIHByZXZpb3VzIG5vbi1zeW5jIHZhbHVlLlxuXG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGVmZmVjdHMuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuICAgIC8vIG5vIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gcmVwb3J0IHRoaXMuXG5cbiAgICB7XG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPSByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cztcblxuICBpZiAocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3RcbiAgICAvLyBzY2hlZHVsZSBhIGNhbGxiYWNrIHVudGlsIGFmdGVyIGZsdXNoaW5nIGxheW91dCB3b3JrLlxuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290O1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gbGFuZXM7XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuICAvLyBUT0RPOiBUaGlzIGlzIHBhcnQgb2YgdGhlIGBjb21wb25lbnREaWRDYXRjaGAgaW1wbGVtZW50YXRpb24uIEl0cyBwdXJwb3NlXG4gIC8vIGlzIHRvIGRldGVjdCB3aGV0aGVyIHNvbWV0aGluZyBtaWdodCBoYXZlIGNhbGxlZCBzZXRTdGF0ZSBpbnNpZGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYC4gVGhlIG1lY2hhbmlzbSBpcyBrbm93biB0byBiZSBmbGF3ZWQgYmVjYXVzZSBgc2V0U3RhdGVgXG4gIC8vIGluc2lkZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGlzIGl0c2VsZiBmbGF3ZWQg4oCUIHRoYXQncyB3aHkgd2UgcmVjb21tZW5kXG4gIC8vIGBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3JgIGluc3RlYWQuIEhvd2V2ZXIsIGl0IGNvdWxkIGJlIGltcHJvdmVkIGJ5XG4gIC8vIGNoZWNraW5nIGlmIHJlbWFpbmluZ0xhbmVzIGluY2x1ZGVzIFN5bmMgd29yaywgaW5zdGVhZCBvZiB3aGV0aGVyIHRoZXJlJ3NcbiAgLy8gYW55IHdvcmsgcmVtYWluaW5nIGF0IGFsbCAod2hpY2ggd291bGQgYWxzbyBpbmNsdWRlIHN0dWZmIGxpa2UgU3VzcGVuc2VcbiAgLy8gcmV0cmllcyBvciB0cmFuc2l0aW9ucykuIEl0J3MgYmVlbiBsaWtlIHRoaXMgZm9yIGEgd2hpbGUsIHRob3VnaCwgc28gZml4aW5nXG4gIC8vIGl0IHByb2JhYmx5IGlzbid0IHRoYXQgdXJnZW50LlxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG4gICAgLy8gZXJyb3IgYm91bmRhcmllcy5cbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKCFyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QkMSgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93JDEoKSk7XG5cbiAgaWYgKHJlY292ZXJhYmxlRXJyb3JzICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUgd2VyZSBlcnJvcnMgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgcmVjb3ZlcmVkIGZyb20gdGhlbSB3aXRob3V0XG4gICAgLy8gbmVlZGluZyB0byBzdXJmYWNlIGl0IHRvIHRoZSBVSS4gV2UgbG9nIHRoZW0gaGVyZS5cbiAgICB2YXIgb25SZWNvdmVyYWJsZUVycm9yID0gcm9vdC5vblJlY292ZXJhYmxlRXJyb3I7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVjb3ZlcmFibGVFcnJvciA9IHJlY292ZXJhYmxlRXJyb3JzW2ldO1xuICAgICAgb25SZWNvdmVyYWJsZUVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciQxID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3IkMTtcbiAgfSAvLyBJZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgcmVuZGVyLCBmbHVzaCB0aGVtXG4gIC8vIHN5bmNocm9ub3VzbHkgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0YXNrIHNvIHRoYXQgdGhlIHJlc3VsdCBpc1xuICAvLyBpbW1lZGlhdGVseSBvYnNlcnZhYmxlLiBPdGhlcndpc2UsIHdlIGFzc3VtZSB0aGF0IHRoZXkgYXJlIG5vdFxuICAvLyBvcmRlci1kZXBlbmRlbnQgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIG9ic2VydmVkIGJ5IGV4dGVybmFsIHN5c3RlbXMsIHNvIHdlXG4gIC8vIGNhbiB3YWl0IHVudGlsIGFmdGVyIHBhaW50LlxuICAvLyBUT0RPOiBXZSBjYW4gb3B0aW1pemUgdGhpcyBieSBub3Qgc2NoZWR1bGluZyB0aGUgY2FsbGJhY2sgZWFybGllci4gU2luY2Ugd2VcbiAgLy8gY3VycmVudGx5IHNjaGVkdWxlIHRoZSBjYWxsYmFjayBpbiBtdWx0aXBsZSBwbGFjZXMsIHdpbGwgd2FpdCB1bnRpbCB0aG9zZVxuICAvLyBhcmUgY29uc29saWRhdGVkLlxuXG5cbiAgaWYgKGluY2x1ZGVzU29tZUxhbmUocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMsIFN5bmNMYW5lKSAmJiByb290LnRhZyAhPT0gTGVnYWN5Um9vdCkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGEgcGFzc2l2ZSBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzLCBTeW5jTGFuZSkpIHtcbiAgICB7XG4gICAgICBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCk7XG4gICAgfSAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4gICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cblxuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9IC8vIElmIGxheW91dCB3b3JrIHdhcyBzY2hlZHVsZWQsIGZsdXNoIGl0IG5vdy5cblxuXG4gIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gIC8vIFJldHVybnMgd2hldGhlciBwYXNzaXZlIGVmZmVjdHMgd2VyZSBmbHVzaGVkLlxuICAvLyBUT0RPOiBDb21iaW5lIHRoaXMgY2hlY2sgd2l0aCB0aGUgb25lIGluIGZsdXNoUGFzc2l2ZUVGZmVjdHNJbXBsLiBXZSBzaG91bGRcbiAgLy8gcHJvYmFibHkganVzdCBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zLiBJIGJlbGlldmUgdGhleSB3ZXJlIG9ubHkgc2VwYXJhdGVcbiAgLy8gaW4gdGhlIGZpcnN0IHBsYWNlIGJlY2F1c2Ugd2UgdXNlZCB0byB3cmFwIGl0IHdpdGhcbiAgLy8gYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLCB3aGljaCBhY2NlcHRzIGEgZnVuY3Rpb24uIEJ1dCBub3cgd2UgdHJhY2sgdGhlXG4gIC8vIHByaW9yaXR5IHdpdGhpbiBSZWFjdCBpdHNlbGYsIHNvIHdlIGNhbiBtdXRhdGUgdGhlIHZhcmlhYmxlIGRpcmVjdGx5LlxuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwpIHtcbiAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyk7XG4gICAgdmFyIHByaW9yaXR5ID0gbG93ZXJFdmVudFByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5LCByZW5kZXJQcmlvcml0eSk7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgICB0cnkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICByZXR1cm4gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247IC8vIE9uY2UgcGFzc2l2ZSBlZmZlY3RzIGhhdmUgcnVuIGZvciB0aGUgdHJlZSAtIGdpdmluZyBjb21wb25lbnRzIGFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaWJlcikge1xuICB7XG4gICAgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMucHVzaChmaWJlcik7XG5cbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDsgLy8gVE9ETzogVGhpcyBpcyBzb21ldGltZXMgb3V0IG9mIHN5bmMgd2l0aCByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy5cbiAgLy8gRmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gSXQncyBub3QgY2F1c2luZyBhbnkga25vd24gaXNzdWVzIChwcm9iYWJseVxuICAvLyBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBwcm9maWxpbmcpLCBidXQgaXQncyBhIHJlZmFjdG9yIGhhemFyZC5cblxuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKHJvb3QuY3VycmVudCk7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgcm9vdC5jdXJyZW50KTsgLy8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG5cbiAge1xuICAgIHZhciBwcm9maWxlckVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cztcbiAgICBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9maWxlckVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfZmliZXIgPSBwcm9maWxlckVmZmVjdHNbaV07XG4gICAgICBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKHJvb3QsIF9maWJlcik7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgfVxuXG4gIHtcbiAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCB0cnVlKTtcbiAgfVxuXG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7IC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cblxuICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCA/IDAgOiBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgKyAxOyAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuICBvblBvc3RDb21taXRSb290KHJvb3QpO1xuXG4gIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gcm9vdC5jdXJyZW50LnN0YXRlTm9kZTtcbiAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gIGlmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9PT0gbnVsbCkge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbaW5zdGFuY2VdKTtcbiAgfSBlbHNlIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQoaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcihlcnJvcikge1xuICBpZiAoIWhhc1VuY2F1Z2h0RXJyb3IpIHtcbiAgICBoYXNVbmNhdWdodEVycm9yID0gdHJ1ZTtcbiAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG52YXIgb25VbmNhdWdodEVycm9yID0gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yO1xuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciwgc291cmNlRmliZXIpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gIGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCB1cGRhdGUpO1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHJvb3RGaWJlciwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lLCBldmVudFRpbWUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKHNvdXJjZUZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciQxKSB7XG4gIGlmIChzb3VyY2VGaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuICAgIC8vIGl0c2VsZiBzaG91bGQgY2FwdHVyZSBpdC5cbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChzb3VyY2VGaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvcjtcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChmaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGN0b3IgPSBmaWJlci50eXBlO1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUoZXJyb3IkMSwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICAvLyBUT0RPOiBVbnRpbCB3ZSByZS1sYW5kIHNraXBVbm1vdW50ZWRCb3VuZGFyaWVzIChzZWUgIzIwMTQ3KSwgdGhpcyB3YXJuaW5nXG4gICAgLy8gd2lsbCBmaXJlIGZvciBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGJ5IGRlc3Ryb3kgZnVuY3Rpb25zIGluc2lkZSBkZWxldGVkXG4gICAgLy8gdHJlZXMuIFdoYXQgaXQgc2hvdWxkIGluc3RlYWQgZG8gaXMgcHJvcGFnYXRlIHRoZSBlcnJvciB0byB0aGUgcGFyZW50IG9mXG4gICAgLy8gdGhlIGRlbGV0ZWQgdHJlZS4gSW4gdGhlIG1lYW50aW1lLCBkbyBub3QgYWRkIHRoaXMgd2FybmluZyB0byB0aGVcbiAgICAvLyBhbGxvd2xpc3Q7IHRoaXMgaXMgb25seSBmb3Igb3VyIGludGVybmFsIHVzZS5cbiAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yICcgKyAnaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIExpa2VseSAnICsgJ2NhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuICcgKyAnYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuJyArICdFcnJvciBtZXNzYWdlOlxcblxcbiVzJywgZXJyb3IkMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG5cbiAgaWYgKHBpbmdDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpO1xuICB3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVihyb290KTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93JDEoKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUykge1xuICAgICAgLy8gUmVzdGFydCBmcm9tIHRoZSByb290LlxuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbiAgICAgIC8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICB9XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbn1cblxuZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG4gIC8vIHByZXZpb3VzbHkgd2FzIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0XG4gIC8vIHN1c3BlbmRlZCBpdCBoYXMgcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzXG4gIC8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGxhbmVzLlxuICBpZiAocmV0cnlMYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBUT0RPOiBBc3NpZ24gdGhpcyB0byBgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmVgPyB0byBhdm9pZFxuICAgIC8vIHVubmVjZXNzYXJ5IGVudGFuZ2xlbWVudD9cbiAgICByZXRyeUxhbmUgPSByZXF1ZXN0UmV0cnlMYW5lKGJvdW5kYXJ5RmliZXIpO1xuICB9IC8vIFRPRE86IFNwZWNpYWwgY2FzZSBpZGxlIHByaW9yaXR5P1xuXG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHJldHJ5TGFuZSwgZXZlbnRUaW1lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICByZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJldHJ5V2FrZWFibGUoYm91bmRhcnlGaWJlciwgd2FrZWFibGUpIHtcbiAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTsgLy8gRGVmYXVsdFxuXG4gIHZhciByZXRyeUNhY2hlO1xuXG4gIHtcbiAgICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gJyArICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuICByZXR1cm4gdGltZUVsYXBzZWQgPCAxMjAgPyAxMjAgOiB0aW1lRWxhcHNlZCA8IDQ4MCA/IDQ4MCA6IHRpbWVFbGFwc2VkIDwgMTA4MCA/IDEwODAgOiB0aW1lRWxhcHNlZCA8IDE5MjAgPyAxOTIwIDogdGltZUVsYXBzZWQgPCAzMDAwID8gMzAwMCA6IHRpbWVFbGFwc2VkIDwgNDMyMCA/IDQzMjAgOiBjZWlsKHRpbWVFbGFwc2VkIC8gMTk2MCkgKiAxOTYwO1xufVxuXG5mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgJ3JlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgJyArICdjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvICcgKyAncHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgICBlcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcgKyBcImNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgXCIgKyAnaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gJyArICdldmVyeSByZW5kZXIuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpIHtcbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTtcblxuICAgIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihmaWJlciwgaGFzUGFzc2l2ZUVmZmVjdHMpIHtcbiAge1xuICAgIC8vIFRPRE8gKFN0cmljdEVmZmVjdHMpIFNob3VsZCB3ZSBzZXQgYSBtYXJrZXIgb24gdGhlIHJvb3QgaWYgaXQgY29udGFpbnMgc3RyaWN0IGVmZmVjdHNcbiAgICAvLyBzbyB3ZSBkb24ndCB0cmF2ZXJzZSB1bm5lY2Vzc2FyaWx5PyBzaW1pbGFyIHRvIHN1YnRyZWVGbGFncyBidXQganVzdCBhdCB0aGUgcm9vdCBsZXZlbC5cbiAgICAvLyBNYXliZSBub3QgYSBiaWcgZGVhbCBzaW5jZSB0aGlzIGlzIERFViBvbmx5IGJlaGF2aW9yLlxuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudExheW91dERldiwgaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWKTtcblxuICAgIGlmIChoYXNQYXNzaXZlRWZmZWN0cykge1xuICAgICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudFBhc3NpdmVEZXYsIGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYpO1xuICAgIH1cblxuICAgIGludm9rZUVmZmVjdHNJbkRldihmaWJlciwgTW91bnRMYXlvdXREZXYsIGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYpO1xuXG4gICAgaWYgKGhhc1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsIE1vdW50UGFzc2l2ZURldiwgaW52b2tlUGFzc2l2ZUVmZmVjdE1vdW50SW5ERVYpO1xuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlRWZmZWN0c0luRGV2KGZpcnN0Q2hpbGQsIGZpYmVyRmxhZ3MsIGludm9rZUVmZmVjdEZuKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICB2YXIgY3VycmVudCA9IGZpcnN0Q2hpbGQ7XG4gICAgdmFyIHN1YnRyZWVSb290ID0gbnVsbDtcblxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJpbWFyeVN1YnRyZWVGbGFnID0gY3VycmVudC5zdWJ0cmVlRmxhZ3MgJiBmaWJlckZsYWdzO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gc3VidHJlZVJvb3QgJiYgY3VycmVudC5jaGlsZCAhPT0gbnVsbCAmJiBwcmltYXJ5U3VidHJlZUZsYWcgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBmaWJlckZsYWdzKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIGludm9rZUVmZmVjdEZuKGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IHN1YnRyZWVSb290ID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG4gICAgaWYgKHRhZyAhPT0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCAmJiB0YWcgIT09IEhvc3RSb290ICYmIHRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgdGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiB0YWcgIT09IEZvcndhcmRSZWYgJiYgdGFnICE9PSBNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCkge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBiZWdpbldvcmskMTtcblxue1xuICB2YXIgZHVtbXlGaWJlciA9IG51bGw7XG5cbiAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbiAgICAvLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4gICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuICAgIC8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG4gICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgIH0gLy8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTsgLy8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbiAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG4gICAgICAvLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxuXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgdW5pdE9mV29yayk7IC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuXG4gICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cbiAgICAgIGlmICggdW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICB9IC8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5cblxuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGJlZ2luV29yaywgbnVsbCwgY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICB2YXIgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYXlFcnJvciA9PT0gJ29iamVjdCcgJiYgcmVwbGF5RXJyb3IgIT09IG51bGwgJiYgcmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZyAmJiB0eXBlb2Ygb3JpZ2luYWxFcnJvciA9PT0gJ29iamVjdCcgJiYgb3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiAhb3JpZ2luYWxFcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgLy8gSWYgc3VwcHJlc3NlZCwgbGV0IHRoZSBmbGFnIGNhcnJ5IG92ZXIgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHdoaWNoIGlzIHRoZSBvbmUgd2UnbGwgcmV0aHJvdy5cbiAgICAgICAgICBvcmlnaW5hbEVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlIGFsd2F5cyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gY2FzZSB0aGUgc2Vjb25kIHJlbmRlciBwYXNzIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGEgbWVtb2l6ZWQgZnVuY3Rpb24gb3IgQ29tbW9uSlMgbW9kdWxlIGRvZXNuJ3QgdGhyb3cgYWZ0ZXIgZmlyc3QgaW52b2NhdGlvbi5cblxuXG4gICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiAhZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDb21wb25lbnROYW1lID0gd29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgJyArICdkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCAnICsgJ2ZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXInLCBzZXRTdGF0ZUNvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSAnICsgJ2Z1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4nKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcykge1xuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgIG1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBzY2hlZHVsaW5nRmliZXIsIGxhbmVzKTtcbiAgICAgIH0pOyAvLyBUaGlzIGZ1bmN0aW9uIGludGVudGlvbmFsbHkgZG9lcyBub3QgY2xlYXIgbWVtb2l6ZWQgdXBkYXRlcnMuXG4gICAgICAvLyBUaG9zZSBtYXkgc3RpbGwgYmUgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgY29tbWl0XG4gICAgICAvLyBhbmQgYSBmdXR1cmUgb25lIChlLmcuIFN1c3BlbnNlKS5cbiAgICB9XG4gIH1cbn1cbnZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlID0ge307XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2skMShwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICB7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhbiBgYWN0YCBzY29wZSwgYnlwYXNzIFNjaGVkdWxlciBhbmQgcHVzaCB0b1xuICAgIC8vIHRoZSBgYWN0YCBxdWV1ZSBpbnN0ZWFkLlxuICAgIHZhciBhY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudDtcblxuICAgIGlmIChhY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgYWN0UXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSkge1xuICBpZiAoIGNhbGxiYWNrTm9kZSA9PT0gZmFrZUFjdENhbGxiYWNrTm9kZSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBJbiBwcm9kdWN0aW9uLCBhbHdheXMgY2FsbCBTY2hlZHVsZXIuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdHJpcHBlZCBvdXQuXG5cblxuICByZXR1cm4gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkge1xuICAvLyBOZXZlciBmb3JjZSBmbHVzaCBpbiBwcm9kdWN0aW9uLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBnZXQgc3RyaXBwZWQgb3V0LlxuICByZXR1cm4gIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICBpZiAoIWlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkpIHtcbiAgICAgICAgLy8gTm90IGluIGFuIGFjdCBlbnZpcm9ubWVudC4gTm8gbmVlZCB0byB3YXJuLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlZ2FjeSBtb2RlIGhhcyBhZGRpdGlvbmFsIGNhc2VzIHdoZXJlIHdlIHN1cHByZXNzIGEgd2FybmluZy5cbiAgICAgIGlmICghaXNMZWdhY3lBY3RFbnZpcm9ubWVudCgpKSB7XG4gICAgICAgIC8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIExlZ2FjeSBtb2RlIGRvZXNuJ3Qgd2FybiBpZiB0aGUgdXBkYXRlIGlzIGJhdGNoZWQsIGkuZS5cbiAgICAgICAgLy8gYmF0Y2hlZFVwZGF0ZXMgb3IgZmx1c2hTeW5jLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWJlci50YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gRm9yd2FyZFJlZiAmJiBmaWJlci50YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggcHJlLWhvb2tzIGNvZGUsIGxlZ2FjeSBtb2RlIG9ubHlcbiAgICAgICAgLy8gd2FybnMgZm9yIHVwZGF0ZXMgdGhhdCBvcmlnaW5hdGUgZnJvbSBhIGhvb2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSAnICsgJ3dyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0JywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYocm9vdCkge1xuICB7XG4gICAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50ICcgKyAnd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgJyArICdpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2RlcyAqL1xudmFyIHJlc29sdmVGYW1pbHkgPSBudWxsOyAvLyAkRmxvd0ZpeE1lIEZsb3cgZ2V0cyBjb25mdXNlZCBieSBhIFdlYWtTZXQgZmVhdHVyZSBjaGVjayBiZWxvdy5cblxudmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xudmFyIHNldFJlZnJlc2hIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAge1xuICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgLy8gTm8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMuXG4gIHJldHVybiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZWFsIGZvcndhcmRSZWYuIERvbid0IHdhbnQgdG8gY3Jhc2ggZWFybHkuXG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHR5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEZvcndhcmRSZWYgaXMgc3BlY2lhbCBiZWNhdXNlIGl0cyByZXNvbHZlZCAudHlwZSBpcyBhbiBvYmplY3QsXG4gICAgICAgIC8vIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgd2Ugb25seSBoYXZlIGl0cyBpbm5lciByZW5kZXIgZnVuY3Rpb24gaW4gdGhlIG1hcC5cbiAgICAgICAgLy8gSWYgdGhhdCBpbm5lciByZW5kZXIgZnVuY3Rpb24gaXMgZGlmZmVyZW50LCB3ZSdsbCBidWlsZCBhIG5ldyBmb3J3YXJkUmVmIHR5cGUuXG4gICAgICAgIHZhciBjdXJyZW50UmVuZGVyID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKTtcblxuICAgICAgICBpZiAodHlwZS5yZW5kZXIgIT09IGN1cnJlbnRSZW5kZXIpIHtcbiAgICAgICAgICB2YXIgc3ludGhldGljVHlwZSA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgICAgICAgICAgcmVuZGVyOiBjdXJyZW50UmVuZGVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5bnRoZXRpY1R5cGUuZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzeW50aGV0aWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGZpYmVyLCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICB2YXIgbmV4dFR5cGUgPSBlbGVtZW50LnR5cGU7IC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBrbm93IHR5cGVzIGFyZW4ndCA9PT0gZXF1YWwuXG5cbiAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSBmYWxzZTtcbiAgICB2YXIgJCR0eXBlb2ZOZXh0VHlwZSA9IHR5cGVvZiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgbmV4dFR5cGUgIT09IG51bGwgPyBuZXh0VHlwZS4kJHR5cGVvZiA6IG51bGw7XG5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBpbm5lciB0eXBlIHlldC5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHRoZSBsYXp5IGlubmVyIHR5cGUgaXMgc3RhYmxlLFxuICAgICAgICAgICAgLy8gYW5kIHNvIGl0IGlzIHN1ZmZpY2llbnQgdG8gYXZvaWQgcmVjb25jaWxpbmcgaXQgYXdheS5cbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byB1bndyYXAgb3IgYWN0dWFsbHkgdXNlIHRoZSBuZXcgbGF6eSB0eXBlLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiBpdCB3YXMgYnV0IGNhbiBubyBsb25nZXIgYmUgc2ltcGxlLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IHNldCB0aGlzLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgaWYgYm90aCB0eXBlcyBoYXZlIGEgZmFtaWx5IGFuZCBpdCdzIHRoZSBzYW1lIG9uZS5cblxuXG4gICAgaWYgKG5lZWRzQ29tcGFyZUZhbWlsaWVzKSB7XG4gICAgICAvLyBOb3RlOiBtZW1vKCkgYW5kIGZvcndhcmRSZWYoKSB3ZSdsbCBjb21wYXJlIG91dGVyIHJhdGhlciB0aGFuIGlubmVyIHR5cGUuXG4gICAgICAvLyBUaGlzIG1lYW5zIGJvdGggb2YgdGhlbSBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdG8gcHJlc2VydmUgc3RhdGUuXG4gICAgICAvLyBJZiB3ZSB1bndyYXBwZWQgYW5kIGNvbXBhcmVkIHRoZSBpbm5lciB0eXBlcyBmb3Igd3JhcHBlcnMgaW5zdGVhZCxcbiAgICAgIC8vIHRoZW4gd2Ugd291bGQgcmlzayBmYWxzZWx5IHNheWluZyB0d28gc2VwYXJhdGUgbWVtbyhGb28pXG4gICAgICAvLyBjYWxscyBhcmUgZXF1aXZhbGVudCBiZWNhdXNlIHRoZXkgd3JhcCB0aGUgc2FtZSBGb28gZnVuY3Rpb24uXG4gICAgICB2YXIgcHJldkZhbWlseSA9IHJlc29sdmVGYW1pbHkocHJldlR5cGUpO1xuXG4gICAgICBpZiAocHJldkZhbWlseSAhPT0gdW5kZWZpbmVkICYmIHByZXZGYW1pbHkgPT09IHJlc29sdmVGYW1pbHkobmV4dFR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgV2Vha1NldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcik7XG4gIH1cbn1cbnZhciBzY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgdXBkYXRlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IHVwZGF0ZS5zdGFsZUZhbWlsaWVzLFxuICAgICAgICB1cGRhdGVkRmFtaWxpZXMgPSB1cGRhdGUudXBkYXRlZEZhbWlsaWVzO1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVSb290ID0gZnVuY3Rpb24gKHJvb3QsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290LmNvbnRleHQgIT09IGVtcHR5Q29udGV4dE9iamVjdCkge1xuICAgICAgLy8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG4gICAgICAvLyBidXQgd2UgZG9uJ3Qga25vdyB0aGUgcGFyZW50Q29tcG9uZW50IHNvIHdlIGNhbid0IHBhc3MgaXQuXG4gICAgICAvLyBKdXN0IGlnbm9yZS4gV2UnbGwgZGVsZXRlIHRoaXMgd2l0aCBfcmVuZGVyU3VidHJlZSBjb2RlIHBhdGggbGF0ZXIuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoZmliZXIsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZHNSZW5kZXIgPSBmYWxzZTtcbiAgICB2YXIgbmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSk7XG5cbiAgICAgIGlmIChmYW1pbHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RhbGVGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRzUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQpIHtcbiAgICAgIGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCB8fCBuZWVkc1JlbmRlcikge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiAhbmVlZHNSZW1vdW50KSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGNoaWxkLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgZmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBob3N0SW5zdGFuY2VzID0gbmV3IFNldCgpO1xuICAgIHZhciB0eXBlcyA9IG5ldyBTZXQoZmFtaWxpZXMubWFwKGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgICB9KSk7XG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIHJldHVybiBob3N0SW5zdGFuY2VzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoZmliZXIsIHR5cGVzLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZGlkTWF0Y2ggPSBmYWxzZTtcblxuICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZXMuaGFzKGNhbmRpZGF0ZVR5cGUpKSB7XG4gICAgICAgIGRpZE1hdGNoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlkTWF0Y2gpIHtcbiAgICAgIC8vIFdlIGhhdmUgYSBtYXRjaC4gVGhpcyBvbmx5IGRyaWxscyBkb3duIHRvIHRoZSBjbG9zZXN0IGhvc3QgY29tcG9uZW50cy5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2ggZGVlcGVyIGJlY2F1c2UgZm9yIHRoZSBwdXJwb3NlIG9mIGdpdmluZ1xuICAgICAgLy8gdmlzdWFsIGZlZWRiYWNrLCBcImZsYXNoaW5nXCIgb3V0ZXJtb3N0IHBhcmVudCByZWN0YW5nbGVzIGlzIHN1ZmZpY2llbnQuXG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBtYXRjaCwgbWF5YmUgdGhlcmUgd2lsbCBiZSBvbmUgZnVydGhlciBkb3duIGluIHRoZSBjaGlsZCB0cmVlLlxuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShjaGlsZCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoc2libGluZywgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcblxuICAgIGlmIChmb3VuZEhvc3RJbnN0YW5jZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueSBob3N0IGNoaWxkcmVuLCBmYWxsYmFjayB0byBjbG9zZXN0IGhvc3QgcGFyZW50LlxuXG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gcmVhY2ggcm9vdCBmaXJzdC4nKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICAvLyBXZSBnb3QgYSBtYXRjaC5cbiAgICAgICAgZm91bmRIb3N0SW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpOyAvLyBUaGVyZSBtYXkgc3RpbGwgYmUgbW9yZSwgc28ga2VlcCBzZWFyY2hpbmcuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuZWxlbWVudFR5cGUgPSBudWxsO1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7IC8vIEZpYmVyXG5cbiAgdGhpcy5yZXR1cm4gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG4gIHRoaXMucmVmID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB0aGlzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gIHRoaXMubW9kZSA9IG1vZGU7IC8vIEVmZmVjdHNcblxuICB0aGlzLmZsYWdzID0gTm9GbGFncztcbiAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gIHRoaXMubGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIC8vIE5vdGU6IFRoZSBmb2xsb3dpbmcgaXMgZG9uZSB0byBhdm9pZCBhIHY4IHBlcmZvcm1hbmNlIGNsaWZmLlxuICAgIC8vXG4gICAgLy8gSW5pdGlhbGl6aW5nIHRoZSBmaWVsZHMgYmVsb3cgdG8gc21pcyBhbmQgbGF0ZXIgdXBkYXRpbmcgdGhlbSB3aXRoXG4gICAgLy8gZG91YmxlIHZhbHVlcyB3aWxsIGNhdXNlIEZpYmVycyB0byBlbmQgdXAgaGF2aW5nIHNlcGFyYXRlIHNoYXBlcy5cbiAgICAvLyBUaGlzIGJlaGF2aW9yL2J1ZyBoYXMgc29tZXRoaW5nIHRvIGRvIHdpdGggT2JqZWN0LnByZXZlbnRFeHRlbnNpb24oKS5cbiAgICAvLyBGb3J0dW5hdGVseSB0aGlzIG9ubHkgaW1wYWN0cyBERVYgYnVpbGRzLlxuICAgIC8vIFVuZm9ydHVuYXRlbHkgaXQgbWFrZXMgUmVhY3QgdW51c2FibHkgc2xvdyBmb3Igc29tZSBhcHBsaWNhdGlvbnMuXG4gICAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgaW5pdGlhbGl6ZSB0aGUgZmllbGRzIGJlbG93IHdpdGggZG91Ymxlcy5cbiAgICAvL1xuICAgIC8vIExlYXJuIG1vcmUgYWJvdXQgdGhpcyBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQzNjVcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD04NTM4XG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IE51bWJlci5OYU47XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjsgLy8gSXQncyBva2F5IHRvIHJlcGxhY2UgdGhlIGluaXRpYWwgZG91YmxlcyB3aXRoIHNtaXMgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgLy8gVGhpcyB3b24ndCB0cmlnZ2VyIHRoZSBwZXJmb3JtYW5jZSBjbGlmZiBtZW50aW9uZWQgYWJvdmUsXG4gICAgLy8gYW5kIGl0IHNpbXBsaWZpZXMgb3RoZXIgcHJvZmlsZXIgY29kZSAoaW5jbHVkaW5nIERldlRvb2xzKS5cblxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIC8vIFRoaXMgaXNuJ3QgZGlyZWN0bHkgdXNlZCBidXQgaXMgaGFuZHkgZm9yIGRlYnVnZ2luZyBpbnRlcm5hbHM6XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuXG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuXG5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgIXNob3VsZENvbnN0cnVjdCQxKHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSA/IENsYXNzQ29tcG9uZW50IDogRnVuY3Rpb25Db21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICB9XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzOyAvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH0gLy8gUmVzZXQgYWxsIGVmZmVjdHMgZXhjZXB0IHN0YXRpYyBvbmVzLlxuICAvLyBTdGF0aWMgZWZmZWN0cyBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgU3RhdGljTWFzaztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbiAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gIHZhciBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgIGZpcnN0Q29udGV4dDogY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHRcbiAgfTsgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gIH1cblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufSAvLyBVc2VkIHRvIHJldXNlIGEgRmliZXIgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgcmVzZXRzIHRoZSBGaWJlciB0byB3aGF0IGNyZWF0ZUZpYmVyIG9yIGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkXG4gIC8vIGhhdmUgc2V0IHRoZSB2YWx1ZXMgdG8gYmVmb3JlIGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSWRlYWxseSB0aGlzIHdvdWxkbid0XG4gIC8vIGJlIG5lY2Vzc2FyeSBidXQgdW5mb3J0dW5hdGVseSBtYW55IGNvZGUgcGF0aHMgcmVhZHMgZnJvbSB0aGUgd29ya0luUHJvZ3Jlc3NcbiAgLy8gd2hlbiB0aGV5IHNob3VsZCBiZSByZWFkaW5nIGZyb20gY3VycmVudCBhbmQgd3JpdGluZyB0byB3b3JrSW5Qcm9ncmVzcy5cbiAgLy8gV2UgYXNzdW1lIHBlbmRpbmdQcm9wcywgaW5kZXgsIGtleSwgcmVmLCByZXR1cm4gYXJlIHN0aWxsIHVudG91Y2hlZCB0b1xuICAvLyBhdm9pZCBkb2luZyBhbm90aGVyIHJlY29uY2lsaWF0aW9uLlxuICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFN0YXRpY01hc2sgfCBQbGFjZW1lbnQ7IC8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZXNldCB0byB0aGUgY2xvbmVkIHZhbHVlcyB0aGF0IGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkJ3ZlLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gICAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICAgIH07XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSkge1xuICB2YXIgbW9kZTtcblxuICBpZiAodGFnID09PSBDb25jdXJyZW50Um9vdCkge1xuICAgIG1vZGUgPSBDb25jdXJyZW50TW9kZTtcblxuICAgIGlmIChpc1N0cmljdE1vZGUgPT09IHRydWUpIHtcbiAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZTtcblxuICAgICAge1xuICAgICAgICBtb2RlIHw9IFN0cmljdEVmZmVjdHNNb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtb2RlID0gTm9Nb2RlO1xuICB9XG5cbiAgaWYgKCBpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIC8vIEFsd2F5cyBjb2xsZWN0IHByb2ZpbGUgdGltaW5ncyB3aGVuIERldlRvb2xzIGFyZSBwcmVzZW50LlxuICAgIC8vIFRoaXMgZW5hYmxlcyBEZXZUb29scyB0byBzdGFydCBjYXB0dXJpbmcgdGltaW5nIGF0IGFueSBwb2ludOKAk1xuICAgIC8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cbiAgICBtb2RlIHw9IFByb2ZpbGVNb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBudWxsLCBtb2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCAvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXJUYWcgPSBJbmRldGVybWluYXRlQ29tcG9uZW50OyAvLyBUaGUgcmVzb2x2ZWQgdHlwZSBpcyBzZXQgaWYgd2Uga25vdyB3aGF0IHRoZSBmaW5hbCB0eXBlIHdpbGwgYmUuIEkuZS4gaXQncyBub3QgbGF6eS5cblxuICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpIHtcbiAgICAgIGZpYmVyVGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBnZXRUYWc6IHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZTtcblxuICAgICAgICBpZiAoIChtb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAvLyBTdHJpY3QgZWZmZWN0cyBzaG91bGQgbmV2ZXIgcnVuIG9uIGxlZ2FjeSByb290c1xuICAgICAgICAgIG1vZGUgfD0gU3RyaWN0RWZmZWN0c01vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29uc3VtZXJcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRDb25zdW1lcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBMYXp5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIiArICduYW1lZCBpbXBvcnRzLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiAnICsgJ2NvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgJyArIChcImJ1dCBnb3Q6IFwiICsgKHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgZmliZXIudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBvd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcblxuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwga2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcyk7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsIHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgICBlZmZlY3REdXJhdGlvbjogMCxcbiAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VMaXN0Q29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKE9mZnNjcmVlbkNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICB2YXIgcHJpbWFyeUNoaWxkSW5zdGFuY2UgPSB7fTtcbiAgZmliZXIuc3RhdGVOb2RlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2U7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChkZWh5ZHJhdGVkTm9kZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihEZWh5ZHJhdGVkRnJhZ21lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IGRlaHlkcmF0ZWROb2RlO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn0gLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cblxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZmxhZ3MgPSBzb3VyY2UuZmxhZ3M7XG4gIHRhcmdldC5zdWJ0cmVlRmxhZ3MgPSBzb3VyY2Uuc3VidHJlZUZsYWdzO1xuICB0YXJnZXQuZGVsZXRpb25zID0gc291cmNlLmRlbGV0aW9ucztcbiAgdGFyZ2V0LmxhbmVzID0gc291cmNlLmxhbmVzO1xuICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcblxuICB7XG4gICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuICAgIHRhcmdldC5hY3R1YWxTdGFydFRpbWUgPSBzb3VyY2UuYWN0dWFsU3RhcnRUaW1lO1xuICAgIHRhcmdldC5zZWxmQmFzZUR1cmF0aW9uID0gc291cmNlLnNlbGZCYXNlRHVyYXRpb247XG4gICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHRhcmdldC5fZGVidWdTb3VyY2UgPSBzb3VyY2UuX2RlYnVnU291cmNlO1xuICB0YXJnZXQuX2RlYnVnT3duZXIgPSBzb3VyY2UuX2RlYnVnT3duZXI7XG4gIHRhcmdldC5fZGVidWdOZWVkc1JlbW91bnQgPSBzb3VyY2UuX2RlYnVnTmVlZHNSZW1vdW50O1xuICB0YXJnZXQuX2RlYnVnSG9va1R5cGVzID0gc291cmNlLl9kZWJ1Z0hvb2tUeXBlcztcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7XG4gIHRoaXMuZXZlbnRUaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG4gIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcChOb1RpbWVzdGFtcCk7XG4gIHRoaXMucGVuZGluZ0xhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmV4cGlyZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMubXV0YWJsZVJlYWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcblxuICBpZiAoc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aGlzLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSBudWxsO1xuICB9XG5cbiAge1xuICAgIHRoaXMuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHRoaXMucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHtcbiAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSB0aGlzLnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBUb3RhbExhbmVzOyBfaSsrKSB7XG4gICAgICBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwLnB1c2gobmV3IFNldCgpKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ29uY3VycmVudFJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gJ2h5ZHJhdGVSb290KCknIDogJ2NyZWF0ZVJvb3QoKSc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExlZ2FjeVJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gJ2h5ZHJhdGUoKScgOiAncmVuZGVyKCknO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgLy8gVE9ETzogV2UgaGF2ZSBzZXZlcmFsIG9mIHRoZXNlIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25jZXB0dWFsbHkgcGFydCBvZiB0aGVcbi8vIGhvc3QgY29uZmlnLCBidXQgYmVjYXVzZSB0aGV5IGFyZSBwYXNzZWQgaW4gYXQgcnVudGltZSwgd2UgaGF2ZSB0byB0aHJlYWRcbi8vIHRoZW0gdGhyb3VnaCB0aGUgcm9vdCBjb25zdHJ1Y3Rvci4gUGVyaGFwcyB3ZSBzaG91bGQgcHV0IHRoZW0gYWxsIGludG8gYVxuLy8gc2luZ2xlIHR5cGUsIGxpa2UgYSBEeW5hbWljSG9zdENvbmZpZyB0aGF0IGlzIGRlZmluZWQgYnkgdGhlIHJlbmRlcmVyLlxuaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciByb290ID0gbmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IpO1xuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuXG5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIodGFnLCBpc1N0cmljdE1vZGUpO1xuICByb290LmN1cnJlbnQgPSB1bmluaXRpYWxpemVkRmliZXI7XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG4gIHtcbiAgICB2YXIgX2luaXRpYWxTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgIGNhY2hlOiBudWxsLFxuICAgICAgLy8gbm90IGVuYWJsZWQgeWV0XG4gICAgICB0cmFuc2l0aW9uczogbnVsbFxuICAgIH07XG4gICAgdW5pbml0aWFsaXplZEZpYmVyLm1lbW9pemVkU3RhdGUgPSBfaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHVuaW5pdGlhbGl6ZWRGaWJlcik7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE4LjAuMC1mYzQ2ZGJhNjctMjAyMjAzMjknO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHtcbiAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGtleSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50KSB7XG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiICsga2V5cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBrZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhvc3RGaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciBoeWRyYXRlID0gZmFsc2U7XG4gIHZhciBpbml0aWFsQ2hpbGRyZW4gPSBudWxsO1xuICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sIC8vIFRPRE86IFJlbW92ZSBgY2FsbGJhY2tgIHdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLlxuY2FsbGJhY2ssIGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcykge1xuICB2YXIgaHlkcmF0ZSA9IHRydWU7XG4gIHZhciByb290ID0gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTsgLy8gVE9ETzogTW92ZSB0aGlzIHRvIEZpYmVyUm9vdCBjb25zdHJ1Y3RvclxuXG4gIHJvb3QuY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpOyAvLyBTY2hlZHVsZSB0aGUgaW5pdGlhbCByZW5kZXIuIEluIGEgaHlkcmF0aW9uIHJvb3QsIHRoaXMgaXMgZGlmZmVyZW50IGZyb21cbiAgLy8gYSByZWd1bGFyIHVwZGF0ZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0IG1hdGNoIHdhcyB3YXMgcmVuZGVyZWRcbiAgLy8gb24gdGhlIHNlcnZlci5cbiAgLy8gTk9URTogVGhpcyB1cGRhdGUgaW50ZW50aW9uYWxseSBkb2Vzbid0IGhhdmUgYSBwYXlsb2FkLiBXZSdyZSBvbmx5IHVzaW5nXG4gIC8vIHRoZSB1cGRhdGUgdG8gc2NoZWR1bGUgd29yayBvbiB0aGUgcm9vdCBmaWJlciAoYW5kLCBmb3IgbGVnYWN5IHJvb3RzLCB0b1xuICAvLyBlbnF1ZXVlIHRoZSBjYWxsYmFjayBpZiBvbmUgaXMgcHJvdmlkZWQpLlxuXG4gIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwgPyBjYWxsYmFjayA6IG51bGw7XG4gIGVucXVldWVVcGRhdGUoY3VycmVudCwgdXBkYXRlKTtcbiAgc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50JDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50JDEpO1xuXG4gIHtcbiAgICBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50XG4gIH07XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcblxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIGVucXVldWVVcGRhdGUoY3VycmVudCQxLCB1cGRhdGUpO1xuICB2YXIgcm9vdCA9IHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGN1cnJlbnQkMSwgbGFuZSk7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICB9XG59XG5mdW5jdGlvbiBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgdmFyIHJvb3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBmaXJzdCBzY2hlZHVsZWQgXCJ1cGRhdGVcIi5cbiAgICAgICAgdmFyIGxhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpO1xuICAgICAgICBmbHVzaFJvb3Qocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG4gICAgICB9KTsgLy8gSWYgd2UncmUgc3RpbGwgYmxvY2tlZCBhZnRlciB0aGlzLCB3ZSBuZWVkIHRvIGluY3JlYXNlXG4gICAgICAvLyB0aGUgcHJpb3JpdHkgb2YgYW55IHByb21pc2VzIHJlc29sdmluZyB3aXRoaW4gdGhpc1xuICAgICAgLy8gYm91bmRhcnkgc28gdGhhdCB0aGV5IG5leHQgYXR0ZW1wdCBhbHNvIGhhcyBoaWdoZXIgcHJpLlxuXG4gICAgICB2YXIgcmV0cnlMYW5lID0gU3luY0xhbmU7XG4gICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgIHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lID0gaGlnaGVyUHJpb3JpdHlMYW5lKHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lLCByZXRyeUxhbmUpO1xuICB9XG59IC8vIEluY3JlYXNlcyB0aGUgcHJpb3JpdHkgb2YgdGhlbmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxudmFyIHNob3VsZEVycm9ySW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZEVycm9yKGZpYmVyKSB7XG4gIHJldHVybiBzaG91bGRFcnJvckltcGwoZmliZXIpO1xufVxuXG52YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xufVxudmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG52YXIgc2V0RXJyb3JIYW5kbGVyID0gbnVsbDtcbnZhciBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuXG57XG4gIHZhciBjb3B5V2l0aERlbGV0ZUltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCkge1xuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICAgIHVwZGF0ZWQuc3BsaWNlKGtleSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFtrZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9IC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aERlbGV0ZSA9IGZ1bmN0aW9uIChvYmosIHBhdGgpIHtcbiAgICByZXR1cm4gY29weVdpdGhEZWxldGVJbXBsKG9iaiwgcGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lSW1wbCA9IGZ1bmN0aW9uIChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG4gICAgdmFyIG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbCggLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgb2JqW29sZEtleV0sIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICB2YXIgZmluZEhvb2sgPSBmdW5jdGlvbiAoZmliZXIsIGlkKSB7XG4gICAgLy8gRm9yIG5vdywgdGhlIFwiaWRcIiBvZiBzdGF0ZWZ1bCBob29rcyBpcyBqdXN0IHRoZSBzdGF0ZWZ1bCBob29rIGluZGV4LlxuICAgIC8vIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlIHdpdGggZS5nLiBuZXN0ZWQgaG9va3MuXG4gICAgdmFyIGN1cnJlbnRIb29rID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBpZCA+IDApIHtcbiAgICAgIGN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgICAgIGlkLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRIb29rO1xuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIGVkaXRhYmxlIHZhbHVlcyBmb3IgdXNlU3RhdGUgYW5kIHVzZVJlZHVjZXIuXG5cblxuICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoU2V0KGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aERlbGV0ZShob29rLm1lbW9pemVkU3RhdGUsIHBhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07IC8vIFN1cHBvcnQgRGV2VG9vbHMgcHJvcHMgZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMsIGZvcndhcmRSZWYsIG1lbW8sIGhvc3QgY29tcG9uZW50cywgZXRjLlxuXG5cbiAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCB2YWx1ZSk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRFcnJvckltcGwpIHtcbiAgICBzaG91bGRFcnJvckltcGwgPSBuZXdTaG91bGRFcnJvckltcGw7XG4gIH07XG5cbiAgc2V0U3VzcGVuc2VIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZFN1c3BlbmRJbXBsKSB7XG4gICAgc2hvdWxkU3VzcGVuZEltcGwgPSBuZXdTaG91bGRTdXNwZW5kSW1wbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMoKSB7XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRvRGV2VG9vbHMoZGV2VG9vbHNDb25maWcpIHtcbiAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG4gIHZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbiAgcmV0dXJuIGluamVjdEludGVybmFscyh7XG4gICAgYnVuZGxlVHlwZTogZGV2VG9vbHNDb25maWcuYnVuZGxlVHlwZSxcbiAgICB2ZXJzaW9uOiBkZXZUb29sc0NvbmZpZy52ZXJzaW9uLFxuICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgcmVuZGVyZXJDb25maWc6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyQ29uZmlnLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlOiBvdmVycmlkZUhvb2tTdGF0ZSxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCxcbiAgICBvdmVycmlkZVByb3BzOiBvdmVycmlkZVByb3BzLFxuICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOiBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCxcbiAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDogb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsXG4gICAgc2V0RXJyb3JIYW5kbGVyOiBzZXRFcnJvckhhbmRsZXIsXG4gICAgc2V0U3VzcGVuc2VIYW5kbGVyOiBzZXRTdXNwZW5zZUhhbmRsZXIsXG4gICAgc2NoZWR1bGVVcGRhdGU6IHNjaGVkdWxlVXBkYXRlLFxuICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcixcbiAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgfHwgZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSxcbiAgICAvLyBSZWFjdCBSZWZyZXNoXG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOiAgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJlZnJlc2g6ICBzY2hlZHVsZVJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUm9vdDogIHNjaGVkdWxlUm9vdCAsXG4gICAgc2V0UmVmcmVzaEhhbmRsZXI6ICBzZXRSZWZyZXNoSGFuZGxlciAsXG4gICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBhcHBlbmQgb3duZXIgc3RhY2tzIHRvIGVycm9yIG1lc3NhZ2VzIGluIERFViBtb2RlLlxuICAgIGdldEN1cnJlbnRGaWJlcjogIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGRldGVjdCByZWNvbmNpbGVyIHZlcnNpb24gcmF0aGVyIHRoYW4gcmVuZGVyZXIgdmVyc2lvblxuICAgIC8vIHdoaWNoIG1heSBub3QgbWF0Y2ggZm9yIHRoaXJkIHBhcnR5IHJlbmRlcmVycy5cbiAgICByZWNvbmNpbGVyVmVyc2lvbjogUmVhY3RWZXJzaW9uXG4gIH0pO1xufVxuXG5leHBvcnRzLmF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb247XG5leHBvcnRzLmF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eTtcbmV4cG9ydHMuYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uID0gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uO1xuZXhwb3J0cy5iYXRjaGVkVXBkYXRlcyA9IGJhdGNoZWRVcGRhdGVzO1xuZXhwb3J0cy5jcmVhdGVDb21wb25lbnRTZWxlY3RvciA9IGNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVDb250YWluZXIgPSBjcmVhdGVDb250YWluZXI7XG5leHBvcnRzLmNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IgPSBjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25Db250YWluZXIgPSBjcmVhdGVIeWRyYXRpb25Db250YWluZXI7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGNyZWF0ZVBvcnRhbDtcbmV4cG9ydHMuY3JlYXRlUm9sZVNlbGVjdG9yID0gY3JlYXRlUm9sZVNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVUZXN0TmFtZVNlbGVjdG9yID0gY3JlYXRlVGVzdE5hbWVTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlVGV4dFNlbGVjdG9yID0gY3JlYXRlVGV4dFNlbGVjdG9yO1xuZXhwb3J0cy5kZWZlcnJlZFVwZGF0ZXMgPSBkZWZlcnJlZFVwZGF0ZXM7XG5leHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGRpc2NyZXRlVXBkYXRlcztcbmV4cG9ydHMuZmluZEFsbE5vZGVzID0gZmluZEFsbE5vZGVzO1xuZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZpbmRCb3VuZGluZ1JlY3RzO1xuZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZTtcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscztcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nO1xuZXhwb3J0cy5mbHVzaENvbnRyb2xsZWQgPSBmbHVzaENvbnRyb2xsZWQ7XG5leHBvcnRzLmZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzO1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmM7XG5leHBvcnRzLmZvY3VzV2l0aGluID0gZm9jdXNXaXRoaW47XG5leHBvcnRzLmdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbmV4cG9ydHMuZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uID0gZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uO1xuZXhwb3J0cy5nZXRQdWJsaWNSb290SW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2U7XG5leHBvcnRzLmluamVjdEludG9EZXZUb29scyA9IGluamVjdEludG9EZXZUb29scztcbmV4cG9ydHMuaXNBbHJlYWR5UmVuZGVyaW5nID0gaXNBbHJlYWR5UmVuZGVyaW5nO1xuZXhwb3J0cy5vYnNlcnZlVmlzaWJsZVJlY3RzID0gb2JzZXJ2ZVZpc2libGVSZWN0cztcbmV4cG9ydHMucmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uID0gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uO1xuZXhwb3J0cy5ydW5XaXRoUHJpb3JpdHkgPSBydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnNob3VsZEVycm9yID0gc2hvdWxkRXJyb3I7XG5leHBvcnRzLnNob3VsZFN1c3BlbmQgPSBzaG91bGRTdXNwZW5kO1xuZXhwb3J0cy51cGRhdGVDb250YWluZXIgPSB1cGRhdGVDb250YWluZXI7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH07XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCIkJCRyZWNvbmNpbGVyIiwiJCQkaG9zdENvbmZpZyIsIlJlYWN0IiwicmVxdWlyZSIsIlNjaGVkdWxlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJzdXBwcmVzc1dhcm5pbmciLCJzZXRTdXBwcmVzc1dhcm5pbmciLCJuZXdTdXBwcmVzc1dhcm5pbmciLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiYXNzaWduIiwiT2JqZWN0IiwiZ2V0Iiwia2V5IiwiX3JlYWN0SW50ZXJuYWxzIiwic2V0IiwidmFsdWUiLCJlbmFibGVQZXJzaXN0ZW50T2Zmc2NyZWVuSG9zdENvbnRhaW5lciIsImVuYWJsZU5ld1JlY29uY2lsZXIiLCJlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uIiwiZW5hYmxlTGVnYWN5SGlkZGVuIiwiZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjayIsIndhcm5BYm91dFN0cmluZ1JlZnMiLCJlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIiLCJlbmFibGVQcm9maWxlclRpbWVyIiwiZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyIsIkZ1bmN0aW9uQ29tcG9uZW50IiwiQ2xhc3NDb21wb25lbnQiLCJJbmRldGVybWluYXRlQ29tcG9uZW50IiwiSG9zdFJvb3QiLCJIb3N0UG9ydGFsIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiRnJhZ21lbnQiLCJNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRm9yd2FyZFJlZiIsIlByb2ZpbGVyIiwiU3VzcGVuc2VDb21wb25lbnQiLCJNZW1vQ29tcG9uZW50IiwiU2ltcGxlTWVtb0NvbXBvbmVudCIsIkxhenlDb21wb25lbnQiLCJJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJEZWh5ZHJhdGVkRnJhZ21lbnQiLCJTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJTY29wZUNvbXBvbmVudCIsIk9mZnNjcmVlbkNvbXBvbmVudCIsIkxlZ2FjeUhpZGRlbkNvbXBvbmVudCIsIkNhY2hlQ29tcG9uZW50IiwiVHJhY2luZ01hcmtlckNvbXBvbmVudCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJSRUFDVF9DQUNIRV9UWVBFIiwiUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJ0eXBlIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwidGFnIiwiJCR0eXBlb2YiLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiZ2V0V3JhcHBlZE5hbWUkMSIsImdldENvbnRleHROYW1lJDEiLCJnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyIiwiZmliZXIiLCJOb0ZsYWdzIiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIlVwZGF0ZSIsIlBsYWNlbWVudEFuZFVwZGF0ZSIsIkNoaWxkRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkRpZENhcHR1cmUiLCJGb3JjZUNsaWVudFJlbmRlciIsIlJlZiIsIlNuYXBzaG90IiwiUGFzc2l2ZSIsIkh5ZHJhdGluZyIsIkh5ZHJhdGluZ0FuZFVwZGF0ZSIsIlZpc2liaWxpdHkiLCJTdG9yZUNvbnNpc3RlbmN5IiwiTGlmZWN5Y2xlRWZmZWN0TWFzayIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlIiwiRm9ya2VkIiwiUmVmU3RhdGljIiwiTGF5b3V0U3RhdGljIiwiUGFzc2l2ZVN0YXRpYyIsIk1vdW50TGF5b3V0RGV2IiwiTW91bnRQYXNzaXZlRGV2IiwiQmVmb3JlTXV0YXRpb25NYXNrIiwiTXV0YXRpb25NYXNrIiwiTGF5b3V0TWFzayIsIlBhc3NpdmVNYXNrIiwiU3RhdGljTWFzayIsIlJlYWN0Q3VycmVudE93bmVyIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5vZGUiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsIm5leHROb2RlIiwiZmxhZ3MiLCJyZXR1cm4iLCJpc0ZpYmVyTW91bnRlZCIsImlzTW91bnRlZCIsImNvbXBvbmVudCIsIm93bmVyIiwiY3VycmVudCIsIm93bmVyRmliZXIiLCJpbnN0YW5jZSIsInN0YXRlTm9kZSIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsIkVycm9yIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwibmV4dFBhcmVudCIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiY3VycmVudFBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVySW1wbCIsIm1hdGNoIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbCIsImlzQXJyYXlJbXBsIiwiaXNBcnJheSIsImdldFB1YmxpY0luc3RhbmNlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInByZXBhcmVGb3JDb21taXQiLCJyZXNldEFmdGVyQ29tbWl0IiwiY3JlYXRlSW5zdGFuY2UiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInByZXBhcmVVcGRhdGUiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsImNyZWF0ZVRleHRJbnN0YW5jZSIsInNjaGVkdWxlVGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJub1RpbWVvdXQiLCJub3ciLCJpc1ByaW1hcnlSZW5kZXJlciIsIndhcm5zSWZOb3RBY3RpbmciLCJzdXBwb3J0c011dGF0aW9uIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwicHJlcGFyZVBvcnRhbE1vdW50IiwicHJlcGFyZVNjb3BlVXBkYXRlIiwiZ2V0SW5zdGFuY2VGcm9tU2NvcGUiLCJnZXRDdXJyZW50RXZlbnRQcmlvcml0eSIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsInN1cHBvcnRzTWljcm90YXNrcyIsInNjaGVkdWxlTWljcm90YXNrIiwic3VwcG9ydHNUZXN0U2VsZWN0b3JzIiwiZmluZEZpYmVyUm9vdCIsImdldEJvdW5kaW5nUmVjdCIsImdldFRleHRDb250ZW50IiwiaXNIaWRkZW5TdWJ0cmVlIiwibWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSIsInNldEZvY3VzSWZGb2N1c2FibGUiLCJzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiY29tbWl0VGV4dFVwZGF0ZSIsImNvbW1pdE1vdW50IiwiY29tbWl0VXBkYXRlIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsInJlc2V0VGV4dENvbnRlbnQiLCJoaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJjbGVhckNvbnRhaW5lciIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJnZXRPZmZzY3JlZW5Db250YWluZXJUeXBlIiwiZ2V0T2Zmc2NyZWVuQ29udGFpbmVyUHJvcHMiLCJjbG9uZUhpZGRlbkluc3RhbmNlIiwiY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UiLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJyZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlIiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJjbGVhclN1c3BlbnNlQm91bmRhcnkiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwic2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMiLCJkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXIiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXIiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2UiLCJlcnJvckh5ZHJhdGluZ0NvbnRhaW5lciIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsInVuZGVmaW5lZCIsInRyaW0iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImNvbnRyb2wiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJSZWZsZWN0Iiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiX2ZyYW1lIiwicmVwbGFjZSIsImluY2x1ZGVzIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUiLCJjdG9yIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImhhc093blByb3BlcnR5IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50IiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJ2YWx1ZVN0YWNrIiwiZmliZXJTdGFjayIsImluZGV4IiwiY3JlYXRlQ3Vyc29yIiwiZGVmYXVsdFZhbHVlIiwicG9wIiwiY3Vyc29yIiwicHVzaCIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsImZyZWV6ZSIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJ3b3JrSW5Qcm9ncmVzcyIsImRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlciIsImlzQ29udGV4dFByb3ZpZGVyIiwiY2FjaGVDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwibWFza2VkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsImdldE1hc2tlZENvbnRleHQiLCJjb250ZXh0VHlwZXMiLCJoYXNDb250ZXh0Q2hhbmdlZCIsImNoaWxkQ29udGV4dFR5cGVzIiwicG9wQ29udGV4dCIsInBvcFRvcExldmVsQ29udGV4dE9iamVjdCIsInB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QiLCJkaWRDaGFuZ2UiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwicGFyZW50Q29udGV4dCIsImdldENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dCIsImNvbnRleHRLZXkiLCJwdXNoQ29udGV4dFByb3ZpZGVyIiwibWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsImludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIiLCJtZXJnZWRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJMZWdhY3lSb290IiwiQ29uY3VycmVudFJvb3QiLCJOb01vZGUiLCJDb25jdXJyZW50TW9kZSIsIlByb2ZpbGVNb2RlIiwiU3RyaWN0TGVnYWN5TW9kZSIsIlN0cmljdEVmZmVjdHNNb2RlIiwiY2x6MzIiLCJNYXRoIiwiY2x6MzJGYWxsYmFjayIsIkxOMiIsImFzVWludCIsIlRvdGFsTGFuZXMiLCJOb0xhbmVzIiwiTm9MYW5lIiwiU3luY0xhbmUiLCJJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIiwiSW5wdXRDb250aW51b3VzTGFuZSIsIkRlZmF1bHRIeWRyYXRpb25MYW5lIiwiRGVmYXVsdExhbmUiLCJUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSIsIlRyYW5zaXRpb25MYW5lcyIsIlRyYW5zaXRpb25MYW5lMSIsIlRyYW5zaXRpb25MYW5lMiIsIlRyYW5zaXRpb25MYW5lMyIsIlRyYW5zaXRpb25MYW5lNCIsIlRyYW5zaXRpb25MYW5lNSIsIlRyYW5zaXRpb25MYW5lNiIsIlRyYW5zaXRpb25MYW5lNyIsIlRyYW5zaXRpb25MYW5lOCIsIlRyYW5zaXRpb25MYW5lOSIsIlRyYW5zaXRpb25MYW5lMTAiLCJUcmFuc2l0aW9uTGFuZTExIiwiVHJhbnNpdGlvbkxhbmUxMiIsIlRyYW5zaXRpb25MYW5lMTMiLCJUcmFuc2l0aW9uTGFuZTE0IiwiVHJhbnNpdGlvbkxhbmUxNSIsIlRyYW5zaXRpb25MYW5lMTYiLCJSZXRyeUxhbmVzIiwiUmV0cnlMYW5lMSIsIlJldHJ5TGFuZTIiLCJSZXRyeUxhbmUzIiwiUmV0cnlMYW5lNCIsIlJldHJ5TGFuZTUiLCJTb21lUmV0cnlMYW5lIiwiU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSIsIk5vbklkbGVMYW5lcyIsIklkbGVIeWRyYXRpb25MYW5lIiwiSWRsZUxhbmUiLCJPZmZzY3JlZW5MYW5lIiwiZ2V0TGFiZWxGb3JMYW5lIiwibGFuZSIsIk5vVGltZXN0YW1wIiwibmV4dFRyYW5zaXRpb25MYW5lIiwibmV4dFJldHJ5TGFuZSIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIiwibGFuZXMiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIiwiZ2V0TmV4dExhbmVzIiwicm9vdCIsIndpcExhbmVzIiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJub25JZGxlVW5ibG9ja2VkTGFuZXMiLCJub25JZGxlUGluZ2VkTGFuZXMiLCJ1bmJsb2NrZWRMYW5lcyIsIm5leHRMYW5lIiwid2lwTGFuZSIsImVudGFuZ2xlZExhbmVzIiwiZW50YW5nbGVtZW50cyIsInBpY2tBcmJpdHJhcnlMYW5lSW5kZXgiLCJnZXRNb3N0UmVjZW50RXZlbnRUaW1lIiwiZXZlbnRUaW1lcyIsIm1vc3RSZWNlbnRFdmVudFRpbWUiLCJldmVudFRpbWUiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50VGltZSIsIm1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQiLCJleHBpcmF0aW9uVGltZXMiLCJleHBpcmF0aW9uVGltZSIsImV4cGlyZWRMYW5lcyIsImdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyIsImdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yIiwiZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiIsImluY2x1ZGVzU3luY0xhbmUiLCJpbmNsdWRlc05vbklkbGVXb3JrIiwiaW5jbHVkZXNPbmx5UmV0cmllcyIsImluY2x1ZGVzT25seVRyYW5zaXRpb25zIiwiaW5jbHVkZXNCbG9ja2luZ0xhbmUiLCJTeW5jRGVmYXVsdExhbmVzIiwiaW5jbHVkZXNFeHBpcmVkTGFuZSIsImlzVHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFJldHJ5TGFuZSIsInBpY2tBcmJpdHJhcnlMYW5lIiwibGFuZVRvSW5kZXgiLCJpbmNsdWRlc1NvbWVMYW5lIiwiaXNTdWJzZXRPZkxhbmVzIiwic3Vic2V0IiwibWVyZ2VMYW5lcyIsInJlbW92ZUxhbmVzIiwiaW50ZXJzZWN0TGFuZXMiLCJsYW5lVG9MYW5lcyIsImhpZ2hlclByaW9yaXR5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsImkiLCJtYXJrUm9vdFVwZGF0ZWQiLCJ1cGRhdGVMYW5lIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJtYXJrUm9vdFBpbmdlZCIsIm1hcmtSb290RmluaXNoZWQiLCJyZW1haW5pbmdMYW5lcyIsIm5vTG9uZ2VyUGVuZGluZ0xhbmVzIiwibXV0YWJsZVJlYWRMYW5lcyIsIm1hcmtSb290RW50YW5nbGVkIiwicm9vdEVudGFuZ2xlZExhbmVzIiwiZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbiIsInJlbmRlckxhbmVzIiwicmVuZGVyTGFuZSIsImFkZEZpYmVyVG9MYW5lc01hcCIsImlzRGV2VG9vbHNQcmVzZW50IiwicGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCIsInVwZGF0ZXJzIiwiYWRkIiwibW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkIiwibWVtb2l6ZWRVcGRhdGVycyIsInNpemUiLCJmb3JFYWNoIiwiY2xlYXIiLCJEaXNjcmV0ZUV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRlZmF1bHRFdmVudFByaW9yaXR5IiwiSWRsZUV2ZW50UHJpb3JpdHkiLCJjdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJuZXdQcmlvcml0eSIsInJ1bldpdGhQcmlvcml0eSIsInByaW9yaXR5IiwicHJldmlvdXNQcmlvcml0eSIsImhpZ2hlckV2ZW50UHJpb3JpdHkiLCJsb3dlckV2ZW50UHJpb3JpdHkiLCJpc0hpZ2hlckV2ZW50UHJpb3JpdHkiLCJsYW5lc1RvRXZlbnRQcmlvcml0eSIsInNjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwiY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInNob3VsZFlpZWxkIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJyZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJub3ckMSIsInVuc3RhYmxlX25vdyIsIkltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJVc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwiTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInVuc3RhYmxlX3lpZWxkVmFsdWUiLCJ1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSIsInJlbmRlcmVySUQiLCJpbmplY3RlZEhvb2siLCJpbmplY3RlZFByb2ZpbGluZ0hvb2tzIiwiaGFzTG9nZ2VkRXJyb3IiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJnZXRMYW5lTGFiZWxNYXAiLCJpbmplY3RQcm9maWxpbmdIb29rcyIsImluamVjdCIsImNoZWNrRENFIiwib25TY2hlZHVsZVJvb3QiLCJjaGlsZHJlbiIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJvbkNvbW1pdFJvb3QiLCJldmVudFByaW9yaXR5Iiwib25Db21taXRGaWJlclJvb3QiLCJkaWRFcnJvciIsInNjaGVkdWxlclByaW9yaXR5Iiwib25Qb3N0Q29tbWl0Um9vdCIsIm9uUG9zdENvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0VW5tb3VudCIsIm9uQ29tbWl0RmliZXJVbm1vdW50Iiwic2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMiLCJuZXdJc1N0cmljdE1vZGUiLCJzZXRTdHJpY3RNb2RlIiwicHJvZmlsaW5nSG9va3MiLCJsYWJlbCIsIm1hcmtDb21taXRTdGFydGVkIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsInRocm93blZhbHVlIiwibWFya0NvbXBvbmVudFN1c3BlbmRlZCIsIndha2VhYmxlIiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJtYXJrUmVuZGVyU3RhcnRlZCIsIm1hcmtSZW5kZXJZaWVsZGVkIiwibWFya1JlbmRlclN0b3BwZWQiLCJtYXJrUmVuZGVyU2NoZWR1bGVkIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwiaXMiLCJ5Iiwib2JqZWN0SXMiLCJzeW5jUXVldWUiLCJpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MiLCJpc0ZsdXNoaW5nU3luY1F1ZXVlIiwic2NoZWR1bGVTeW5jQ2FsbGJhY2siLCJjYWxsYmFjayIsInNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrIiwiZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSIsImZsdXNoU3luY0NhbGxiYWNrcyIsInByZXZpb3VzVXBkYXRlUHJpb3JpdHkiLCJpc1N5bmMiLCJxdWV1ZSIsInNsaWNlIiwiaXNSb290RGVoeWRyYXRlZCIsImN1cnJlbnRTdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJpc0RlaHlkcmF0ZWQiLCJSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyIsIk5vVHJhbnNpdGlvbiIsInJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5cyIsImtleXNCIiwiY3VycmVudEtleSIsImRlc2NyaWJlRmliZXIiLCJfZGVidWdPd25lciIsIl9kZWJ1Z1NvdXJjZSIsImdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsImlzUmVuZGVyaW5nIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwiLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicmVzZXRDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50U3RhY2siLCJzZXRDdXJyZW50RmliZXIiLCJzZXRJc1JlbmRlcmluZyIsInJlbmRlcmluZyIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJmaW5kU3RyaWN0Um9vdCIsIm1heWJlU3RyaWN0Um9vdCIsIm1vZGUiLCJzZXRUb1NvcnRlZFN0cmluZyIsImFycmF5Iiwic29ydCIsImpvaW4iLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsIlNldCIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsInNvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzMiIsIl9zb3J0ZWROYW1lczMiLCJfc29ydGVkTmFtZXM0IiwiX3NvcnRlZE5hbWVzNSIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzdHJpY3RSb290Iiwid2FybmluZ3NGb3JSb290IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsInR5cGVOYW1lIiwiaGFzVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImNvbnN0cnVjdG9yIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tLZXlTdHJpbmdDb2VyY2lvbiIsImNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uIiwicHJvcE5hbWUiLCJyZXNvbHZlRGVmYXVsdFByb3BzIiwiYmFzZVByb3BzIiwiZGVmYXVsdFByb3BzIiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlclNpZ2lsIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwiZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsImV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInB1c2hQcm92aWRlciIsInByb3ZpZGVyRmliZXIiLCJuZXh0VmFsdWUiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRSZW5kZXJlciIsIl9jdXJyZW50VmFsdWUyIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwb3BQcm92aWRlciIsImN1cnJlbnRWYWx1ZSIsInNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgiLCJwcm9wYWdhdGlvblJvb3QiLCJjaGlsZExhbmVzIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIiLCJuZXh0RmliZXIiLCJsaXN0IiwiZGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jeSIsImZpcnN0Q29udGV4dCIsInVwZGF0ZSIsImNyZWF0ZVVwZGF0ZSIsIkZvcmNlVXBkYXRlIiwidXBkYXRlUXVldWUiLCJzaGFyZWRRdWV1ZSIsInNoYXJlZCIsInBlbmRpbmciLCJuZXh0IiwicGFyZW50U3VzcGVuc2UiLCJfYWx0ZXJuYXRlIiwicHJlcGFyZVRvUmVhZENvbnRleHQiLCJtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSIsInJlYWRDb250ZXh0IiwiY29udGV4dEl0ZW0iLCJtZW1vaXplZFZhbHVlIiwiaW50ZXJsZWF2ZWRRdWV1ZXMiLCJwdXNoSW50ZXJsZWF2ZWRRdWV1ZSIsImVucXVldWVJbnRlcmxlYXZlZFVwZGF0ZXMiLCJsYXN0SW50ZXJsZWF2ZWRVcGRhdGUiLCJpbnRlcmxlYXZlZCIsImZpcnN0SW50ZXJsZWF2ZWRVcGRhdGUiLCJsYXN0UGVuZGluZ1VwZGF0ZSIsImZpcnN0UGVuZGluZ1VwZGF0ZSIsIlVwZGF0ZVN0YXRlIiwiUmVwbGFjZVN0YXRlIiwiQ2FwdHVyZVVwZGF0ZSIsImhhc0ZvcmNlVXBkYXRlIiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImluaXRpYWxpemVVcGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwiZWZmZWN0cyIsImNsb25lVXBkYXRlUXVldWUiLCJjdXJyZW50UXVldWUiLCJjbG9uZSIsImVucXVldWVVcGRhdGUiLCJpc0ludGVybGVhdmVkVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9ucyIsInF1ZXVlTGFuZXMiLCJuZXdRdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJwZW5kaW5nUXVldWUiLCJjdXJyZW50TGFzdEJhc2VVcGRhdGUiLCJuZXdTdGF0ZSIsIm5ld0xhbmVzIiwibmV3QmFzZVN0YXRlIiwibmV3Rmlyc3RCYXNlVXBkYXRlIiwibmV3TGFzdEJhc2VVcGRhdGUiLCJ1cGRhdGVFdmVudFRpbWUiLCJfY2xvbmUiLCJfbGFzdFBlbmRpbmdVcGRhdGUiLCJfZmlyc3RQZW5kaW5nVXBkYXRlIiwibGFzdEludGVybGVhdmVkIiwibWFya1NraXBwZWRVcGRhdGVMYW5lcyIsImNhbGxDYWxsYmFjayIsInJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nIiwiY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZyIsImNvbW1pdFVwZGF0ZVF1ZXVlIiwiZmluaXNoZWRXb3JrIiwiZmluaXNoZWRRdWV1ZSIsImVmZmVjdCIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZW1wdHlSZWZzT2JqZWN0IiwicmVmcyIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiY2FsbGVyTmFtZSIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVNldFN0YXRlIiwiaW5zdCIsInJlcXVlc3RFdmVudFRpbWUiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJvbGRTdGF0ZSIsIm5leHRDb250ZXh0Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwic2hvdWxkVXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50IiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJzdGF0ZSIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiX3N0YXRlIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwidXBkYXRlciIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwiaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIiLCJpc1ZhbGlkIiwiYWRkZW5kdW0iLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIl9jb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImNvbXBvbmVudERpZE1vdW50IiwiZmliZXJGbGFncyIsInJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSIsIm1lbW9pemVkUHJvcHMiLCJvbGRDb250ZXh0IiwibmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCIsImhhc05ld0xpZmVjeWNsZXMiLCJfZmliZXJGbGFncyIsIl9maWJlckZsYWdzMiIsInVwZGF0ZUNsYXNzSW5zdGFuY2UiLCJ1bnJlc29sdmVkT2xkUHJvcHMiLCJlbGVtZW50VHlwZSIsInVucmVzb2x2ZWROZXdQcm9wcyIsInBlbmRpbmdQcm9wcyIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrUHJvdmlkZXIiLCJ0cmVlRm9ya0NvdW50IiwiaWRTdGFjayIsImlkU3RhY2tJbmRleCIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsImlzRm9ya2VkQ2hpbGQiLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJnZXRGb3Jrc0F0TGV2ZWwiLCJnZXRUcmVlSWQiLCJvdmVyZmxvdyIsImlkV2l0aExlYWRpbmdCaXQiLCJpZCIsImdldExlYWRpbmdCaXQiLCJ0b1N0cmluZyIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJwdXNoVHJlZUlkIiwiYmFzZUlkV2l0aExlYWRpbmdCaXQiLCJiYXNlT3ZlcmZsb3ciLCJiYXNlTGVuZ3RoIiwiZ2V0Qml0TGVuZ3RoIiwiYmFzZUlkIiwic2xvdCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3ciLCJyZXN0T2ZCYXNlSWQiLCJyZXN0T2ZCYXNlTGVuZ3RoIiwicmVzdE9mTGVuZ3RoIiwicmVzdE9mTmV3Qml0cyIsIm5ld0JpdHMiLCJfaWQiLCJfb3ZlcmZsb3ciLCJwdXNoTWF0ZXJpYWxpemVkVHJlZUlkIiwicmV0dXJuRmliZXIiLCJudW1iZXJPZkZvcmtzIiwic2xvdEluZGV4IiwibnVtYmVyIiwicG9wVHJlZUNvbnRleHQiLCJnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCIsInJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCIsInN1c3BlbmRlZENvbnRleHQiLCJnZXRJc0h5ZHJhdGluZyIsImh5ZHJhdGlvblBhcmVudEZpYmVyIiwibmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImlzSHlkcmF0aW5nIiwiZGlkU3VzcGVuZCIsImh5ZHJhdGlvbkVycm9ycyIsIndhcm5JZkh5ZHJhdGluZyIsIm1hcmtEaWRTdXNwZW5kV2hpbGVIeWRyYXRpbmdERVYiLCJlbnRlckh5ZHJhdGlvblN0YXRlIiwicGFyZW50SW5zdGFuY2UiLCJjb250YWluZXJJbmZvIiwicmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwic3VzcGVuc2VJbnN0YW5jZSIsInRyZWVDb250ZXh0Iiwid2FyblVuaHlkcmF0ZWRJbnN0YW5jZSIsInN1c3BlbnNlU3RhdGUiLCJkZWh5ZHJhdGVkIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiY2hpbGRUb0RlbGV0ZSIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiZGVsZXRpb25zIiwid2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UiLCJwYXJlbnRDb250YWluZXIiLCJ0ZXh0IiwicGFyZW50VHlwZSIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfcHJvcHMiLCJfdGV4dCIsIl9wYXJlbnRJbnN0YW5jZSIsIl90eXBlMiIsIl9wcm9wczIiLCJfdGV4dDIiLCJpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlIiwidHJ5SHlkcmF0ZSIsIm5leHRJbnN0YW5jZSIsInRleHRJbnN0YW5jZSIsInJldHJ5TGFuZSIsImRlaHlkcmF0ZWRGcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudCIsInNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2giLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UiLCJwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwicm9vdENvbnRhaW5lckluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJzaG91bGRXYXJuSWZNaXNtYXRjaERldiIsInVwZGF0ZVBheWxvYWQiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInRleHRDb250ZW50IiwiaXNDb25jdXJyZW50TW9kZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSIsInNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJ3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzIiwiaGFzVW5oeWRyYXRlZFRhaWxOb2RlcyIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJ1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSIsInF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMiLCJxdWV1ZUh5ZHJhdGlvbkVycm9yIiwiZGlkV2FybkFib3V0TWFwcyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjb2VyY2VSZWYiLCJtaXhlZFJlZiIsInJlZiIsIl9zZWxmIiwicmVzb2x2ZWRJbnN0Iiwic3RyaW5nUmVmIiwiX3N0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiY2hpbGRTdHJpbmciLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJyZXNvbHZlTGF6eSIsImxhenlUeXBlIiwiQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlRnJhZ21lbnQiLCJpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmciLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwidXBkYXRlUG9ydGFsIiwicG9ydGFsIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJmcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9udW1iZXJPZkZvcmtzIiwiX25ld0ZpYmVyMiIsImRlbGV0ZSIsIl9udW1iZXJPZkZvcmtzMiIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJuZXdDaGlsZHJlbkl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJfbmV3Q2hpbGRyZW4iLCJfc3RlcCIsImRvbmUiLCJzdGVwIiwiX25ld0ZpYmVyMyIsIl9udW1iZXJPZkZvcmtzMyIsIl9uZXdGaWJlcjQiLCJfbnVtYmVyT2ZGb3JrczQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfZXhpc3RpbmciLCJfY3JlYXRlZDQiLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsImlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQiLCJtb3VudENoaWxkRmliZXJzIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsInJlc2V0Q2hpbGRGaWJlcnMiLCJyZXNldFdvcmtJblByb2dyZXNzIiwiTk9fQ09OVEVYVCIsImNvbnRleHRTdGFja0N1cnNvciQxIiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsInJlcXVpcmVkQ29udGV4dCIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicm9vdEluc3RhbmNlIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJEZWZhdWx0U3VzcGVuc2VDb250ZXh0IiwiU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2siLCJJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQiLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJzdXNwZW5zZVN0YWNrQ3Vyc29yIiwiaGFzU3VzcGVuc2VDb250ZXh0IiwiZmxhZyIsInNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0Iiwic2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dCIsInNoYWxsb3dDb250ZXh0IiwiYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dCIsInN1YnRyZWVDb250ZXh0IiwicHVzaFN1c3BlbnNlQ29udGV4dCIsIm5ld0NvbnRleHQiLCJwb3BTdXNwZW5zZUNvbnRleHQiLCJzaG91bGRDYXB0dXJlU3VzcGVuc2UiLCJoYXNJbnZpc2libGVQYXJlbnQiLCJmaW5kRmlyc3RTdXNwZW5kZWQiLCJyb3ciLCJyZXZlYWxPcmRlciIsIk5vRmxhZ3MkMSIsIkhhc0VmZmVjdCIsIkluc2VydGlvbiIsIkxheW91dCIsIlBhc3NpdmUkMSIsIndvcmtJblByb2dyZXNzU291cmNlcyIsInJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucyIsIm11dGFibGVTb3VyY2UiLCJfd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSIsIl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25TZWNvbmRhcnkiLCJyZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24iLCJnZXRWZXJzaW9uIiwiX2dldFZlcnNpb24iLCJ2ZXJzaW9uIiwibXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MiLCJsb2NhbElkQ291bnRlciIsImdsb2JhbENsaWVudElkQ291bnRlciIsIlJFX1JFTkRFUl9MSU1JVCIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwiaG9va1R5cGVzRGV2IiwiaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsIm1vdW50SG9va1R5cGVzRGV2IiwiaG9va05hbWUiLCJ1cGRhdGVIb29rVHlwZXNEZXYiLCJ3YXJuT25Ib29rTWlzbWF0Y2hJbkRldiIsImNoZWNrRGVwc0FyZUFycmF5RGV2IiwiZGVwcyIsImN1cnJlbnRIb29rTmFtZSIsInRhYmxlIiwic2Vjb25kQ29sdW1uU3RhcnQiLCJvbGRIb29rTmFtZSIsIm5ld0hvb2tOYW1lIiwidGhyb3dJbnZhbGlkSG9va0Vycm9yIiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsInJlbmRlcldpdGhIb29rcyIsInNlY29uZEFyZyIsIm5leHRSZW5kZXJMYW5lcyIsIl9kZWJ1Z0hvb2tUeXBlcyIsIkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJDb250ZXh0T25seURpc3BhdGNoZXIiLCJkaWRSZW5kZXJUb29GZXdIb29rcyIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwiYmFpbG91dEhvb2tzIiwicmVzZXRIb29rc0FmdGVyVGhyb3ciLCJpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlIiwibW91bnRXb3JrSW5Qcm9ncmVzc0hvb2siLCJiYXNlUXVldWUiLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXh0Q3VycmVudEhvb2siLCJuZXh0V29ya0luUHJvZ3Jlc3NIb29rIiwibmV3SG9vayIsImNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUiLCJsYXN0RWZmZWN0Iiwic3RvcmVzIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJhY3Rpb24iLCJtb3VudFJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwibGFzdFJlbmRlcmVkUmVkdWNlciIsImxhc3RSZW5kZXJlZFN0YXRlIiwiZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsImJhc2VGaXJzdCIsInBlbmRpbmdGaXJzdCIsImZpcnN0IiwibmV3QmFzZVF1ZXVlRmlyc3QiLCJuZXdCYXNlUXVldWVMYXN0IiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJpbnRlcmxlYXZlZExhbmUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwibW91bnRNdXRhYmxlU291cmNlIiwiZ2V0U25hcHNob3QiLCJzdWJzY3JpYmUiLCJ1cGRhdGVNdXRhYmxlU291cmNlIiwibW91bnRTeW5jRXh0ZXJuYWxTdG9yZSIsImdldFNlcnZlclNuYXBzaG90IiwibmV4dFNuYXBzaG90IiwiY2FjaGVkU25hcHNob3QiLCJnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QiLCJwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrIiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaEVmZmVjdCIsInVwZGF0ZVN0b3JlSW5zdGFuY2UiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsInByZXZTbmFwc2hvdCIsInNuYXBzaG90Q2hhbmdlZCIsInVwZGF0ZUVmZmVjdCIsInJlbmRlcmVkU25hcHNob3QiLCJjaGVjayIsImNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwiY2hlY2tJZlNuYXBzaG90Q2hhbmdlZCIsImZvcmNlU3RvcmVSZXJlbmRlciIsImhhbmRsZVN0b3JlQ2hhbmdlIiwibGF0ZXN0R2V0U25hcHNob3QiLCJwcmV2VmFsdWUiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsInVwZGF0ZVN0YXRlIiwicmVyZW5kZXJTdGF0ZSIsImNyZWF0ZSIsImRlc3Ryb3kiLCJmaXJzdEVmZmVjdCIsIm1vdW50UmVmIiwiaW5pdGlhbFZhbHVlIiwiX3JlZjIiLCJ1cGRhdGVSZWYiLCJtb3VudEVmZmVjdEltcGwiLCJob29rRmxhZ3MiLCJ1cGRhdGVFZmZlY3RJbXBsIiwicHJldkVmZmVjdCIsIm1vdW50SW5zZXJ0aW9uRWZmZWN0IiwidXBkYXRlSW5zZXJ0aW9uRWZmZWN0IiwibW91bnRMYXlvdXRFZmZlY3QiLCJ1cGRhdGVMYXlvdXRFZmZlY3QiLCJpbXBlcmF0aXZlSGFuZGxlRWZmZWN0IiwicmVmQ2FsbGJhY2siLCJfaW5zdCIsInJlZk9iamVjdCIsIl9pbnN0MiIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsImVmZmVjdERlcHMiLCJ1cGRhdGVJbXBlcmF0aXZlSGFuZGxlIiwibW91bnREZWJ1Z1ZhbHVlIiwiZm9ybWF0dGVyRm4iLCJ1cGRhdGVEZWJ1Z1ZhbHVlIiwibW91bnRDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwibW91bnRNZW1vIiwibmV4dENyZWF0ZSIsInVwZGF0ZU1lbW8iLCJtb3VudERlZmVycmVkVmFsdWUiLCJfbW91bnRTdGF0ZSIsInNldFZhbHVlIiwicHJldlRyYW5zaXRpb24iLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwiX3VwZGF0ZVN0YXRlIiwicmVyZW5kZXJEZWZlcnJlZFZhbHVlIiwiX3JlcmVuZGVyU3RhdGUiLCJzdGFydFRyYW5zaXRpb24iLCJzZXRQZW5kaW5nIiwib3B0aW9ucyIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJ1cGRhdGVkRmliZXJzQ291bnQiLCJtb3VudFRyYW5zaXRpb24iLCJfbW91bnRTdGF0ZTIiLCJpc1BlbmRpbmciLCJzdGFydCIsInVwZGF0ZVRyYW5zaXRpb24iLCJfdXBkYXRlU3RhdGUyIiwicmVyZW5kZXJUcmFuc2l0aW9uIiwiX3JlcmVuZGVyU3RhdGUyIiwiZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZ2xvYmFsQ2xpZW50SWQiLCJ1cGRhdGVJZCIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUiLCJtYXJrVXBkYXRlSW5EZXZUb29scyIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUlkIiwidW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJ3YXJuSW52YWxpZEhvb2tBY2Nlc3MiLCJub3ckMiIsImNvbW1pdFRpbWUiLCJsYXlvdXRFZmZlY3RTdGFydFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsInBhc3NpdmVFZmZlY3RTdGFydFRpbWUiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJpc0N1cnJlbnRVcGRhdGVOZXN0ZWQiLCJtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwicmVzZXROZXN0ZWRVcGRhdGVGbGFnIiwic3luY05lc3RlZFVwZGF0ZUZsYWciLCJnZXRDb21taXRUaW1lIiwicmVjb3JkQ29tbWl0VGltZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsImFjdHVhbFN0YXJ0VGltZSIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSIsIm92ZXJyaWRlQmFzZVRpbWUiLCJlbGFwc2VkVGltZSIsImFjdHVhbER1cmF0aW9uIiwic2VsZkJhc2VEdXJhdGlvbiIsInJlY29yZExheW91dEVmZmVjdER1cmF0aW9uIiwicGFyZW50RmliZXIiLCJlZmZlY3REdXJhdGlvbiIsInBhcmVudFN0YXRlTm9kZSIsInJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInN0YXJ0TGF5b3V0RWZmZWN0VGltZXIiLCJzdGFydFBhc3NpdmVFZmZlY3RUaW1lciIsInRyYW5zZmVyQWN0dWFsRHVyYXRpb24iLCJjcmVhdGVDYXB0dXJlZFZhbHVlIiwic2hvd0Vycm9yRGlhbG9nIiwiYm91bmRhcnkiLCJlcnJvckluZm8iLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJjb21wb25lbnRTdGFjayIsIl9zdXBwcmVzc0xvZ2dpbmciLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJjb21iaW5lZE1lc3NhZ2UiLCJzZXRUaW1lb3V0IiwiUG9zc2libHlXZWFrTWFwJDEiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJvblVuY2F1Z2h0RXJyb3IiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJjb21wb25lbnREaWRDYXRjaCIsIm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQiLCJhdHRhY2hQaW5nTGlzdGVuZXIiLCJwaW5nQ2FjaGUiLCJ0aHJlYWRJRHMiLCJwaW5nIiwicGluZ1N1c3BlbmRlZFJvb3QiLCJyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzIiwidGhlbiIsImF0dGFjaFJldHJ5TGlzdGVuZXIiLCJzdXNwZW5zZUJvdW5kYXJ5Iiwid2FrZWFibGVzIiwicmVzZXRTdXNwZW5kZWRDb21wb25lbnQiLCJzb3VyY2VGaWJlciIsInJvb3RSZW5kZXJMYW5lcyIsImN1cnJlbnRTb3VyY2UiLCJnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZSIsIm1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZSIsImN1cnJlbnRTdXNwZW5zZUJvdW5kYXJ5Iiwib2Zmc2NyZWVuRmliZXIiLCJvZmZzY3JlZW5Db250YWluZXIiLCJjb250YWluZXJQcm9wcyIsImN1cnJlbnRTb3VyY2VGaWJlciIsInRocm93RXhjZXB0aW9uIiwicmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSIsInVuY2F1Z2h0U3VzcGVuc2VFcnJvciIsIl9zdXNwZW5zZUJvdW5kYXJ5IiwicmVuZGVyRGlkRXJyb3IiLCJfZXJyb3JJbmZvIiwiaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeSIsIl9sYW5lIiwiX3VwZGF0ZSIsImdldFN1c3BlbmRlZENhY2hlIiwibWFya1VwZGF0ZSIsIm1hcmtSZWYiLCJoYWROb011dGF0aW9uc0VmZmVjdHMiLCJjb21wbGV0ZWRXb3JrIiwiZGlkQmFpbG91dCIsInN1YnRyZWVGbGFncyIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJ1cGRhdGVIb3N0VGV4dCIsIm5lZWRzVmlzaWJpbGl0eVRvZ2dsZSIsImlzSGlkZGVuIiwiY3VycmVudEhvc3RDb250ZXh0Iiwib2xkVGV4dCIsIm5ld1RleHQiLCJfaW5zdGFuY2UiLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJfaW5zdGFuY2UyIiwicG9ydGFsT3JSb290IiwiY2hpbGRyZW5VbmNoYW5nZWQiLCJjb250YWluZXIiLCJuZXdDaGlsZFNldCIsInBlbmRpbmdDaGlsZHJlbiIsImN1cnJlbnRJbnN0YW5jZSIsInJlY3ljbGFibGVJbnN0YW5jZSIsIm5ld0luc3RhbmNlIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwicmVuZGVyU3RhdGUiLCJoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2siLCJ0YWlsTW9kZSIsInRhaWxOb2RlIiwidGFpbCIsImxhc3RUYWlsTm9kZSIsIl90YWlsTm9kZSIsIl9sYXN0VGFpbE5vZGUiLCJidWJibGVQcm9wZXJ0aWVzIiwibmV3Q2hpbGRMYW5lcyIsInRyZWVCYXNlRHVyYXRpb24iLCJfdHJlZUJhc2VEdXJhdGlvbiIsIl9jaGlsZDIiLCJfY2hpbGQzIiwiY29tcGxldGVXb3JrIiwiZmliZXJSb290IiwicGVuZGluZ0NvbnRleHQiLCJ3YXNIeWRyYXRlZCIsIl93YXNIeWRyYXRlZCIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfY3VycmVudEhvc3RDb250ZXh0IiwiX3dhc0h5ZHJhdGVkMiIsIl93YXNIeWRyYXRlZDMiLCJpc1RpbWVkT3V0U3VzcGVuc2UiLCJwcmltYXJ5Q2hpbGRGcmFnbWVudCIsIl9pc1RpbWVkT3V0U3VzcGVuc2UiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJuZXh0RGlkVGltZW91dCIsInByZXZEaWRUaW1lb3V0IiwiX3ByZXZTdGF0ZSIsIl9vZmZzY3JlZW5GaWJlciIsImhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCIsInVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIiwicmVuZGVyRGlkU3VzcGVuZCIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDIiLCJfQ29tcG9uZW50IiwiZGlkU3VzcGVuZEFscmVhZHkiLCJyZW5kZXJlZFRhaWwiLCJjYW5ub3RCZVN1c3BlbmRlZCIsInJlbmRlckhhc05vdFN1c3BlbmRlZFlldCIsInN1c3BlbmRlZCIsIm5ld1RoZW5hYmxlcyIsImdldFJlbmRlclRhcmdldFRpbWUiLCJfc3VzcGVuZGVkIiwiX25ld1RoZW5hYmxlcyIsInJlbmRlcmluZ1N0YXJ0VGltZSIsImlzQmFja3dhcmRzIiwicHJldmlvdXNTaWJsaW5nIiwibGFzdCIsInN1c3BlbnNlQ29udGV4dCIsInBvcFJlbmRlckxhbmVzIiwiX25leHRTdGF0ZSIsIm5leHRJc0hpZGRlbiIsIl9wcmV2U3RhdGUyIiwicHJldklzSGlkZGVuIiwic3VidHJlZVJlbmRlckxhbmVzIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsImRpZFJlY2VpdmVVcGRhdGUiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsImRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzIiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUiLCJ1cGRhdGVGb3J3YXJkUmVmIiwiaW5uZXJQcm9wVHlwZXMiLCJoYXNJZCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50IiwiaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCIsImNvbXBhcmUiLCJyZXNvbHZlZFR5cGUiLCJyZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmciLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJ1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50IiwiY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzIiwiX2lubmVyUHJvcFR5cGVzIiwiaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwiY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQiLCJwcmV2UHJvcHMiLCJvdXRlck1lbW9UeXBlIiwib3V0ZXJQcm9wVHlwZXMiLCJ1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudCIsImJhc2VMYW5lcyIsImNhY2hlUG9vbCIsInB1c2hSZW5kZXJMYW5lcyIsInNwYXduZWRDYWNoZVBvb2wiLCJuZXh0QmFzZUxhbmVzIiwicHJldkJhc2VMYW5lcyIsIl9uZXh0U3RhdGUyIiwiX3N1YnRyZWVSZW5kZXJMYW5lcyIsInVwZGF0ZU1vZGUiLCJ1cGRhdGVQcm9maWxlciIsIm1hcmtSZWYkMSIsInVwZGF0ZUNsYXNzQ29tcG9uZW50Iiwic2hvdWxkRXJyb3IiLCJ0ZW1wSW5zdGFuY2UiLCJoYXNDb250ZXh0IiwibmV4dFVuaXRPZldvcmsiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsImRpZENhcHR1cmVFcnJvciIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJ1cGRhdGVIb3N0Um9vdCIsInByZXZDaGlsZHJlbiIsIm92ZXJyaWRlU3RhdGUiLCJjYWNoZSIsInRyYW5zaXRpb25zIiwicmVjb3ZlcmFibGVFcnJvciIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwiX3JlY292ZXJhYmxlRXJyb3IiLCJ1cGRhdGVIb3N0Q29tcG9uZW50JDEiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0JDEiLCJtb3VudExhenlDb21wb25lbnQiLCJfY3VycmVudCIsInJlc29sdmVkVGFnIiwicmVzb2x2ZUxhenlDb21wb25lbnRUYWciLCJyZXNvbHZlZFByb3BzIiwicmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nIiwicmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmciLCJoaW50IiwibW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJfY29tcG9uZW50TmFtZTIiLCJvd25lck5hbWUiLCJ3YXJuaW5nS2V5IiwiZGVidWdTb3VyY2UiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJfY29tcG9uZW50TmFtZTMiLCJfY29tcG9uZW50TmFtZTQiLCJTVVNQRU5ERURfTUFSS0VSIiwibW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwidXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZSIsInByZXZPZmZzY3JlZW5TdGF0ZSIsInNob3VsZFJlbWFpbk9uRmFsbGJhY2siLCJnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZSIsInVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50Iiwic2hvdWxkU3VzcGVuZCIsInNob3dGYWxsYmFjayIsIm1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50IiwibmV4dFByaW1hcnlDaGlsZHJlbiIsIm5leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2siLCJmYWxsYmFja0ZyYWdtZW50IiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4iLCJtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwiX2RlaHlkcmF0ZWQiLCJ1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQiLCJyZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuIiwiX25leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2tDaGlsZEZyYWdtZW50IiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmciLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4yIiwiX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsInVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbiIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDMiLCJfbmV4dFByaW1hcnlDaGlsZHJlbjMiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0IiwidXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zIiwiX25leHRQcmltYXJ5Q2hpbGRyZW40IiwiX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDIiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ1IiwiX3ByZXZPZmZzY3JlZW5TdGF0ZSIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuNSIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDYiLCJwcmltYXJ5Q2hpbGRyZW4iLCJwcmltYXJ5Q2hpbGRQcm9wcyIsIm1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlciIsImZhbGxiYWNrQ2hpbGRyZW4iLCJwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50Iiwib2Zmc2NyZWVuUHJvcHMiLCJjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4iLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50IiwiY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsImZpYmVyTW9kZSIsImF0dGVtcHRIeWRyYXRpb25BdExhbmUiLCJyZXRyeSIsInJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIiLCJwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2UiLCJmaXJzdENoaWxkIiwiZmluZExhc3RDb250ZW50Um93IiwibGFzdENvbnRlbnRSb3ciLCJjdXJyZW50Um93IiwidmFsaWRhdGVSZXZlYWxPcmRlciIsInRvTG93ZXJDYXNlIiwidmFsaWRhdGVUYWlsT3B0aW9ucyIsInZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQiLCJjaGlsZFNsb3QiLCJpc0FuQXJyYXkiLCJpc0l0ZXJhYmxlIiwidmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbiIsImNoaWxkcmVuSXRlcmF0b3IiLCJfaSIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsInNob3VsZEZvcmNlRmFsbGJhY2siLCJkaWRTdXNwZW5kQmVmb3JlIiwiX3RhaWwiLCJuZXh0Um93IiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJwcm92aWRlclR5cGUiLCJuZXdWYWx1ZSIsInByb3ZpZGVyUHJvcFR5cGVzIiwib2xkVmFsdWUiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIiLCJ1cGRhdGVDb250ZXh0Q29uc3VtZXIiLCJDb25zdW1lciIsInJlbW91bnRGaWJlciIsIm9sZFdvcmtJblByb2dyZXNzIiwibmV3V29ya0luUHJvZ3Jlc3MiLCJwcmV2U2libGluZyIsInVwZGF0ZUxhbmVzIiwiYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUiLCJoYXNDaGlsZFdvcmsiLCJwcmltYXJ5Q2hpbGRMYW5lcyIsIl9oYXNDaGlsZFdvcmsiLCJiZWdpbldvcmsiLCJfZGVidWdOZWVkc1JlbW91bnQiLCJ1bnJlc29sdmVkUHJvcHMiLCJfdW5yZXNvbHZlZFByb3BzIiwiX3Jlc29sdmVkUHJvcHMiLCJfdW5yZXNvbHZlZFByb3BzMiIsIl9yZXNvbHZlZFByb3BzMiIsIl91bnJlc29sdmVkUHJvcHMzIiwiX3Jlc29sdmVkUHJvcHMzIiwiX0NvbXBvbmVudDIiLCJfdW5yZXNvbHZlZFByb3BzNCIsIl9yZXNvbHZlZFByb3BzNCIsInVud2luZFdvcmsiLCJfZmxhZ3MiLCJfZmxhZ3MyIiwidW53aW5kSW50ZXJydXB0ZWRXb3JrIiwiaW50ZXJydXB0ZWRXb3JrIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZCIsImZ1bmMiLCJkIiwiZiIsImZ1bmNBcmdzIiwib25FcnJvciIsImludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiY3JlYXRlRWxlbWVudCIsImludm9rZUd1YXJkZWRDYWxsYmFja0RldiIsImV2dCIsImRpZENhbGwiLCJ3aW5kb3dFdmVudCIsImV2ZW50Iiwid2luZG93RXZlbnREZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicmVzdG9yZUFmdGVyRGlzcGF0Y2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZ0VHlwZSIsImRpZFNldEVycm9yIiwiaXNDcm9zc09yaWdpbkVycm9yIiwiaGFuZGxlV2luZG93RXJyb3IiLCJjb2xubyIsImxpbmVubyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpbm5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbml0RXZlbnQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEiLCJoYXNFcnJvciIsImNhdWdodEVycm9yIiwicmVwb3J0ZXIiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJoYXNDYXVnaHRFcnJvciIsImNsZWFyQ2F1Z2h0RXJyb3IiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJQb3NzaWJseVdlYWtTZXQiLCJXZWFrU2V0IiwibmV4dEVmZmVjdCIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290IiwicmVwb3J0VW5jYXVnaHRFcnJvckluREVWIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudCIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IiLCJjb21taXRIb29rRWZmZWN0TGlzdE1vdW50IiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQiLCJzYWZlbHlBdHRhY2hSZWYiLCJjb21taXRBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJyZXRWYWwiLCJzYWZlbHlDYWxsRGVzdHJveSIsImZvY3VzZWRJbnN0YW5jZUhhbmRsZSIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbiIsInNob3VsZEZpcmUiLCJlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJzbmFwc2hvdCIsImRpZFdhcm5TZXQiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCIsImNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMiLCJmaW5pc2hlZFJvb3QiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUiLCJvblBvc3RDb21taXQiLCJwaGFzZSIsIm91dGVyIiwiY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlciIsImNvbW1pdHRlZExhbmVzIiwiX3VwZGF0ZVF1ZXVlIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplMiIsIm9uQ29tbWl0Iiwib25SZW5kZXIiLCJlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdCIsImNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzIiwicmVhcHBlYXJMYXlvdXRFZmZlY3RzT25GaWJlciIsImhpZGVPclVuaGlkZUFsbENoaWxkcmVuIiwiaG9zdFN1YnRyZWVSb290IiwiX2luc3RhbmNlMyIsImluc3RhbmNlVG9Vc2UiLCJjb21taXREZXRhY2hSZWYiLCJjdXJyZW50UmVmIiwiY29tbWl0VW5tb3VudCIsIl9lZmZlY3QiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImNvbW1pdE5lc3RlZFVubW91bnRzIiwiZGV0YWNoRmliZXJNdXRhdGlvbiIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwiaG9zdEluc3RhbmNlIiwiZW1wdHlDaGlsZFNldCIsImNvbW1pdENvbnRhaW5lciIsImdldEhvc3RQYXJlbnRGaWJlciIsImlzSG9zdFBhcmVudCIsImdldEhvc3RTaWJsaW5nIiwic2libGluZ3MiLCJjb21taXRQbGFjZW1lbnQiLCJiZWZvcmUiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUiLCJfcGFyZW50IiwiX2JlZm9yZSIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJpc0hvc3QiLCJjdXJyZW50UGFyZW50SXNWYWxpZCIsImN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciIsImZpbmRQYXJlbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRTdXNwZW5zZUNhbGxiYWNrIiwiYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyIsInByZXZSb290U3RhdGUiLCJfcHJldlJvb3RTdGF0ZSIsIl9yb290IiwicmV0cnlDYWNoZSIsInJlc29sdmVSZXRyeVdha2VhYmxlIiwiY29tbWl0UmVzZXRUZXh0Q29udGVudCIsImNvbW1pdE11dGF0aW9uRWZmZWN0cyIsImNvbW1pdE11dGF0aW9uRWZmZWN0c19iZWdpbiIsImNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJ3YXNIaWRkZW4iLCJtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2siLCJfbmV3U3RhdGUiLCJfaXNIaWRkZW4iLCJfY3VycmVudDIiLCJfd2FzSGlkZGVuIiwib2Zmc2NyZWVuQm91bmRhcnkiLCJvZmZzY3JlZW5DaGlsZCIsImRpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4iLCJwcmltYXJ5RmxhZ3MiLCJfY3VycmVudDMiLCJfY3VycmVudDQiLCJfY3VycmVudDUiLCJjb21taXRMYXlvdXRFZmZlY3RzIiwiY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbiIsInN1YnRyZWVSb290IiwiaXNNb2Rlcm5Sb290IiwibmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwiY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlIiwibmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInJlYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbiIsImRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUiLCJyZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUiLCJjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbiIsImNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUiLCJjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2JlZ2luIiwiZmliZXJUb0RlbGV0ZSIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4iLCJwcmV2aW91c0ZpYmVyIiwiZGV0YWNoZWRDaGlsZCIsImRldGFjaGVkU2libGluZyIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsImNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZSIsImRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIiLCJleHBlY3RlZFJldHVybkZpYmVyIiwiaW52b2tlTGF5b3V0RWZmZWN0TW91bnRJbkRFViIsImludm9rZVBhc3NpdmVFZmZlY3RNb3VudEluREVWIiwiaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWIiwiaW52b2tlUGFzc2l2ZUVmZmVjdFVubW91bnRJbkRFViIsIkNPTVBPTkVOVF9UWVBFIiwiSEFTX1BTRVVET19DTEFTU19UWVBFIiwiUk9MRV9UWVBFIiwiVEVTVF9OQU1FX1RZUEUiLCJURVhUX1RZUEUiLCJzeW1ib2xGb3IiLCJjcmVhdGVDb21wb25lbnRTZWxlY3RvciIsImNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IiLCJzZWxlY3RvcnMiLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGV4dFNlbGVjdG9yIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdCIsImhvc3RSb290IiwibWF5YmVGaWJlciIsIm1hdGNoU2VsZWN0b3IiLCJzZWxlY3RvciIsImhhc01hdGNoaW5nUGF0aHMiLCJpbmRleE9mIiwiZGF0YVRlc3RJRCIsInNlbGVjdG9yVG9TdHJpbmciLCJmaW5kUGF0aHMiLCJtYXRjaGluZ0ZpYmVycyIsInNlbGVjdG9ySW5kZXgiLCJmaW5kQWxsTm9kZXMiLCJpbnN0YW5jZVJvb3RzIiwiZnJvbSIsImdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiIsIm1heFNlbGVjdG9ySW5kZXgiLCJtYXRjaGVkTmFtZXMiLCJ1bm1hdGNoZWROYW1lcyIsImZpbmRCb3VuZGluZ1JlY3RzIiwiYm91bmRpbmdSZWN0cyIsInRhcmdldFJlY3QiLCJ0YXJnZXRMZWZ0IiwidGFyZ2V0UmlnaHQiLCJ3aWR0aCIsInRhcmdldFRvcCIsInRhcmdldEJvdHRvbSIsImhlaWdodCIsImoiLCJvdGhlclJlY3QiLCJvdGhlckxlZnQiLCJvdGhlclJpZ2h0Iiwib3RoZXJUb3AiLCJvdGhlckJvdHRvbSIsInNwbGljZSIsImZvY3VzV2l0aGluIiwiY29tbWl0SG9va3MiLCJvbkNvbW1pdFJvb3QkMSIsImNvbW1pdEhvb2siLCJvYnNlcnZlVmlzaWJsZVJlY3RzIiwiX3NldHVwSW50ZXJzZWN0aW9uT2JzIiwiZGlzY29ubmVjdCIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJuZXh0SW5zdGFuY2VSb290cyIsInRhcmdldCIsIlJlYWN0Q3VycmVudEFjdFF1ZXVlIiwiaXNMZWdhY3lBY3RFbnZpcm9ubWVudCIsImlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCIsIklTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCIsImplc3RJc0RlZmluZWQiLCJqZXN0IiwiaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQiLCJjZWlsIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyIiwiUmVhY3RDdXJyZW50T3duZXIkMiIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIiLCJSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxIiwiTm9Db250ZXh0IiwiQmF0Y2hlZENvbnRleHQiLCJSZW5kZXJDb250ZXh0IiwiQ29tbWl0Q29udGV4dCIsIlJvb3RJblByb2dyZXNzIiwiUm9vdEZhdGFsRXJyb3JlZCIsIlJvb3RFcnJvcmVkIiwiUm9vdFN1c3BlbmRlZCIsIlJvb3RTdXNwZW5kZWRXaXRoRGVsYXkiLCJSb290Q29tcGxldGVkIiwiUm9vdERpZE5vdENvbXBsZXRlIiwiZXhlY3V0aW9uQ29udGV4dCIsIndvcmtJblByb2dyZXNzUm9vdCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwic3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yIiwid29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyIsIndvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyIsImdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUiLCJGQUxMQkFDS19USFJPVFRMRV9NUyIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUiLCJJbmZpbml0eSIsIlJFTkRFUl9USU1FT1VUX01TIiwicmVzZXRSZW5kZXJUaW1lciIsImhhc1VuY2F1Z2h0RXJyb3IiLCJmaXJzdFVuY2F1Z2h0RXJyb3IiLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsInJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIiwicm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyIsInBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50Iiwicm9vdFdpdGhOZXN0ZWRVcGRhdGVzIiwiTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUIiwibmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50IiwiY3VycmVudEV2ZW50VGltZSIsImN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lIiwiaXNUcmFuc2l0aW9uIiwiZXZlbnRMYW5lIiwicmVxdWVzdFJldHJ5TGFuZSIsImNoZWNrRm9yTmVzdGVkVXBkYXRlcyIsIm1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290Iiwid2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYiLCJ3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYiLCJtYXJrUm9vdFN1c3BlbmRlZCQxIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwiaXNCYXRjaGluZ0xlZ2FjeSIsInNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdCIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJleGlzdGluZ0NhbGxiYWNrTm9kZSIsImNhbGxiYWNrTm9kZSIsImNhbmNlbENhbGxiYWNrJDEiLCJjYWxsYmFja1ByaW9yaXR5IiwibmV3Q2FsbGJhY2tQcmlvcml0eSIsImV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSIsImZha2VBY3RDYWxsYmFja05vZGUiLCJuZXdDYWxsYmFja05vZGUiLCJkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsInNjaGVkdWxlQ2FsbGJhY2skMSIsInNjaGVkdWxlclByaW9yaXR5TGV2ZWwiLCJwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QiLCJkaWRUaW1lb3V0Iiwib3JpZ2luYWxDYWxsYmFja05vZGUiLCJkaWRGbHVzaFBhc3NpdmVFZmZlY3RzIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsInNob3VsZFRpbWVTbGljZSIsImV4aXRTdGF0dXMiLCJyZW5kZXJSb290Q29uY3VycmVudCIsInJlbmRlclJvb3RTeW5jIiwiZXJyb3JSZXRyeUxhbmVzIiwicmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3IiLCJmYXRhbEVycm9yIiwicHJlcGFyZUZyZXNoU3RhY2siLCJyZW5kZXJXYXNDb25jdXJyZW50IiwiaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzIiwiX2Vycm9yUmV0cnlMYW5lcyIsIl9mYXRhbEVycm9yIiwiZmluaXNoZWRMYW5lcyIsImZpbmlzaENvbmN1cnJlbnRSZW5kZXIiLCJlcnJvcnNGcm9tRmlyc3RBdHRlbXB0Iiwicm9vdFdvcmtJblByb2dyZXNzIiwiZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQiLCJlcnJvcnMiLCJjb21taXRSb290Iiwic2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWIiwibXNVbnRpbFRpbWVvdXQiLCJ0aW1lb3V0SGFuZGxlIiwiZXZlbnRUaW1lTXMiLCJ0aW1lRWxhcHNlZE1zIiwiX21zVW50aWxUaW1lb3V0Iiwiam5kIiwiY2hlY2tzIiwicmVuZGVyZWRWYWx1ZSIsImZsdXNoUm9vdCIsImRlZmVycmVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwicHJldkV4ZWN1dGlvbkNvbnRleHQiLCJkaXNjcmV0ZVVwZGF0ZXMiLCJmbHVzaFN5bmMiLCJpc0FscmVhZHlSZW5kZXJpbmciLCJmbHVzaENvbnRyb2xsZWQiLCJoYW5kbGVFcnJvciIsImVycm9yZWRXb3JrIiwiY29tcGxldGVVbml0T2ZXb3JrIiwieWV0QW5vdGhlclRocm93blZhbHVlIiwicHVzaERpc3BhdGNoZXIiLCJwb3BEaXNwYXRjaGVyIiwid29ya0xvb3BTeW5jIiwicGVyZm9ybVVuaXRPZldvcmsiLCJ3b3JrTG9vcENvbmN1cnJlbnQiLCJ1bml0T2ZXb3JrIiwiYmVnaW5Xb3JrJDEiLCJfbmV4dCIsInNpYmxpbmdGaWJlciIsInJlY292ZXJhYmxlRXJyb3JzIiwicHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkiLCJjb21taXRSb290SW1wbCIsInJlbmRlclByaW9yaXR5TGV2ZWwiLCJmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYiLCJzdWJ0cmVlSGFzRWZmZWN0cyIsInJvb3RIYXNFZmZlY3QiLCJyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzIiwiY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwib25SZWNvdmVyYWJsZUVycm9yIiwicmVuZGVyUHJpb3JpdHkiLCJmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCIsInByb2ZpbGVyRWZmZWN0cyIsIl9maWJlciIsInByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvciIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290Iiwicm9vdEZpYmVyIiwid2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwidGltZUVsYXBzZWQiLCJoYXNQYXNzaXZlRWZmZWN0cyIsImludm9rZUVmZmVjdHNJbkRldiIsImludm9rZUVmZmVjdEZuIiwicHJpbWFyeVN1YnRyZWVGbGFnIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCIsImR1bW15RmliZXIiLCJvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSIsImFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWIiwib3JpZ2luYWxFcnJvciIsInJlcGxheUVycm9yIiwiZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJyZW5kZXJpbmdDb21wb25lbnROYW1lIiwiZGVkdXBlS2V5Iiwic2V0U3RhdGVDb21wb25lbnROYW1lIiwic2NoZWR1bGluZ0ZpYmVyIiwicHJpb3JpdHlMZXZlbCIsImFjdFF1ZXVlIiwicmVzb2x2ZUZhbWlseSIsImZhaWxlZEJvdW5kYXJpZXMiLCJzZXRSZWZyZXNoSGFuZGxlciIsImhhbmRsZXIiLCJmYW1pbHkiLCJjdXJyZW50UmVuZGVyIiwic3ludGhldGljVHlwZSIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJuZWVkc0NvbXBhcmVGYW1pbGllcyIsIiQkdHlwZW9mTmV4dFR5cGUiLCJwcmV2RmFtaWx5Iiwic2NoZWR1bGVSZWZyZXNoIiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsInNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkiLCJzY2hlZHVsZVJvb3QiLCJ1cGRhdGVDb250YWluZXIiLCJjYW5kaWRhdGVUeXBlIiwibmVlZHNSZW5kZXIiLCJuZWVkc1JlbW91bnQiLCJmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2giLCJmYW1pbGllcyIsImhvc3RJbnN0YW5jZXMiLCJ0eXBlcyIsImZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseSIsImRpZE1hdGNoIiwiZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImZvdW5kSG9zdEluc3RhbmNlcyIsImZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwiRmliZXJOb2RlIiwiTnVtYmVyIiwiTmFOIiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QkMSIsImN1cnJlbnREZXBlbmRlbmNpZXMiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiaXNTdHJpY3RNb2RlIiwiY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSIsImZpYmVyVGFnIiwiZ2V0VGFnIiwiY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIiLCJjcmVhdGVGaWJlckZyb21TdXNwZW5zZSIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdCIsImVsZW1lbnRzIiwicHJpbWFyeUNoaWxkSW5zdGFuY2UiLCJjb250ZW50IiwiZGVoeWRyYXRlZE5vZGUiLCJGaWJlclJvb3ROb2RlIiwiaHlkcmF0ZSIsIl9kZWJ1Z1Jvb3RUeXBlIiwiY3JlYXRlRmliZXJSb290IiwiaW5pdGlhbENoaWxkcmVuIiwiaHlkcmF0aW9uQ2FsbGJhY2tzIiwidHJhbnNpdGlvbkNhbGxiYWNrcyIsInVuaW5pdGlhbGl6ZWRGaWJlciIsIl9pbml0aWFsU3RhdGUiLCJSZWFjdFZlcnNpb24iLCJjcmVhdGVQb3J0YWwiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsImZpbmRIb3N0SW5zdGFuY2UiLCJob3N0RmliZXIiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiY3JlYXRlQ29udGFpbmVyIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwiY3VycmVudCQxIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiY29udGFpbmVyRmliZXIiLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZCIsIm1hcmtSZXRyeUxhbmVJbXBsIiwiYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24iLCJhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsInNob3VsZEVycm9ySW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwiY29weVdpdGhEZWxldGVJbXBsIiwib2JqIiwicGF0aCIsInVwZGF0ZWQiLCJjb3B5V2l0aERlbGV0ZSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZFBhdGgiLCJuZXdQYXRoIiwib2xkS2V5IiwibmV3S2V5IiwiY29weVdpdGhSZW5hbWUiLCJjb3B5V2l0aFNldEltcGwiLCJjb3B5V2l0aFNldCIsImZpbmRIb29rIiwibmV3U2hvdWxkRXJyb3JJbXBsIiwibmV3U2hvdWxkU3VzcGVuZEltcGwiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyIsImluamVjdEludG9EZXZUb29scyIsImRldlRvb2xzQ29uZmlnIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsInJlbmRlcmVyQ29uZmlnIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJnZXRDdXJyZW50RmliZXIiLCJyZWNvbmNpbGVyVmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/react-reconciler/constants.js":
/*!*****************************************************!*\
  !*** ../node_modules/react-reconciler/constants.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/../node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLG1MQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRpZm9saW8yMDI0Ly4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cy5qcz8yMTdiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/react-reconciler/index.js":
/*!*************************************************!*\
  !*** ../node_modules/react-reconciler/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/../node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsK0pBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGlmb2xpbzIwMjQvLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvaW5kZXguanM/ODBlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/react-reconciler/index.js\n");

/***/ })

};
;